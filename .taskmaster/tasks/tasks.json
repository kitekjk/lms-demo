{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "프로젝트 초기 설정 및 기술 스택 구성",
        "description": "Spring Boot 3.5+ Kotlin 기반 백엔드 프로젝트 초기화, MySQL 데이터베이스 설정, JWT 인증 기반 구조 구축, libs.versions.toml을 통한 의존성 버전 관리",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "1. Spring Boot 3.5+ 프로젝트 생성 (Kotlin DSL)\n2. libs.versions.toml을 사용한 의존성 버전 관리 설정:\n   - Gradle Version Catalog 구성\n   - 모든 라이브러리 버전을 중앙 집중식으로 관리\n3. 필요한 의존성 추가:\n   - spring-boot-starter-web\n   - spring-boot-starter-data-jpa\n   - spring-boot-starter-security\n   - mysql-connector-java\n   - jjwt (JWT 라이브러리)\n   - kotlin-reflect\n4. application.yml 설정:\n   - MySQL 연결 정보 (datasource)\n   - JPA 설정 (hibernate ddl-auto, show-sql)\n   - JWT 시크릿 키 및 만료 시간\n5. 프로젝트 패키지 구조 생성:\n   - controller\n   - application (service)\n   - domain (entity, repository, service)\n   - infrastructure (security, config)\n6. JWT 기반 인증 필터 구현:\n   - JwtTokenProvider 클래스\n   - JwtAuthenticationFilter\n   - SecurityConfig (RBAC 설정)\n7. CORS 설정 (Flutter Web, Mobile 앱 연동 대비)\n8. 공통 응답 DTO 및 예외 처리 핸들러 구현",
        "testStrategy": "1. Spring Boot 애플리케이션 정상 구동 확인\n2. libs.versions.toml을 통한 의존성 버전 관리 검증\n3. MySQL 연결 테스트\n4. JWT 토큰 생성 및 검증 단위 테스트\n5. Security 설정 테스트 (인증/인가 필터 동작 확인)\n6. 기본 Health Check 엔드포인트 테스트",
        "subtasks": [
          {
            "id": 1,
            "title": "libs.versions.toml 생성 및 의존성 버전 관리 설정",
            "description": "Gradle Version Catalog를 사용하여 libs.versions.toml 파일을 생성하고 모든 라이브러리 버전을 중앙 집중식으로 관리합니다.",
            "dependencies": [],
            "details": "gradle/libs.versions.toml 파일을 생성하고 [versions], [libraries], [plugins] 섹션을 구성합니다. Spring Boot, Kotlin, MySQL Connector, JWT, JPA 등 모든 의존성의 버전을 [versions]에 정의하고, [libraries]에서 각 라이브러리를 참조합니다. [plugins]에는 Spring Boot, Kotlin JVM, Kotlin Spring 플러그인을 정의합니다. settings.gradle.kts에서 dependencyResolutionManagement를 설정하여 Version Catalog를 활성화합니다.\n<info added on 2026-01-16T05:56:11.319Z>\n구현 완료: Gradle 8.5 및 Version Catalog 기반 멀티모듈 프로젝트 구조 설정 완료. gradle/libs.versions.toml에 Kotlin 1.9.22, Spring Boot 3.2.2, MySQL 8.3.0, JWT(jjwt 0.12.5), Kotest 의존성 정의. DDD 아키텍처 기반 4개 모듈 생성(domain, application, infrastructure, interfaces). settings.gradle.kts에 모듈 정의 및 dependencyResolutionManagement 설정. 루트 및 각 모듈별 build.gradle.kts 작성(domain은 순수 Kotlin, application은 Spring Context, infrastructure는 JPA/MySQL, interfaces는 Spring Boot Web/Security). Gradle Wrapper 8.5 다운로드 및 설정. ./gradlew :domain:dependencies 및 ./gradlew :interfaces:dependencies 실행으로 의존성 해결 검증 완료. libs.xxx 표기법으로 모든 의존성 정상 참조 확인.\n</info added on 2026-01-16T05:56:11.319Z>",
            "status": "done",
            "testStrategy": "libs.versions.toml 파일이 올바르게 파싱되는지 확인하고, build.gradle.kts에서 libs.xxx 형태로 의존성을 참조할 수 있는지 검증합니다. ./gradlew dependencies 명령어로 의존성 트리를 확인하여 버전이 올바르게 적용되었는지 테스트합니다.",
            "updatedAt": "2026-01-16T05:56:19.094Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Spring Boot 프로젝트 생성 및 Version Catalog 기반 의존성 설정",
            "description": "Spring Boot 3.5+ Kotlin 프로젝트를 생성하고 libs.versions.toml에 정의된 의존성을 build.gradle.kts에서 참조하여 추가합니다.",
            "dependencies": [
              1
            ],
            "details": "Spring Initializr 또는 IntelliJ IDEA를 사용하여 Spring Boot 3.5+ Kotlin 프로젝트를 생성합니다. build.gradle.kts에서 libs.versions.toml에 정의된 의존성을 libs.spring.boot.starter.web, libs.spring.boot.starter.data.jpa, libs.spring.boot.starter.security, libs.mysql.connector.java, libs.jjwt.api, libs.jjwt.impl, libs.jjwt.jackson, libs.kotlin.reflect, libs.kotlin.stdlib.jdk8 형태로 참조하여 추가합니다. Kotlin DSL을 사용하여 프로젝트를 구성하고 Java 17 이상을 타겟으로 설정합니다.\n<info added on 2026-01-16T06:10:59.350Z>\nSpring Boot 애플리케이션 진입점 생성 완료: LmsApplication.kt 파일을 com.lms 패키지에 @SpringBootApplication 어노테이션과 함께 생성하고 컴포넌트 스캔을 위한 scanBasePackages를 설정했습니다. application.yml 설정 파일 생성 완료: MySQL 데이터소스 설정(localhost:3306/lms_demo), JPA/Hibernate 설정(ddl-auto: validate, show-sql, format_sql), 서버 포트 8080, 로깅 레벨을 구성했습니다. JVM 호환성 문제 해결: 루트 build.gradle.kts에 JavaCompile 설정을 추가하여 sourceCompatibility와 targetCompatibility를 Java 17로 설정하고 Kotlin JVM 타겟 17과 일치시켰습니다. 빌드 및 실행 검증 완료: ./gradlew clean build 성공, Spring Boot 애플리케이션 정상 시작, Tomcat 포트 8080 초기화 확인, Spring Security 자동 설정 로드, JPA EntityManagerFactory 초기화 완료, libs.versions.toml의 모든 의존성 정상 해결(Spring Boot 3.2.2, MySQL Connector 8.3.0, JWT jjwt 0.12.5, Kotlin 1.9.22). 데이터베이스 연결 실패는 예상된 동작이며 Subtask 1.3에서 해결 예정입니다.\n</info added on 2026-01-16T06:10:59.350Z>",
            "status": "done",
            "testStrategy": "Spring Boot 애플리케이션이 정상적으로 구동되는지 확인하고, 모든 의존성이 올바르게 로드되는지 검증합니다. ./gradlew build 명령어로 빌드가 성공하는지 테스트하고, Version Catalog를 통해 의존성이 올바르게 해석되는지 확인합니다.",
            "parentId": "undefined",
            "updatedAt": "2026-01-16T06:10:59.403Z"
          },
          {
            "id": 3,
            "title": "application.yml 설정 및 프로젝트 패키지 구조 생성",
            "description": "MySQL 데이터베이스 연결 정보, JPA 설정, JWT 설정을 application.yml에 구성하고 DDD 기반 패키지 구조를 생성합니다.",
            "dependencies": [
              2
            ],
            "details": "application.yml에 MySQL datasource 설정(url, username, password), JPA 설정(hibernate.ddl-auto: validate, show-sql: true, format_sql: true), JWT 설정(secret-key, access-token-expiration, refresh-token-expiration)을 추가합니다. 프로젝트 루트 패키지 하위에 controller, application(service), domain(entity, repository, service), infrastructure(security, config) 패키지를 생성합니다.\n<info added on 2026-01-16T06:15:59.634Z>\n구현 완료 사항:\n\n1. application.yml 다중 프로파일 구성 완료:\n   - dev/prod 프로파일 분리 (application-dev.yml, application-prod.yml)\n   - HikariCP 커넥션 풀 설정 추가 (최소/최대 연결 수, 타임아웃)\n   - JPA/Hibernate 성능 최적화 설정 (batch_size, order_inserts, SQL 주석)\n   - Jackson JSON 설정 추가 (타임존: Asia/Seoul)\n   - JWT 설정 섹션 구성 (secret-key, access/refresh 토큰 만료 시간)\n   - 서버 에러 핸들링 설정 강화\n   - 디버깅용 로깅 레벨 개선\n   - .env.example 파일에 LMS 환경 변수 템플릿 추가\n\n2. DDD 기반 완전한 패키지 구조 생성 (13개 패키지):\n   - Domain 모듈 (com.lms.domain): model/, service/, exception/, event/, common/\n   - Application 모듈 (com.lms.application): 애플리케이션 서비스\n   - Infrastructure 모듈 (com.lms.infrastructure): persistence/, security/, config/\n   - Interfaces 모듈 (com.lms.interfaces): web/controller/, web/dto/\n   - 각 패키지에 .gitkeep 파일 배치하여 구조 유지\n\n3. JwtProperties 설정 클래스 구현:\n   - @ConfigurationProperties를 통한 타입 안전 JWT 설정 바인딩\n   - 모든 속성에 기본값 설정\n   - application.yml의 jwt.* 설정과 자동 매핑\n\n4. Infrastructure 모듈 빌드 설정 수정:\n   - Spring Boot BOM import 추가로 의존성 관리 개선\n   - Configuration processor 의존성 추가\n   - 의존성 해결 문제 수정 완료\n\n5. 프로젝트 문서화 완료 (ARCHITECTURE.md):\n   - 전체 프로젝트 구조 및 모듈별 책임 명시\n   - DDD 패턴 및 컨벤션 가이드\n   - 데이터 흐름 다이어그램\n   - 테스트 전략 및 실행/배포 가이드\n\n검증 완료:\n- ./gradlew clean build 성공\n- 모든 모듈 컴파일 정상\n- ConfigurationTest 통과 (JWT 설정 로드 확인)\n- 다중 프로파일 동작 확인 (dev/prod)\n- 패키지 구조 생성 확인 (13개 패키지)\n</info added on 2026-01-16T06:15:59.634Z>",
            "status": "done",
            "testStrategy": "MySQL 데이터베이스 연결 테스트를 수행하고, application.yml의 설정값이 올바르게 로드되는지 확인합니다. @Value 어노테이션으로 설정값을 주입받아 출력하는 테스트를 작성합니다.",
            "parentId": "undefined",
            "updatedAt": "2026-01-16T06:15:59.684Z"
          },
          {
            "id": 4,
            "title": "JWT 인증 필터 및 토큰 프로바이더 구현",
            "description": "JWT 토큰 생성, 검증, 파싱을 담당하는 JwtTokenProvider와 요청을 가로채는 JwtAuthenticationFilter를 구현합니다.",
            "dependencies": [
              3
            ],
            "details": "JwtTokenProvider 클래스를 생성하여 generateAccessToken(), generateRefreshToken(), validateToken(), getAuthentication(), getUserIdFromToken() 메서드를 구현합니다. JWT 토큰에 사용자 ID, 역할(role), 매장 ID를 클레임으로 포함시킵니다. JwtAuthenticationFilter를 OncePerRequestFilter를 상속받아 구현하고, Authorization 헤더에서 Bearer 토큰을 추출하여 검증한 후 SecurityContext에 인증 정보를 설정합니다.",
            "status": "done",
            "testStrategy": "JWT 토큰 생성 및 파싱 단위 테스트를 작성합니다. 유효한 토큰, 만료된 토큰, 잘못된 서명의 토큰에 대한 검증 테스트를 수행합니다. JwtAuthenticationFilter의 동작을 MockMvc를 사용하여 통합 테스트합니다.",
            "parentId": "undefined",
            "updatedAt": "2026-01-16T06:59:31.449Z"
          },
          {
            "id": 5,
            "title": "Spring Security 설정 및 RBAC 구성",
            "description": "SecurityConfig를 구성하여 JWT 필터를 등록하고, RBAC(Role Based Access Control)를 설정하며, CORS 정책을 구현합니다.",
            "dependencies": [
              4
            ],
            "details": "SecurityConfig 클래스에 @EnableWebSecurity, @EnableMethodSecurity(prePostEnabled = true)를 추가합니다. SecurityFilterChain을 빈으로 등록하고, JwtAuthenticationFilter를 UsernamePasswordAuthenticationFilter 앞에 추가합니다. CORS 설정을 추가하여 Flutter Web 및 Mobile 앱의 요청을 허용합니다(allowedOrigins, allowedMethods, allowedHeaders, allowCredentials). PasswordEncoder로 BCryptPasswordEncoder를 빈으로 등록합니다. /api/auth/** 경로는 permitAll()로 설정하고 나머지는 authenticated()로 설정합니다.",
            "status": "done",
            "testStrategy": "Security 설정 테스트를 수행하여 인증이 필요한 엔드포인트에 토큰 없이 접근 시 401 응답이 반환되는지 확인합니다. CORS 설정이 올바르게 동작하는지 preflight 요청을 테스트합니다. 역할별 권한 테스트를 @PreAuthorize 어노테이션과 함께 수행합니다.",
            "parentId": "undefined",
            "updatedAt": "2026-01-16T07:00:51.459Z"
          },
          {
            "id": 6,
            "title": "공통 응답 DTO 및 전역 예외 처리 핸들러 구현",
            "description": "API 응답의 일관성을 위한 공통 응답 DTO와 전역 예외를 처리하는 GlobalExceptionHandler를 구현합니다.",
            "dependencies": [
              3
            ],
            "details": "ApiResponse<T> 데이터 클래스를 생성하여 success(Boolean), message(String), data(T), timestamp(LocalDateTime) 필드를 포함시킵니다. @RestControllerAdvice를 사용하여 GlobalExceptionHandler 클래스를 생성하고, @ExceptionHandler로 다양한 예외를 처리합니다(MethodArgumentNotValidException, AccessDeniedException, EntityNotFoundException, IllegalArgumentException, Exception). 각 예외에 대해 적절한 HTTP 상태 코드와 에러 메시지를 포함한 ApiResponse를 반환합니다. 커스텀 예외 클래스들(BusinessException, UnauthorizedException 등)을 생성합니다.",
            "status": "done",
            "testStrategy": "각 예외 타입에 대한 핸들러가 올바른 HTTP 상태 코드와 메시지를 반환하는지 테스트합니다. MockMvc를 사용하여 validation 에러, 인증 에러, 권한 에러 등의 시나리오를 테스트합니다. Health Check 엔드포인트(/actuator/health)를 추가하고 정상 응답을 확인합니다.",
            "parentId": "undefined",
            "updatedAt": "2026-01-16T07:02:06.151Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Spring Boot 3.5+ Kotlin 프로젝트 초기화, MySQL 데이터베이스 연결, JWT 인증 인프라 구축, 패키지 구조 설정, 공통 응답 DTO 및 예외 처리 핸들러 구현을 포함하는 5개의 세부 작업으로 분해하세요. 각 작업은 독립적으로 테스트 가능하고 명확한 완료 기준을 가져야 합니다.",
        "updatedAt": "2026-01-16T07:02:06.151Z"
      },
      {
        "id": "2",
        "title": "도메인 모델 및 데이터베이스 스키마 설계",
        "description": "DDD 기반 도메인 엔티티 설계 및 MySQL 데이터베이스 스키마 구현 (Employee, Store, WorkSchedule, AttendanceRecord, LeaveRequest, Payroll)",
        "details": "1. Employee 엔티티:\n   - employeeId (PK, UUID)\n   - name, email, password (암호화)\n   - employeeType (ENUM: REGULAR, IRREGULAR, PART_TIME)\n   - storeId (FK)\n   - remainingLeave (Decimal)\n   - role (ENUM: SUPER_ADMIN, MANAGER, EMPLOYEE)\n   - isActive (Boolean)\n   - createdAt, updatedAt\n\n2. Store 엔티티:\n   - storeId (PK, UUID)\n   - name, location\n   - createdAt, updatedAt\n\n3. WorkSchedule 엔티티:\n   - scheduleId (PK, UUID)\n   - employeeId (FK)\n   - workDate (Date)\n   - startTime, endTime (Time)\n   - createdAt, updatedAt\n\n4. AttendanceRecord 엔티티:\n   - recordId (PK, UUID)\n   - employeeId (FK)\n   - checkInTime, checkOutTime (Timestamp)\n   - adjusted (Boolean)\n   - adjustedBy (FK to Employee)\n   - adjustmentReason (Text)\n   - createdAt, updatedAt\n\n5. LeaveRequest 엔티티:\n   - leaveId (PK, UUID)\n   - employeeId (FK)\n   - leaveType (ENUM: ANNUAL, HALF_DAY, HOLIDAY)\n   - startDate, endDate (Date)\n   - status (ENUM: REQUESTED, APPROVED, REJECTED)\n   - approvedBy (FK to Employee)\n   - createdAt, updatedAt\n\n6. Payroll 엔티티:\n   - payrollId (PK, UUID)\n   - employeeId (FK)\n   - period (String, YYYY-MM)\n   - baseAmount, overtimeAmount, totalAmount (Decimal)\n   - calculatedAt, createdAt\n\n7. PayrollPolicy 엔티티:\n   - policyId (PK, UUID)\n   - policyType (ENUM: WEEKDAY, NIGHT, WEEKEND, HOLIDAY)\n   - multiplier (Decimal)\n   - effectiveFrom, effectiveTo (Date)\n\n8. AuditLog 엔티티 (변경 이력 추적):\n   - logId (PK, UUID)\n   - entityType, entityId\n   - action, changedBy\n   - oldValue, newValue (JSON)\n   - createdAt\n\n9. JPA Repository 인터페이스 생성\n10. 인덱스 설정 (employeeId, storeId, workDate 등)",
        "testStrategy": "1. 엔티티 매핑 테스트 (JPA 스키마 생성 확인)\n2. Repository 기본 CRUD 테스트\n3. 연관관계 매핑 테스트 (FK 제약조건)\n4. 데이터베이스 제약조건 테스트 (NOT NULL, UNIQUE)\n5. 인덱스 생성 확인",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "핵심 도메인 엔티티 설계 및 구현 (Employee, Store)",
            "description": "DDD 기반으로 Employee와 Store 엔티티를 설계하고 JPA 어노테이션을 사용하여 구현합니다. UUID 기반 PK, ENUM 타입, 암호화 필드 등을 포함합니다.",
            "dependencies": [],
            "details": "1. Employee 엔티티 구현: employeeId(UUID), name, email, password(BCrypt 암호화), employeeType(ENUM), storeId(FK), remainingLeave, role(ENUM), isActive, createdAt, updatedAt\n2. Store 엔티티 구현: storeId(UUID), name, location, createdAt, updatedAt\n3. JPA 어노테이션 설정: @Entity, @Id, @GeneratedValue, @Enumerated, @ManyToOne\n4. BaseEntity 추상 클래스 생성 (createdAt, updatedAt 공통 필드)\n5. ENUM 클래스 정의: EmployeeType, Role",
            "status": "done",
            "testStrategy": "1. 엔티티 매핑 테스트 (JPA 스키마 자동 생성 확인)\n2. ENUM 타입 매핑 테스트\n3. UUID 생성 및 저장 테스트\n4. 연관관계 매핑 테스트 (Employee-Store)\n5. BaseEntity 상속 테스트 (createdAt, updatedAt 자동 설정)",
            "parentId": "undefined",
            "updatedAt": "2026-01-16T07:05:02.272Z"
          },
          {
            "id": 2,
            "title": "근무 관련 도메인 엔티티 설계 및 구현 (WorkSchedule, AttendanceRecord)",
            "description": "근무 일정과 출퇴근 기록을 관리하는 WorkSchedule과 AttendanceRecord 엔티티를 설계하고 구현합니다. 출퇴근 수정 이력 추적 기능을 포함합니다.",
            "dependencies": [
              1
            ],
            "details": "1. WorkSchedule 엔티티 구현: scheduleId(UUID), employeeId(FK), workDate, startTime, endTime, createdAt, updatedAt\n2. AttendanceRecord 엔티티 구현: recordId(UUID), employeeId(FK), checkInTime, checkOutTime, adjusted, adjustedBy(FK), adjustmentReason, createdAt, updatedAt\n3. Employee와의 연관관계 설정 (@ManyToOne)\n4. 날짜/시간 타입 매핑 (LocalDate, LocalTime, LocalDateTime)\n5. 인덱스 설정: employeeId, workDate",
            "status": "done",
            "testStrategy": "1. WorkSchedule 엔티티 CRUD 테스트\n2. AttendanceRecord 엔티티 CRUD 테스트\n3. 날짜/시간 타입 저장 및 조회 테스트\n4. Employee와의 FK 제약조건 테스트\n5. 인덱스 생성 확인 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-16T07:36:06.452Z"
          },
          {
            "id": 3,
            "title": "휴가 및 급여 도메인 엔티티 설계 및 구현 (LeaveRequest, Payroll, PayrollPolicy)",
            "description": "휴가 신청, 급여 정보, 급여 정책을 관리하는 엔티티들을 설계하고 구현합니다. 승인 프로세스와 급여 계산을 위한 필드를 포함합니다.",
            "dependencies": [
              1
            ],
            "details": "1. LeaveRequest 엔티티 구현: leaveId(UUID), employeeId(FK), leaveType(ENUM), startDate, endDate, status(ENUM), approvedBy(FK), createdAt, updatedAt\n2. Payroll 엔티티 구현: payrollId(UUID), employeeId(FK), period(String), baseAmount, overtimeAmount, totalAmount(Decimal), calculatedAt, createdAt\n3. PayrollPolicy 엔티티 구현: policyId(UUID), policyType(ENUM), multiplier(Decimal), effectiveFrom, effectiveTo\n4. ENUM 클래스 정의: LeaveType, LeaveStatus, PolicyType\n5. Decimal 타입 매핑 (BigDecimal)",
            "status": "done",
            "testStrategy": "1. LeaveRequest 엔티티 매핑 테스트\n2. Payroll 엔티티 매핑 테스트\n3. PayrollPolicy 엔티티 매핑 테스트\n4. BigDecimal 타입 정밀도 테스트\n5. ENUM 타입 저장 및 조회 테스트\n6. 날짜 범위 검증 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-16T07:40:33.350Z"
          },
          {
            "id": 4,
            "title": "감사 로그 엔티티 및 JPA Repository 인터페이스 구현",
            "description": "모든 중요 변경 사항을 추적하는 AuditLog 엔티티를 구현하고, 모든 도메인 엔티티에 대한 JPA Repository 인터페이스를 생성합니다.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "1. AuditLog 엔티티 구현: logId(UUID), entityType, entityId, action, changedBy, oldValue(JSON), newValue(JSON), createdAt\n2. JSON 타입 매핑 (@Convert 사용)\n3. JPA Repository 인터페이스 생성: EmployeeRepository, StoreRepository, WorkScheduleRepository, AttendanceRecordRepository, LeaveRequestRepository, PayrollRepository, PayrollPolicyRepository, AuditLogRepository\n4. 커스텀 쿼리 메서드 정의 (findByEmployeeId, findByStoreId, findByWorkDate 등)\n5. @Query 어노테이션을 사용한 복잡한 조회 메서드 정의",
            "status": "done",
            "testStrategy": "1. AuditLog 엔티티 저장 및 조회 테스트\n2. JSON 필드 직렬화/역직렬화 테스트\n3. 각 Repository의 기본 CRUD 테스트\n4. 커스텀 쿼리 메서드 테스트\n5. 복잡한 조회 쿼리 성능 테스트\n6. 트랜잭션 롤백 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-16T08:24:31.731Z"
          },
          {
            "id": 5,
            "title": "데이터베이스 스키마 최적화 및 제약조건 설정",
            "description": "인덱스 설정, 제약조건 추가, 스키마 검증을 통해 데이터베이스 성능과 데이터 무결성을 확보합니다.",
            "dependencies": [
              4
            ],
            "details": "1. 복합 인덱스 설정: (employeeId, workDate), (storeId, createdAt), (employeeId, period)\n2. UNIQUE 제약조건 설정: Employee.email\n3. NOT NULL 제약조건 검증\n4. FK 제약조건 ON DELETE/UPDATE 정책 설정\n5. application.yml에 JPA 설정: ddl-auto, show-sql, format-sql\n6. Flyway 또는 Liquibase를 사용한 마이그레이션 스크립트 작성\n7. 스키마 검증 및 초기 데이터 시드 스크립트 작성",
            "status": "done",
            "testStrategy": "1. 인덱스 생성 확인 (EXPLAIN 쿼리 사용)\n2. UNIQUE 제약조건 위반 테스트\n3. NOT NULL 제약조건 위반 테스트\n4. FK 제약조건 위반 테스트\n5. 마이그레이션 스크립트 실행 테스트\n6. 초기 데이터 시드 테스트\n7. 스키마 일관성 검증 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-16T08:27:16.099Z"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Employee, Store, WorkSchedule, AttendanceRecord, LeaveRequest, Payroll, PayrollPolicy, AuditLog 등 8개 엔티티의 설계 및 구현을 논리적 그룹으로 묶어 5개의 세부 작업으로 분해하세요. 각 작업은 엔티티 설계, JPA 매핑, Repository 구현, 인덱스 최적화, 제약조건 설정을 포함해야 합니다.",
        "updatedAt": "2026-01-16T08:27:16.099Z"
      },
      {
        "id": "3",
        "title": "사용자 인증 및 권한 관리 시스템 구현",
        "description": "JWT 기반 로그인, 회원가입, RBAC(Role Based Access Control) 구현 - SUPER_ADMIN, MANAGER, EMPLOYEE 역할 구분",
        "details": "1. AuthController 구현:\n   - POST /api/auth/login (이메일, 비밀번호)\n   - POST /api/auth/register (슈퍼 관리자가 매니저/근로자 등록)\n   - POST /api/auth/refresh (토큰 갱신)\n   - POST /api/auth/logout\n\n2. AuthService 구현:\n   - 로그인 시 비밀번호 검증 (BCrypt)\n   - JWT 토큰 생성 (Access Token, Refresh Token)\n   - 토큰에 사용자 ID, 역할, 매장 ID 포함\n\n3. UserDetailsService 구현:\n   - Employee 엔티티 기반 사용자 정보 로드\n\n4. RBAC 구현:\n   - @PreAuthorize 어노테이션 활용\n   - SUPER_ADMIN: 모든 권한\n   - MANAGER: 소속 매장 관리 권한\n   - EMPLOYEE: 본인 정보만 조회/수정\n\n5. SecurityContext에서 현재 사용자 정보 추출 유틸리티\n\n6. 비밀번호 암호화 (BCryptPasswordEncoder)\n\n7. 로그인 실패 처리 및 에러 응답",
        "testStrategy": "1. 로그인 API 테스트 (성공/실패 케이스)\n2. JWT 토큰 생성 및 파싱 테스트\n3. 역할별 권한 테스트 (SUPER_ADMIN, MANAGER, EMPLOYEE)\n4. 토큰 만료 테스트\n5. 비밀번호 암호화 테스트\n6. 인증 필터 통합 테스트",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "JWT 토큰 생성 및 검증 유틸리티 구현",
            "description": "JWT Access Token과 Refresh Token을 생성하고 검증하는 유틸리티 클래스 구현. 토큰에 사용자 ID, 역할, 매장 ID를 포함하고 만료 시간을 설정합니다.",
            "dependencies": [],
            "details": "JwtTokenProvider 클래스 생성하여 generateAccessToken(), generateRefreshToken(), validateToken(), extractClaims() 메서드 구현. application.yml에서 JWT 시크릿 키와 만료 시간 설정 로드. 토큰에 employeeId, role, storeId를 클레임으로 포함. Access Token 만료 시간 1시간, Refresh Token 만료 시간 7일로 설정.",
            "status": "done",
            "testStrategy": "JWT 토큰 생성 테스트, 토큰 파싱 및 클레임 추출 테스트, 만료된 토큰 검증 테스트, 잘못된 서명 토큰 검증 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-16T08:28:54.628Z"
          },
          {
            "id": 2,
            "title": "Spring Security 설정 및 JWT 인증 필터 구현",
            "description": "Spring Security 설정 클래스와 JWT 기반 인증 필터를 구현하여 요청마다 토큰을 검증하고 SecurityContext에 인증 정보를 설정합니다.",
            "dependencies": [
              1
            ],
            "details": "SecurityConfig 클래스에서 SecurityFilterChain 빈 설정. JwtAuthenticationFilter 구현하여 요청 헤더에서 Bearer 토큰 추출 및 검증. 토큰이 유효하면 UsernamePasswordAuthenticationToken 생성하여 SecurityContext에 설정. /api/auth/** 경로는 인증 없이 접근 허용, 나머지는 인증 필요. BCryptPasswordEncoder 빈 등록. CORS 설정 추가.",
            "status": "done",
            "testStrategy": "인증 필터 동작 테스트, 유효한 토큰으로 보호된 엔드포인트 접근 테스트, 토큰 없이 접근 시 401 응답 테스트, 만료된 토큰으로 접근 시 401 응답 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-16T08:31:06.678Z"
          },
          {
            "id": 3,
            "title": "UserDetailsService 및 인증 서비스 구현",
            "description": "Employee 엔티티 기반으로 사용자 정보를 로드하는 UserDetailsService와 로그인, 회원가입, 토큰 갱신 로직을 처리하는 AuthService를 구현합니다.",
            "dependencies": [
              1,
              2
            ],
            "details": "CustomUserDetailsService 클래스에서 loadUserByUsername() 구현하여 이메일로 Employee 조회 후 UserDetails 반환. AuthService에서 login() 메서드 구현: 이메일로 사용자 조회, BCrypt로 비밀번호 검증, JWT 토큰 생성 및 반환. register() 메서드: 비밀번호 암호화 후 Employee 생성. refreshToken() 메서드: Refresh Token 검증 후 새로운 Access Token 발급. logout() 메서드: Refresh Token 무효화 처리.",
            "status": "done",
            "testStrategy": "로그인 성공 케이스 테스트, 잘못된 비밀번호로 로그인 실패 테스트, 존재하지 않는 이메일로 로그인 실패 테스트, 회원가입 API 테스트, 토큰 갱신 API 테스트, 비밀번호 암호화 검증 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-16T08:33:16.088Z"
          },
          {
            "id": 4,
            "title": "AuthController 및 인증 API 엔드포인트 구현",
            "description": "로그인, 회원가입, 토큰 갱신, 로그아웃 API 엔드포인트를 제공하는 AuthController를 구현하고 요청/응답 DTO를 정의합니다.",
            "dependencies": [
              3
            ],
            "details": "AuthController 클래스 생성. POST /api/auth/login: LoginRequest(email, password) 받아 LoginResponse(accessToken, refreshToken, userInfo) 반환. POST /api/auth/register: RegisterRequest(name, email, password, role, storeId) 받아 SUPER_ADMIN만 접근 가능하도록 @PreAuthorize 설정. POST /api/auth/refresh: RefreshTokenRequest 받아 새로운 AccessToken 반환. POST /api/auth/logout: 현재 사용자의 Refresh Token 무효화. 각 API에 대한 에러 응답 처리 (401, 403, 400).",
            "status": "done",
            "testStrategy": "로그인 API 통합 테스트, 회원가입 API 권한 테스트, 토큰 갱신 API 테스트, 로그아웃 API 테스트, 잘못된 요청 데이터에 대한 400 응답 테스트, 인증 실패 시 401 응답 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-16T08:39:10.264Z"
          },
          {
            "id": 5,
            "title": "RBAC 권한 관리 및 SecurityContext 유틸리티 구현",
            "description": "역할 기반 접근 제어(RBAC)를 구현하고 SecurityContext에서 현재 사용자 정보를 추출하는 유틸리티를 제공합니다. SUPER_ADMIN, MANAGER, EMPLOYEE 역할별 권한을 설정합니다.",
            "dependencies": [
              2,
              3
            ],
            "details": "SecurityConfig에서 @EnableMethodSecurity 활성화. SecurityUtils 유틸리티 클래스 생성: getCurrentUserId(), getCurrentUserRole(), getCurrentStoreId(), isCurrentUser() 메서드 구현. @PreAuthorize 어노테이션 활용 예시 작성: hasRole('SUPER_ADMIN'), hasAnyRole('SUPER_ADMIN', 'MANAGER'), @PreAuthorize(\"hasRole('EMPLOYEE') and #employeeId == principal.employeeId\"). 각 역할별 권한 문서화: SUPER_ADMIN은 모든 권한, MANAGER는 소속 매장 관리, EMPLOYEE는 본인 정보만 접근.",
            "status": "done",
            "testStrategy": "SUPER_ADMIN 권한으로 모든 API 접근 테스트, MANAGER 권한으로 소속 매장 데이터 접근 테스트, MANAGER가 다른 매장 데이터 접근 시 403 응답 테스트, EMPLOYEE가 본인 정보 접근 테스트, EMPLOYEE가 타인 정보 접근 시 403 응답 테스트, SecurityUtils 메서드 단위 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-16T08:40:41.430Z"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "JWT 토큰 생성/검증, Spring Security 설정, UserDetailsService 구현, AuthController 및 API 엔드포인트, RBAC 권한 관리 및 SecurityContext 유틸리티를 포함하는 5개의 세부 작업으로 분해하세요. 각 작업은 보안 테스트와 권한별 접근 제어 검증을 포함해야 합니다.",
        "updatedAt": "2026-01-16T08:40:41.430Z"
      },
      {
        "id": "4",
        "title": "매장 및 근로자 관리 API 구현",
        "description": "슈퍼 관리자의 매장 관리, 매니저의 근로자 관리 기능 구현 (등록, 수정, 조회, 비활성화)",
        "details": "1. StoreController:\n   - POST /api/stores (매장 등록, SUPER_ADMIN)\n   - GET /api/stores (전체 매장 조회, SUPER_ADMIN)\n   - GET /api/stores/{storeId} (매장 상세 조회)\n   - PUT /api/stores/{storeId} (매장 수정, SUPER_ADMIN)\n   - DELETE /api/stores/{storeId} (매장 삭제, SUPER_ADMIN)\n\n2. EmployeeController:\n   - POST /api/employees (근로자 등록, SUPER_ADMIN/MANAGER)\n   - GET /api/employees (근로자 목록 조회, 매장별 필터링)\n   - GET /api/employees/{employeeId} (근로자 상세 조회)\n   - PUT /api/employees/{employeeId} (근로자 정보 수정)\n   - PATCH /api/employees/{employeeId}/deactivate (비활성화)\n\n3. StoreService:\n   - 매장 CRUD 로직\n   - 매장에 매니저 할당\n\n4. EmployeeService:\n   - 근로자 CRUD 로직\n   - 매니저는 자신의 매장 근로자만 관리 가능하도록 검증\n   - 근로자 유형별 초기 연차 설정\n\n5. DTO 구현:\n   - StoreCreateRequest, StoreResponse\n   - EmployeeCreateRequest, EmployeeResponse\n   - EmployeeUpdateRequest\n\n6. 권한 검증:\n   - 매니저는 자신의 매장만 접근 가능\n   - 근로자는 본인 정보만 조회 가능",
        "testStrategy": "1. 매장 CRUD API 통합 테스트\n2. 근로자 CRUD API 통합 테스트\n3. 권한별 접근 제어 테스트 (SUPER_ADMIN, MANAGER, EMPLOYEE)\n4. 매장별 근로자 필터링 테스트\n5. 비활성화 기능 테스트\n6. 유효성 검증 테스트 (필수 필드, 형식)",
        "priority": "high",
        "dependencies": [
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "매장 관리 DTO 및 엔티티 구현",
            "description": "매장 관리를 위한 DTO(StoreCreateRequest, StoreResponse, StoreUpdateRequest)와 Store 엔티티 구현",
            "dependencies": [],
            "details": "Store 엔티티 필드 정의 (id, name, address, phoneNumber, managerId, isActive, createdAt, updatedAt), StoreCreateRequest DTO (name, address, phoneNumber, managerId), StoreResponse DTO (모든 필드 포함), StoreUpdateRequest DTO (수정 가능 필드), 유효성 검증 어노테이션 추가 (@NotBlank, @Pattern 등)",
            "status": "done",
            "testStrategy": "DTO 유효성 검증 단위 테스트, 엔티티 매핑 테스트, 필수 필드 검증 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-16T08:41:40.635Z"
          },
          {
            "id": 2,
            "title": "매장 관리 서비스 및 리포지토리 구현",
            "description": "StoreRepository와 StoreService를 구현하여 매장 CRUD 로직 및 매니저 할당 기능 구현",
            "dependencies": [
              1
            ],
            "details": "StoreRepository 인터페이스 생성 (JpaRepository 상속), StoreService 구현 (createStore, getAllStores, getStoreById, updateStore, deleteStore, assignManager), 매장 존재 여부 검증 로직, 매니저 할당 시 User 엔티티와 연동, 트랜잭션 처리 (@Transactional)",
            "status": "done",
            "testStrategy": "StoreService 단위 테스트 (Mockito 사용), 매장 CRUD 로직 테스트, 매니저 할당 테스트, 예외 처리 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-16T08:55:26.183Z"
          },
          {
            "id": 3,
            "title": "매장 관리 API 컨트롤러 구현",
            "description": "StoreController를 구현하여 매장 등록, 조회, 수정, 삭제 REST API 엔드포인트 구현 및 권한 검증",
            "dependencies": [
              2
            ],
            "details": "POST /api/stores (매장 등록, @PreAuthorize SUPER_ADMIN), GET /api/stores (전체 매장 조회, SUPER_ADMIN), GET /api/stores/{storeId} (매장 상세 조회), PUT /api/stores/{storeId} (매장 수정, SUPER_ADMIN), DELETE /api/stores/{storeId} (매장 삭제, SUPER_ADMIN), @Valid를 통한 요청 검증, ResponseEntity를 통한 적절한 HTTP 상태 코드 반환",
            "status": "done",
            "testStrategy": "매장 CRUD API 통합 테스트 (MockMvc 사용), SUPER_ADMIN 권한 검증 테스트, 유효하지 않은 요청 처리 테스트, 존재하지 않는 매장 조회 시 404 반환 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-16T09:00:36.100Z"
          },
          {
            "id": 4,
            "title": "근로자 관리 DTO, 엔티티 및 서비스 구현",
            "description": "근로자 관리를 위한 DTO, Employee 엔티티, EmployeeService 구현 및 권한별 접근 제어 로직 구현",
            "dependencies": [
              2
            ],
            "details": "Employee 엔티티 필드 정의 (id, userId, storeId, employeeType, hourlyWage, dailyWage, annualLeave, isActive), EmployeeCreateRequest, EmployeeResponse, EmployeeUpdateRequest DTO 구현, EmployeeRepository 생성, EmployeeService 구현 (createEmployee, getEmployees, getEmployeeById, updateEmployee, deactivateEmployee), 매니저는 자신의 매장 근로자만 관리 가능하도록 검증 로직 추가, 근로자 유형별 초기 연차 설정 로직 (정규직 15일, 계약직 11일 등)",
            "status": "done",
            "testStrategy": "EmployeeService 단위 테스트, 권한별 접근 제어 테스트 (매니저는 자신의 매장만), 근로자 유형별 초기 연차 설정 테스트, 비활성화 기능 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-16T09:02:31.428Z"
          },
          {
            "id": 5,
            "title": "근로자 관리 API 컨트롤러 구현",
            "description": "EmployeeController를 구현하여 근로자 등록, 조회, 수정, 비활성화 REST API 엔드포인트 구현 및 권한별 접근 제어",
            "dependencies": [
              4
            ],
            "details": "POST /api/employees (근로자 등록, SUPER_ADMIN/MANAGER), GET /api/employees (근로자 목록 조회, 매장별 필터링 쿼리 파라미터), GET /api/employees/{employeeId} (근로자 상세 조회), PUT /api/employees/{employeeId} (근로자 정보 수정), PATCH /api/employees/{employeeId}/deactivate (비활성화), SecurityContext에서 현재 사용자 정보 추출하여 권한 검증 (매니저는 자신의 매장만, 근로자는 본인 정보만), @Valid를 통한 요청 검증",
            "status": "done",
            "testStrategy": "근로자 CRUD API 통합 테스트, 권한별 접근 제어 테스트 (SUPER_ADMIN, MANAGER, EMPLOYEE), 매장별 필터링 테스트, 비활성화 기능 테스트, 유효성 검증 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-16T09:03:22.760Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "매장 관리 DTO/엔티티, 매장 서비스 및 Repository, 매장 API 컨트롤러, 근로자 관리 DTO/엔티티/서비스, 근로자 API 컨트롤러를 포함하는 5개의 세부 작업으로 분해하세요. 각 작업은 권한별 접근 제어(SUPER_ADMIN, MANAGER, EMPLOYEE)와 매장별 데이터 격리 검증을 포함해야 합니다.",
        "updatedAt": "2026-01-16T09:03:22.760Z"
      },
      {
        "id": "5",
        "title": "출퇴근 관리 시스템 구현",
        "description": "근로자의 출근/퇴근 기록, 관리자의 출퇴근 기록 수정 및 이력 추적 기능 구현",
        "details": "1. AttendanceController:\n   - POST /api/attendance/check-in (출근, EMPLOYEE)\n   - POST /api/attendance/check-out (퇴근, EMPLOYEE)\n   - GET /api/attendance/my-records (본인 출퇴근 기록 조회)\n   - GET /api/attendance/records (매장별 출퇴근 기록 조회, MANAGER)\n   - PUT /api/attendance/records/{recordId} (출퇴근 기록 수정, MANAGER)\n\n2. AttendanceService:\n   - checkIn(): 출근 시간 기록, 중복 체크\n   - checkOut(): 퇴근 시간 기록, 근무 시간 계산\n   - adjustRecord(): 출퇴근 기록 수정 (관리자)\n   - 수정 시 AuditLog에 변경 이력 저장\n\n3. 출퇴근 검증 로직:\n   - 이미 출근한 상태에서 재출근 방지\n   - 출근하지 않은 상태에서 퇴근 방지\n   - 매장 단위 출퇴근 제한 (옵션, storeId 검증)\n\n4. 근무 시간 계산:\n   - checkOutTime - checkInTime\n   - 시간 단위로 저장 (Decimal)\n\n5. AuditLogService:\n   - 출퇴근 기록 수정 시 로그 생성\n   - 변경 전/후 값, 수정자, 수정 사유 저장\n\n6. DTO:\n   - CheckInRequest, CheckOutRequest\n   - AttendanceRecordResponse\n   - AttendanceAdjustRequest (adjustedCheckInTime, adjustedCheckOutTime, reason)",
        "testStrategy": "1. 출근 API 테스트 (정상, 중복 출근 방지)\n2. 퇴근 API 테스트 (정상, 출근 없이 퇴근 방지)\n3. 근무 시간 계산 로직 단위 테스트\n4. 출퇴근 기록 수정 API 테스트\n5. 수정 이력 로그 생성 확인\n6. 권한별 접근 제어 테스트\n7. 매장별 출퇴근 기록 조회 테스트",
        "priority": "high",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "출퇴근 DTO 및 엔티티 검증 로직 구현",
            "description": "출퇴근 기능에 필요한 Request/Response DTO 클래스 작성 및 출퇴근 검증 로직 구현",
            "dependencies": [],
            "details": "CheckInRequest, CheckOutRequest, AttendanceRecordResponse, AttendanceAdjustRequest DTO 클래스 작성. 중복 출근 방지, 출근 없이 퇴근 방지, 매장 단위 출퇴근 제한 등의 검증 로직을 구현. Kotlin data class로 작성하고 validation 어노테이션 추가.",
            "status": "done",
            "testStrategy": "DTO 직렬화/역직렬화 테스트, 검증 로직 단위 테스트 (중복 출근, 출근 없이 퇴근 시도 등)",
            "parentId": "undefined",
            "updatedAt": "2026-01-16T09:10:14.364Z"
          },
          {
            "id": 2,
            "title": "AttendanceService 핵심 비즈니스 로직 구현",
            "description": "출근, 퇴근, 근무 시간 계산 등 출퇴근 관리의 핵심 비즈니스 로직을 서비스 레이어에 구현",
            "dependencies": [
              1
            ],
            "details": "checkIn() 메서드: 출근 시간 기록 및 중복 체크. checkOut() 메서드: 퇴근 시간 기록 및 근무 시간 계산 (checkOutTime - checkInTime을 Decimal로 저장). AttendanceRecord 엔티티 조회 및 저장. 트랜잭션 처리 및 예외 핸들링 포함.",
            "status": "done",
            "testStrategy": "출근 메서드 단위 테스트 (정상 케이스, 중복 출근), 퇴근 메서드 단위 테스트 (정상 케이스, 출근 없이 퇴근), 근무 시간 계산 로직 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-16T09:11:04.537Z"
          },
          {
            "id": 3,
            "title": "AttendanceController 및 출퇴근 API 엔드포인트 구현",
            "description": "근로자의 출근/퇴근 및 본인 기록 조회 API 엔드포인트 구현",
            "dependencies": [
              2
            ],
            "details": "POST /api/attendance/check-in (출근, EMPLOYEE 권한), POST /api/attendance/check-out (퇴근, EMPLOYEE 권한), GET /api/attendance/my-records (본인 출퇴근 기록 조회) 엔드포인트 구현. JWT 토큰에서 사용자 정보 추출하여 서비스 호출. 적절한 HTTP 상태 코드 및 응답 반환.",
            "status": "done",
            "testStrategy": "출근 API 통합 테스트, 퇴근 API 통합 테스트, 본인 기록 조회 API 테스트, 권한 검증 테스트 (EMPLOYEE 권한)",
            "parentId": "undefined",
            "updatedAt": "2026-01-16T09:11:58.536Z"
          },
          {
            "id": 4,
            "title": "관리자용 출퇴근 기록 조회 및 수정 기능 구현",
            "description": "관리자가 매장별 출퇴근 기록을 조회하고 수정할 수 있는 기능 구현",
            "dependencies": [
              2
            ],
            "details": "GET /api/attendance/records (매장별 출퇴근 기록 조회, MANAGER 권한), PUT /api/attendance/records/{recordId} (출퇴근 기록 수정, MANAGER 권한) 엔드포인트 구현. adjustRecord() 서비스 메서드 작성: 출퇴근 시간 수정 및 근무 시간 재계산. 매장 권한 검증 로직 포함.",
            "status": "done",
            "testStrategy": "매장별 출퇴근 기록 조회 API 테스트, 출퇴근 기록 수정 API 테스트, 권한별 접근 제어 테스트 (MANAGER 권한), 매장 권한 검증 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-16T09:13:36.919Z"
          },
          {
            "id": 5,
            "title": "출퇴근 기록 수정 이력 추적 기능 구현",
            "description": "관리자가 출퇴근 기록을 수정할 때 AuditLog에 변경 이력을 자동으로 저장하는 기능 구현",
            "dependencies": [
              4
            ],
            "details": "AuditLogService 작성: 출퇴근 기록 수정 시 변경 전/후 값, 수정자 정보, 수정 사유를 AuditLog 엔티티에 저장. adjustRecord() 메서드 내에서 AuditLogService 호출하여 이력 생성. 트랜잭션 내에서 원자적으로 처리되도록 구현.\n<info added on 2026-01-17T00:03:33.009Z>\nJPA AuditingEntityListener를 사용하여 @PreUpdate 시점에 변경 전후 값을 자동 비교하여 AuditLog 엔티티 생성. AttendanceRecordEntity에 @EntityListeners(AuditingEntityListener::class) 설정. 변경 감지를 위해 @Transient 필드에 이전 상태 스냅샷 저장 후 @PostLoad에서 초기화, @PreUpdate에서 비교. 수정 사유(reason)와 수정자(modifier)는 ThreadLocal 또는 SecurityContextHolder에서 주입. AdjustAttendanceAppService는 도메인 모델 변경만 수행하고, JPA lifecycle callback이 자동으로 audit 로그 생성하도록 리팩토링.\n</info added on 2026-01-17T00:03:33.009Z>",
            "status": "done",
            "testStrategy": "출퇴근 기록 수정 시 AuditLog 생성 확인 테스트, 변경 전/후 값 저장 검증, 수정자 및 수정 사유 저장 확인, 트랜잭션 롤백 시 이력도 함께 롤백되는지 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-16T23:40:40.554Z"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "출퇴근 DTO 및 검증 로직, AttendanceService 핵심 비즈니스 로직(출근/퇴근/근무시간 계산), 출퇴근 API 엔드포인트, 관리자용 출퇴근 기록 조회/수정, 출퇴근 기록 수정 이력 추적(AuditLog)을 포함하는 5개의 세부 작업으로 분해하세요.",
        "updatedAt": "2026-01-16T23:40:40.554Z"
      },
      {
        "id": "6",
        "title": "근무 일정 관리 시스템 구현",
        "description": "관리자의 근무 일정 생성/수정/삭제, 근로자의 일정 조회 기능 구현",
        "details": "1. WorkScheduleController:\n   - POST /api/schedules (근무 일정 생성, SUPER_ADMIN/MANAGER)\n   - GET /api/schedules (일정 조회, 날짜/근로자/매장 필터링)\n   - GET /api/schedules/my-schedule (본인 일정 조회, EMPLOYEE)\n   - PUT /api/schedules/{scheduleId} (일정 수정)\n   - DELETE /api/schedules/{scheduleId} (일정 삭제)\n\n2. WorkScheduleService:\n   - createSchedule(): 근무 일정 생성\n   - 근로자 유형별 스케줄 차등 관리\n   - 일정 중복 검증 (동일 근로자, 동일 날짜)\n   - updateSchedule(): 일정 수정\n   - deleteSchedule(): 일정 삭제\n   - getSchedulesByEmployee(): 근로자별 일정 조회\n   - getSchedulesByStore(): 매장별 일정 조회\n   - getSchedulesByDateRange(): 기간별 일정 조회\n\n3. 일정 검증 로직:\n   - startTime < endTime 검증\n   - 근로자가 해당 매장 소속인지 확인\n   - 매니저는 자신의 매장 일정만 관리 가능\n\n4. DTO:\n   - ScheduleCreateRequest (employeeId, workDate, startTime, endTime)\n   - ScheduleResponse\n   - ScheduleUpdateRequest\n\n5. 일정 조회 필터링:\n   - Query Parameter: employeeId, storeId, startDate, endDate",
        "testStrategy": "1. 근무 일정 생성 API 테스트\n2. 일정 중복 검증 테스트\n3. 시간 유효성 검증 테스트 (startTime < endTime)\n4. 일정 조회 API 테스트 (필터링 포함)\n5. 일정 수정/삭제 API 테스트\n6. 권한별 접근 제어 테스트\n7. 근로자 본인 일정 조회 테스트",
        "priority": "medium",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "근무 일정 DTO 및 엔티티 검증 로직 구현",
            "description": "근무 일정 생성/수정/조회를 위한 DTO 클래스들과 엔티티 레벨의 비즈니스 검증 로직을 구현합니다.",
            "dependencies": [],
            "details": "ScheduleCreateRequest, ScheduleUpdateRequest, ScheduleResponse DTO를 생성하고, WorkSchedule 엔티티에 startTime < endTime 검증, 근로자 매장 소속 확인, 일정 중복 검증 메서드를 구현합니다. 날짜/시간 유효성 검증 로직을 포함합니다.\n<info added on 2026-01-17T00:12:41.931Z>\n구현 완료 사항:\n\n1. 도메인 예외 정의 완료 (WorkScheduleException.kt)\n   - ScheduleNotFoundException (SCH001)\n   - DuplicateScheduleException (SCH002)\n   - ConfirmedScheduleCannotModifyException (SCH003)\n   - EmployeeNotBelongToStoreException (SCH004)\n   - ManagerCanOnlyManageOwnStoreException (SCH005)\n\n2. ErrorCode 열거형 업데이트 완료 (5개 스케줄 관련 에러 코드 추가)\n\n3. Application 계층 DTO 생성 완료 (application/schedule/dto/WorkScheduleDto.kt)\n   - CreateWorkScheduleCommand: DomainContext, employeeId, storeId, workDate, startTime, endTime\n   - UpdateWorkScheduleCommand: DomainContext, scheduleId, workDate, startTime, endTime\n   - WorkScheduleResult: scheduleId, employeeId, storeId, workDate, startTime, endTime, isConfirmed\n\n4. Interfaces 계층 Request DTO 생성 완료 (interfaces/web/dto/WorkScheduleRequest.kt)\n   - CreateRequest: Jakarta Bean Validation 적용 (@NotBlank, @NotNull, @FutureOrPresent, @Pattern)\n   - UpdateRequest: Jakarta Bean Validation 적용\n\n5. Interfaces 계층 Response DTO 생성 완료 (interfaces/web/dto/WorkScheduleResponse.kt)\n   - WorkScheduleResponse: 단건 조회용\n   - WorkScheduleListResponse: 목록 조회용 (리스트 래핑)\n\n6. 도메인 모델 검증 로직 확인\n   - WorkTime VO의 init 블록에서 startTime < endTime 검증 이미 구현됨\n   - 추가 비즈니스 검증 로직은 도메인 서비스 또는 Aggregate Root 메서드에서 처리 예정\n\n빌드 성공 확인 완료. 다음 서브태스크(6.2 - Repository 및 조회 쿼리 메서드 구현) 진행 가능.\n</info added on 2026-01-17T00:12:41.931Z>",
            "status": "done",
            "testStrategy": "DTO 직렬화/역직렬화 테스트, 시간 유효성 검증 단위 테스트, 일정 중복 검증 로직 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-17T00:12:28.324Z"
          },
          {
            "id": 2,
            "title": "WorkScheduleRepository 및 조회 쿼리 메서드 구현",
            "description": "근무 일정 데이터 접근을 위한 Repository 인터페이스와 다양한 필터링 조건의 조회 쿼리 메서드를 구현합니다.",
            "dependencies": [
              1
            ],
            "details": "WorkScheduleRepository를 생성하고 findByEmployeeId, findByStoreId, findByDateRange, findByEmployeeIdAndWorkDate 등의 쿼리 메서드를 구현합니다. QueryDSL 또는 JPQL을 사용하여 복합 필터링 쿼리를 작성합니다.\n<info added on 2026-01-17T00:13:51.784Z>\n구현 완료 사항:\n1. WorkScheduleEntity가 적절한 JPA 설정(인덱스, 유니크 제약조건, JPA Auditing)과 함께 존재함을 확인\n2. WorkScheduleMapper가 toDomain, toEntity, updateEntity 메서드와 함께 존재함을 확인\n3. WorkScheduleJpaRepository에 필요한 모든 쿼리 메서드(findByEmployeeId, findByStoreId, findByEmployeeIdAndWorkDate, findByEmployeeIdAndWorkDateBetween, findByStoreIdAndWorkDateBetween, findConfirmedSchedulesByDateRange) 존재함을 확인\n4. 중복 일정 검증을 위해 도메인 레포지토리 인터페이스에 findByEmployeeIdAndWorkDate() 메서드 추가\n5. WorkScheduleRepositoryImpl에 findByEmployeeIdAndWorkDate() 구현 완료\n6. 빌드 성공\n\n모든 레포지토리 쿼리 메서드가 정상적으로 구현되었으며 컴파일을 통해 검증 완료됨.\n</info added on 2026-01-17T00:13:51.784Z>",
            "status": "done",
            "testStrategy": "Repository 기본 CRUD 테스트, 필터링 조회 쿼리 테스트, 날짜 범위 조회 테스트, 복합 조건 조회 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-17T00:13:41.288Z"
          },
          {
            "id": 3,
            "title": "WorkScheduleService 비즈니스 로직 구현",
            "description": "근무 일정 생성, 수정, 삭제 및 조회를 위한 서비스 레이어 비즈니스 로직을 구현합니다.",
            "dependencies": [
              2
            ],
            "details": "createSchedule, updateSchedule, deleteSchedule, getSchedulesByEmployee, getSchedulesByStore, getSchedulesByDateRange 메서드를 구현합니다. 근로자 유형별 스케줄 차등 관리, 일정 중복 검증, 근로자 매장 소속 확인, 매니저 권한 검증 로직을 포함합니다.\n<info added on 2026-01-17T00:15:19.283Z>\n구현 완료:\n1. CreateWorkScheduleAppService - 직원/매장 존재 확인, 직원의 매장 소속 검증, 중복 일정 방지 로직 구현\n2. GetWorkScheduleAppService - 단일 일정 조회 기능 구현\n3. GetWorkSchedulesByEmployeeAppService - 직원별 일정 목록 조회 구현\n4. GetWorkSchedulesByStoreAppService - 매장별 일정 목록 조회 구현\n5. GetWorkSchedulesByDateRangeAppService - 날짜 범위 기반 일정 필터링 구현\n6. UpdateWorkScheduleAppService - 도메인 검증을 포함한 일정 수정 기능 구현\n7. DeleteWorkScheduleAppService - 존재 확인 후 일정 삭제 기능 구현\n\n모든 서비스는 기존 패턴을 준수하며 빌드 성공 확인됨.\n</info added on 2026-01-17T00:15:19.283Z>",
            "status": "done",
            "testStrategy": "일정 생성 서비스 테스트, 중복 검증 테스트, 권한별 접근 제어 테스트, 일정 수정/삭제 테스트, 조회 필터링 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-17T00:15:10.095Z"
          },
          {
            "id": 4,
            "title": "WorkScheduleController REST API 엔드포인트 구현",
            "description": "근무 일정 관리를 위한 REST API 컨트롤러와 모든 엔드포인트를 구현합니다.",
            "dependencies": [
              3
            ],
            "details": "POST /api/schedules, GET /api/schedules, GET /api/schedules/my-schedule, PUT /api/schedules/{scheduleId}, DELETE /api/schedules/{scheduleId} 엔드포인트를 구현합니다. 권한별 접근 제어(@PreAuthorize), Query Parameter 필터링(employeeId, storeId, startDate, endDate), 요청/응답 검증을 포함합니다.\n<info added on 2026-01-17T00:17:04.181Z>\nSuccessfully completed WorkScheduleController implementation with all required REST endpoints:\n\n**구현 완료된 엔드포인트:**\n- POST /api/schedules - 근무 일정 생성 (MANAGER, SUPER_ADMIN 권한)\n- GET /api/schedules - 근무 일정 목록 조회 (필터링 지원: employeeId, storeId, startDate, endDate)\n- GET /api/schedules/my-schedule - 본인 근무 일정 조회 (인증된 사용자)\n- GET /api/schedules/{scheduleId} - 특정 근무 일정 단건 조회\n- PUT /api/schedules/{scheduleId} - 근무 일정 수정 (MANAGER, SUPER_ADMIN 권한)\n- DELETE /api/schedules/{scheduleId} - 근무 일정 삭제 (MANAGER, SUPER_ADMIN 권한)\n\n**적용된 기술 요소:**\n- Spring Security `@PreAuthorize` 어노테이션을 통한 역할 기반 접근 제어\n- Request DTO 유효성 검증 (`@Valid`, `@NotNull`, `@NotBlank` 등)\n- 적절한 HTTP 상태 코드 응답 (201 Created, 200 OK, 204 No Content)\n- Query Parameter를 통한 동적 필터링 기능\n- 빌드 성공 확인 완료\n</info added on 2026-01-17T00:17:04.181Z>",
            "status": "done",
            "testStrategy": "일정 생성 API 통합 테스트, 일정 조회 API 테스트(필터링 포함), 본인 일정 조회 테스트, 일정 수정/삭제 API 테스트, 권한별 접근 제어 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-17T00:16:53.986Z"
          },
          {
            "id": 5,
            "title": "근무 일정 관리 통합 테스트 및 예외 처리 구현",
            "description": "전체 근무 일정 관리 시스템의 통합 테스트와 예외 상황 처리를 구현합니다.",
            "dependencies": [
              4
            ],
            "details": "전체 API 플로우 통합 테스트, 동시성 제어 테스트, 예외 처리(일정 중복, 권한 없음, 존재하지 않는 리소스 등), 에러 응답 표준화, 로깅 구현을 포함합니다. 매니저가 타 매장 일정 관리 시도 시 예외 처리를 검증합니다.\n<info added on 2026-01-17T00:18:05.690Z>\n예외 처리 구현 완료:\n- GlobalExceptionHandler에 DomainException 핸들러 추가\n- WorkSchedule 도메인의 모든 예외(ScheduleNotFoundException, DuplicateWorkScheduleException, ConfirmedScheduleCannotBeModifiedException, EmployeeNotBelongToStoreException, ManagerCanOnlyManageOwnStoreException) 처리 구현\n- ApiResponse 형식의 일관된 에러 응답 구조 적용\n- 에러 코드와 함께 적절한 로깅 구현\n- 빌드 성공 및 모든 예외 시나리오 검증 완료\n</info added on 2026-01-17T00:18:05.690Z>",
            "status": "done",
            "testStrategy": "전체 CRUD 플로우 통합 테스트, 예외 상황 테스트, 동시성 테스트, 권한 위반 시나리오 테스트, 에러 응답 포맷 검증",
            "parentId": "undefined",
            "updatedAt": "2026-01-17T00:17:55.365Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "근무 일정 DTO 및 검증 로직, WorkScheduleRepository 및 조회 쿼리, WorkScheduleService 비즈니스 로직, WorkScheduleController REST API, 통합 테스트 및 예외 처리를 포함하는 5개의 세부 작업으로 분해하세요. 각 작업은 일정 중복 검증, 시간 유효성 검증, 권한별 접근 제어를 포함해야 합니다.",
        "updatedAt": "2026-01-17T00:17:55.365Z"
      },
      {
        "id": "7",
        "title": "휴가 및 연차 관리 시스템 구현",
        "description": "근로자의 휴가 신청/취소, 매니저의 승인/반려, 직급별 연차 정책 관리 기능 구현",
        "details": "1. LeaveRequestController:\n   - POST /api/leaves (휴가 신청, EMPLOYEE)\n   - GET /api/leaves/my-leaves (본인 휴가 내역 조회)\n   - GET /api/leaves (매장별 휴가 신청 목록, MANAGER)\n   - PATCH /api/leaves/{leaveId}/approve (승인, MANAGER)\n   - PATCH /api/leaves/{leaveId}/reject (반려, MANAGER)\n   - DELETE /api/leaves/{leaveId} (신청 취소, EMPLOYEE)\n\n2. LeaveRequestService:\n   - requestLeave(): 휴가 신청\n     - 잔여 연차 확인\n     - 반차는 0.5일 차감\n   - cancelLeave(): 신청 취소 (REQUESTED 상태만 가능)\n   - approveLeave(): 승인\n     - 근로자의 remainingLeave 차감\n     - 상태를 APPROVED로 변경\n   - rejectLeave(): 반려\n     - 상태를 REJECTED로 변경\n\n3. LeavePolicyService:\n   - 직급별 연차 정책 관리\n   - 정규직: 15일, 비정규직: 10일, 파트타임: 5일 (예시)\n   - 근로자 등록 시 초기 연차 설정\n\n4. 휴가 검증 로직:\n   - 잔여 연차 부족 시 신청 불가\n   - 이미 승인된 휴가와 날짜 중복 방지\n   - 매니저는 자신의 매장 근로자 휴가만 승인/반려 가능\n\n5. DTO:\n   - LeaveRequestCreateRequest (leaveType, startDate, endDate)\n   - LeaveRequestResponse\n   - LeaveApprovalRequest (approvalComment)",
        "testStrategy": "1. 휴가 신청 API 테스트\n2. 잔여 연차 검증 테스트\n3. 휴가 승인/반려 API 테스트\n4. 승인 시 연차 차감 확인\n5. 휴가 취소 API 테스트\n6. 날짜 중복 검증 테스트\n7. 권한별 접근 제어 테스트\n8. 직급별 연차 정책 적용 테스트",
        "priority": "medium",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "휴가 관련 DTO 및 Enum 클래스 구현",
            "description": "휴가 신청, 응답, 승인 관련 DTO와 휴가 타입, 상태 Enum 클래스를 구현합니다.",
            "dependencies": [],
            "details": "LeaveRequestCreateRequest (leaveType, startDate, endDate), LeaveRequestResponse, LeaveApprovalRequest (approvalComment) DTO를 생성합니다. LeaveType Enum (ANNUAL, HALF_DAY, SICK 등), LeaveStatus Enum (REQUESTED, APPROVED, REJECTED, CANCELLED)을 정의합니다. 날짜 유효성 검증 로직을 포함합니다.",
            "status": "done",
            "testStrategy": "DTO 직렬화/역직렬화 테스트, Enum 값 검증 테스트, 날짜 유효성 검증 단위 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-17T00:40:09.909Z"
          },
          {
            "id": 2,
            "title": "LeavePolicyService 구현 - 직급별 연차 정책 관리",
            "description": "직급별 연차 정책을 관리하고 근로자 등록 시 초기 연차를 설정하는 서비스를 구현합니다.",
            "dependencies": [],
            "details": "직급별 연차 정책 관리 로직 구현 (정규직: 15일, 비정규직: 10일, 파트타임: 5일). getAnnualLeaveByEmployeeType() 메서드로 직급별 기본 연차 조회. initializeEmployeeLeave() 메서드로 근로자 등록 시 remainingLeave 초기화. 정책 조회 및 적용 로직 구현.\n<info added on 2026-01-17T00:08:27.031Z>\nLeavePolicyService는 application 계층이 아닌 domain/service에 위치해야 합니다. 직급별 연차 정책은 비즈니스 규칙이므로 순수 도메인 로직으로 구현하며, Spring이나 infrastructure 의존성 없이 작성합니다. Application 계층(application/leave)에는 LeaveRequestAppService만 존재하며 휴가 신청/취소/승인/반려 UseCase만 처리합니다. LeavePolicyService는 domain/service 패키지에 일반 Kotlin class로 구현하고, @Service 어노테이션을 사용하지 않습니다.\n</info added on 2026-01-17T00:08:27.031Z>",
            "status": "done",
            "testStrategy": "직급별 연차 정책 조회 테스트, 근로자 초기 연차 설정 테스트, 정책 적용 단위 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-17T00:40:48.049Z"
          },
          {
            "id": 3,
            "title": "LeaveRequestService 핵심 비즈니스 로직 구현",
            "description": "휴가 신청, 취소, 승인, 반려 비즈니스 로직과 검증 로직을 구현합니다.",
            "dependencies": [
              2
            ],
            "details": "requestLeave(): 잔여 연차 확인, 반차 0.5일 차감, 날짜 중복 검증. cancelLeave(): REQUESTED 상태만 취소 가능, 연차 복구. approveLeave(): remainingLeave 차감, 상태 APPROVED 변경, 매니저 권한 검증. rejectLeave(): 상태 REJECTED 변경. 이미 승인된 휴가와 날짜 중복 방지 로직 구현. 트랜잭션 처리.",
            "status": "done",
            "testStrategy": "휴가 신청 로직 테스트, 잔여 연차 검증 테스트, 날짜 중복 검증 테스트, 승인 시 연차 차감 확인, 취소 시 연차 복구 테스트, 상태 전이 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-17T00:42:32.484Z"
          },
          {
            "id": 4,
            "title": "LeaveRequestController API 엔드포인트 구현",
            "description": "휴가 신청, 조회, 승인, 반려, 취소 REST API 엔드포인트를 구현합니다.",
            "dependencies": [
              1,
              3
            ],
            "details": "POST /api/leaves (휴가 신청, EMPLOYEE 권한), GET /api/leaves/my-leaves (본인 휴가 내역 조회), GET /api/leaves (매장별 휴가 신청 목록, MANAGER 권한), PATCH /api/leaves/{leaveId}/approve (승인, MANAGER 권한), PATCH /api/leaves/{leaveId}/reject (반려, MANAGER 권한), DELETE /api/leaves/{leaveId} (신청 취소, EMPLOYEE 권한). 각 엔드포인트에 적절한 권한 검증 및 예외 처리 추가.",
            "status": "done",
            "testStrategy": "휴가 신청 API 통합 테스트, 휴가 조회 API 테스트, 승인/반려 API 테스트, 취소 API 테스트, 권한별 접근 제어 테스트, 예외 처리 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-17T00:43:22.123Z"
          },
          {
            "id": 5,
            "title": "휴가 관리 시스템 통합 테스트 및 권한 검증",
            "description": "전체 휴가 관리 시스템의 통합 테스트와 매니저 권한 검증을 수행합니다.",
            "dependencies": [
              4
            ],
            "details": "전체 휴가 신청-승인-차감 플로우 통합 테스트. 매니저가 자신의 매장 근로자 휴가만 승인/반려 가능한지 검증. 다른 매장 근로자 휴가 접근 시 권한 오류 확인. 휴가 신청부터 승인까지 전체 시나리오 테스트. 동시성 처리 테스트 (동일 기간 중복 신청). 엣지 케이스 테스트 (잔여 연차 0일, 과거 날짜 신청 등).",
            "status": "done",
            "testStrategy": "전체 플로우 통합 테스트, 매장별 권한 검증 테스트, 동시성 테스트, 엣지 케이스 테스트, 성능 테스트, 보안 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-17T00:43:25.868Z"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "휴가 DTO 및 Enum, LeavePolicyService(직급별 연차 정책), LeaveRequestService(신청/취소/승인/반려), LeaveRequestController API, 통합 테스트 및 권한 검증을 포함하는 5개의 세부 작업으로 분해하세요. 각 작업은 잔여 연차 검증, 날짜 중복 방지, 승인 시 연차 차감 로직을 포함해야 합니다.",
        "updatedAt": "2026-01-17T00:43:25.868Z"
      },
      {
        "id": "8",
        "title": "급여 정책 관리 시스템 구현",
        "description": "슈퍼 관리자의 급여 계산 방식, 가산율 설정 및 관리 기능 구현",
        "details": "1. PayrollPolicyController:\n   - POST /api/payroll-policies (정책 생성, SUPER_ADMIN)\n   - GET /api/payroll-policies (정책 조회)\n   - GET /api/payroll-policies/active (현재 유효한 정책 조회)\n   - PUT /api/payroll-policies/{policyId} (정책 수정, SUPER_ADMIN)\n   - DELETE /api/payroll-policies/{policyId} (정책 삭제, SUPER_ADMIN)\n\n2. PayrollPolicyService:\n   - createPolicy(): 정책 생성\n     - policyType: WEEKDAY, NIGHT, WEEKEND, HOLIDAY\n     - multiplier: 가산율 (예: 1.0, 1.5, 2.0)\n     - effectiveFrom, effectiveTo: 유효 기간\n   - getActivePolicies(): 현재 유효한 정책 조회\n   - updatePolicy(): 정책 수정\n   - deletePolicy(): 정책 삭제\n\n3. 정책 유형별 기본값 설정:\n   - WEEKDAY: 1.0 (기본급)\n   - NIGHT: 1.5 (야간 가산)\n   - WEEKEND: 1.5 (주말 가산)\n   - HOLIDAY: 2.0 (공휴일 가산)\n\n4. 정책 유효성 검증:\n   - effectiveFrom < effectiveTo\n   - 동일 유형의 정책 기간 중복 방지\n\n5. DTO:\n   - PayrollPolicyCreateRequest (policyType, multiplier, effectiveFrom, effectiveTo)\n   - PayrollPolicyResponse\n   - PayrollPolicyUpdateRequest\n\n6. 정책 이력 관리:\n   - 과거 정책도 조회 가능하도록 soft delete",
        "testStrategy": "1. 급여 정책 생성 API 테스트\n2. 정책 유효 기간 검증 테스트\n3. 정책 중복 검증 테스트\n4. 현재 유효한 정책 조회 테스트\n5. 정책 수정/삭제 API 테스트\n6. 권한 검증 테스트 (SUPER_ADMIN만 접근)\n7. 정책 이력 조회 테스트",
        "priority": "medium",
        "dependencies": [
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "급여 정책 엔티티 및 Repository 구현",
            "description": "PayrollPolicy 엔티티와 PayrollPolicyRepository를 생성하고, 정책 유형(WEEKDAY, NIGHT, WEEKEND, HOLIDAY)과 가산율을 관리할 수 있는 데이터베이스 구조를 구현합니다.",
            "dependencies": [],
            "details": "PayrollPolicy 엔티티 필드: policyId(PK, UUID), policyType(ENUM: WEEKDAY, NIGHT, WEEKEND, HOLIDAY), multiplier(Decimal), effectiveFrom(Date), effectiveTo(Date), isDeleted(Boolean), createdAt, updatedAt. PayrollPolicyRepository에 findByPolicyTypeAndIsDeletedFalse, findByEffectiveFromLessThanEqualAndEffectiveToGreaterThanEqualAndIsDeletedFalse 등의 쿼리 메서드 추가. 정책 기간 중복 검증을 위한 쿼리 메서드 구현.",
            "status": "done",
            "testStrategy": "1. 엔티티 매핑 테스트 (JPA 스키마 생성 확인)\n2. Repository CRUD 테스트\n3. 정책 유형별 조회 테스트\n4. 유효 기간 기반 조회 쿼리 테스트\n5. Soft delete 동작 확인 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-17T00:44:24.790Z"
          },
          {
            "id": 2,
            "title": "급여 정책 DTO 및 유효성 검증 로직 구현",
            "description": "PayrollPolicyCreateRequest, PayrollPolicyUpdateRequest, PayrollPolicyResponse DTO를 생성하고, 정책 생성/수정 시 필요한 유효성 검증 로직을 구현합니다.",
            "dependencies": [
              1
            ],
            "details": "PayrollPolicyCreateRequest: policyType, multiplier, effectiveFrom, effectiveTo 필드와 @Valid 어노테이션 추가. PayrollPolicyUpdateRequest: multiplier, effectiveFrom, effectiveTo 수정 가능. PayrollPolicyResponse: 모든 정책 정보 포함. 유효성 검증: effectiveFrom < effectiveTo 확인, multiplier 범위 검증(0.5~3.0), 동일 유형의 정책 기간 중복 방지 로직 구현.",
            "status": "done",
            "testStrategy": "1. DTO 직렬화/역직렬화 테스트\n2. 유효 기간 검증 테스트 (effectiveFrom >= effectiveTo 시 예외)\n3. 가산율 범위 검증 테스트\n4. 정책 기간 중복 검증 테스트\n5. 필수 필드 누락 시 예외 처리 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-17T00:45:31.519Z"
          },
          {
            "id": 3,
            "title": "PayrollPolicyService 비즈니스 로직 구현",
            "description": "급여 정책 생성, 조회, 수정, 삭제 비즈니스 로직을 구현하고, 현재 유효한 정책 조회 및 정책 이력 관리 기능을 개발합니다.",
            "dependencies": [
              2
            ],
            "details": "createPolicy(): 정책 생성 시 중복 검증 후 저장, 기본값 설정(WEEKDAY: 1.0, NIGHT: 1.5, WEEKEND: 1.5, HOLIDAY: 2.0). getActivePolicies(): 현재 날짜 기준 유효한 정책 조회(effectiveFrom <= today <= effectiveTo). updatePolicy(): 정책 수정 시 기간 중복 재검증. deletePolicy(): soft delete 처리(isDeleted = true). getAllPolicies(): 과거 정책 포함 전체 조회. 트랜잭션 관리 적용.\n<info added on 2026-01-17T00:08:42.184Z>\nPayrollPolicyService는 Application 계층의 UseCase로 정책 CRUD만 담당. 실제 급여 계산 로직은 Task 9의 PayrollCalculationEngine(domain service)에서 처리. PayrollPolicy 엔티티는 데이터 저장소 역할. Application 계층에서 infrastructure 의존 없이 domain의 PayrollPolicyRepository만 사용. createPolicy(), getActivePolicies(), updatePolicy(), deletePolicy(), getAllPolicies() 메서드는 정책 관리만 수행하며 계산 로직 포함하지 않음.\n</info added on 2026-01-17T00:08:42.184Z>",
            "status": "done",
            "testStrategy": "1. 정책 생성 단위 테스트 (기본값 확인)\n2. 현재 유효한 정책 조회 테스트\n3. 정책 수정 테스트 (중복 검증 포함)\n4. Soft delete 테스트\n5. 정책 이력 조회 테스트\n6. 트랜잭션 롤백 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-17T00:48:27.662Z"
          },
          {
            "id": 4,
            "title": "PayrollPolicyController REST API 구현",
            "description": "급여 정책 관리를 위한 REST API 엔드포인트를 구현하고, SUPER_ADMIN 권한 검증을 적용합니다.",
            "dependencies": [
              3
            ],
            "details": "POST /api/payroll-policies: 정책 생성 (SUPER_ADMIN). GET /api/payroll-policies: 전체 정책 조회 (페이징 지원). GET /api/payroll-policies/active: 현재 유효한 정책 조회. PUT /api/payroll-policies/{policyId}: 정책 수정 (SUPER_ADMIN). DELETE /api/payroll-policies/{policyId}: 정책 삭제 (SUPER_ADMIN). @PreAuthorize 어노테이션으로 권한 검증. 예외 처리 및 적절한 HTTP 상태 코드 반환.",
            "status": "done",
            "testStrategy": "1. 정책 생성 API 통합 테스트\n2. 정책 조회 API 테스트 (페이징 포함)\n3. 현재 유효한 정책 조회 API 테스트\n4. 정책 수정 API 테스트\n5. 정책 삭제 API 테스트\n6. SUPER_ADMIN 권한 검증 테스트\n7. 권한 없는 사용자 접근 시 403 응답 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-17T00:48:29.420Z"
          },
          {
            "id": 5,
            "title": "급여 정책 관리 통합 테스트 및 문서화",
            "description": "급여 정책 관리 시스템의 전체 플로우 통합 테스트를 수행하고, API 문서를 작성합니다.",
            "dependencies": [
              4
            ],
            "details": "통합 테스트 시나리오: 1) SUPER_ADMIN으로 로그인 후 정책 생성, 2) 정책 기간 중복 시도 및 예외 확인, 3) 현재 유효한 정책 조회, 4) 정책 수정 및 이력 확인, 5) 정책 삭제 및 soft delete 확인, 6) 일반 사용자 권한으로 접근 시도 및 거부 확인. API 문서화: Swagger/OpenAPI 스펙 작성, 각 엔드포인트의 요청/응답 예시, 에러 코드 정리. 성능 테스트: 대량 정책 조회 시 응답 시간 측정.",
            "status": "done",
            "testStrategy": "1. 전체 플로우 통합 테스트 (생성→조회→수정→삭제)\n2. 정책 기간 중복 방지 시나리오 테스트\n3. 권한별 접근 제어 통합 테스트\n4. API 문서 자동 생성 확인 (Swagger UI)\n5. 성능 테스트 (100개 이상 정책 조회)\n6. 동시성 테스트 (동시 정책 생성 시도)",
            "parentId": "undefined",
            "updatedAt": "2026-01-17T00:48:31.054Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "PayrollPolicy 엔티티 및 Repository, 급여 정책 DTO 및 유효성 검증, PayrollPolicyService 비즈니스 로직, PayrollPolicyController REST API, 통합 테스트 및 문서화를 포함하는 5개의 세부 작업으로 분해하세요. 각 작업은 정책 기간 중복 방지, 유효 기간 검증, SUPER_ADMIN 권한 검증을 포함해야 합니다.",
        "updatedAt": "2026-01-17T00:48:31.054Z"
      },
      {
        "id": "9",
        "title": "급여 산정 시스템 구현",
        "description": "출퇴근 기록, 근무 일정, 휴가, 가산율을 기반으로 급여 자동 계산 및 배치 처리 구현",
        "details": "1. PayrollController:\n   - POST /api/payroll/calculate (급여 산정 실행, SUPER_ADMIN/MANAGER)\n   - GET /api/payroll (급여 내역 조회, 매장/기간 필터링)\n   - GET /api/payroll/my-payroll (본인 급여 내역 조회, EMPLOYEE)\n   - GET /api/payroll/{payrollId} (급여 상세 조회)\n\n2. PayrollService:\n   - calculatePayroll(employeeId, period): 급여 산정\n     - 해당 기간의 AttendanceRecord 조회\n     - 근무 시간 집계\n     - 근무 유형 판단 (평일/야간/주말/공휴일)\n     - 가산율 적용\n     - 승인된 휴가 반영 (무급/유급 처리)\n   - calculateBatch(storeId, period): 매장 전체 급여 산정\n\n3. 급여 계산 로직:\n   - 일 단위 계산: 출근 일수 × 일급\n   - 시간 단위 계산: 근무 시간 × 시급 × 가산율\n   - 야간 근무 판단: 22:00 ~ 06:00\n   - 주말 판단: 토요일, 일요일\n   - 공휴일 판단: 별도 공휴일 테이블 또는 외부 API\n\n4. PayrollCalculationEngine:\n   - calculateBaseAmount(): 기본급 계산\n   - calculateOvertimeAmount(): 가산 금액 계산\n   - applyPolicyMultiplier(): 정책 가산율 적용\n\n5. 배치 처리:\n   - Spring Batch 또는 @Scheduled 활용\n   - 매월 말일 자동 급여 산정\n\n6. DTO:\n   - PayrollCalculationRequest (employeeId, period)\n   - PayrollResponse (baseAmount, overtimeAmount, totalAmount, breakdown)\n   - PayrollDetailResponse\n\n7. 급여 데이터 무결성:\n   - 트랜잭션 처리\n   - 계산 실패 시 롤백",
        "testStrategy": "1. 급여 계산 로직 단위 테스트 (시간/일 단위)\n2. 가산율 적용 테스트 (평일/야간/주말/공휴일)\n3. 휴가 반영 테스트\n4. 급여 산정 API 통합 테스트\n5. 배치 처리 테스트\n6. 급여 조회 API 테스트 (필터링 포함)\n7. 트랜잭션 롤백 테스트\n8. 대량 데이터 처리 성능 테스트",
        "priority": "high",
        "dependencies": [
          "5",
          "6",
          "7",
          "8"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "급여 엔티티 및 Repository 구현",
            "description": "Payroll 엔티티, PayrollDetail 엔티티 및 관련 Repository 인터페이스 구현",
            "dependencies": [],
            "details": "1. Payroll 엔티티 생성: payrollId(PK, UUID), employeeId(FK), period(YearMonth), baseAmount, overtimeAmount, totalAmount, status(ENUM: DRAFT, CONFIRMED), calculatedAt, createdAt, updatedAt\n2. PayrollDetail 엔티티 생성: detailId(PK), payrollId(FK), workDate, workType(ENUM: WEEKDAY, NIGHT, WEEKEND, HOLIDAY), hours, rate, multiplier, amount\n3. PayrollRepository 인터페이스 생성: findByEmployeeIdAndPeriod, findByStoreIdAndPeriod, findByPeriod 등 쿼리 메서드 정의\n4. PayrollDetailRepository 인터페이스 생성: findByPayrollId 쿼리 메서드 정의\n5. 엔티티 간 연관관계 매핑 (Payroll - PayrollDetail: OneToMany)",
            "status": "done",
            "testStrategy": "1. 엔티티 매핑 테스트 (JPA 스키마 생성 확인)\n2. Repository CRUD 테스트\n3. 쿼리 메서드 동작 테스트\n4. 연관관계 매핑 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-17T00:50:01.558Z"
          },
          {
            "id": 2,
            "title": "급여 계산 엔진 구현",
            "description": "근무 시간, 근무 유형, 가산율을 기반으로 급여를 계산하는 핵심 로직 구현",
            "dependencies": [
              1
            ],
            "details": "1. PayrollCalculationEngine 클래스 생성\n2. calculateBaseAmount(): 기본급 계산 (근무 시간 × 시급 또는 출근 일수 × 일급)\n3. calculateOvertimeAmount(): 가산 금액 계산 (야간/주말/공휴일 근무 시간 × 시급 × 가산율)\n4. determineWorkType(): 근무 유형 판단 (평일/야간/주말/공휴일) - 22:00~06:00 야간, 토일 주말, 공휴일 테이블 참조\n5. applyPolicyMultiplier(): PayrollPolicy에서 가산율 조회 및 적용\n6. calculateTotalAmount(): 기본급 + 가산 금액 합산\n7. 휴가 반영 로직: 승인된 LeaveRequest 조회하여 무급/유급 처리\n<info added on 2026-01-17T00:08:57.337Z>\nPayrollCalculationEngine은 domain/service 패키지에 위치하는 도메인 서비스입니다. Spring Framework에 대한 의존성 없이 순수 Kotlin으로 구현되어야 하며, JPA나 인프라 계층의 Repository를 직접 호출하지 않습니다. 급여 계산은 핵심 비즈니스 규칙이므로 반드시 도메인 계층에 위치해야 합니다.\n\nApplication 계층의 PayrollService(UseCase)에서 필요한 데이터를 조회한 후 이 도메인 서비스를 호출하여 계산을 수행합니다. PayrollCalculationEngine은 도메인 모델(Attendance, PayrollPolicy, LeaveRequest 등)과 정책 정보만을 파라미터로 받아 계산 로직을 수행하며, 외부 의존성 없이 테스트 가능한 순수 함수로 구현되어야 합니다.\n\n모든 계산 메서드는 DomainContext를 첫 번째 파라미터로 받아야 하며, 계산 결과는 불변 객체(Value Object 또는 data class)로 반환합니다.\n</info added on 2026-01-17T00:08:57.337Z>",
            "status": "done",
            "testStrategy": "1. 기본급 계산 단위 테스트 (시간/일 단위)\n2. 가산율 적용 테스트 (평일/야간/주말/공휴일)\n3. 근무 유형 판단 로직 테스트\n4. 휴가 반영 테스트 (유급/무급)\n5. 경계값 테스트 (22:00, 06:00 등)",
            "parentId": "undefined",
            "updatedAt": "2026-01-17T00:50:55.226Z"
          },
          {
            "id": 3,
            "title": "PayrollService 구현",
            "description": "개별 및 배치 급여 산정 비즈니스 로직을 처리하는 서비스 레이어 구현",
            "dependencies": [
              2
            ],
            "details": "1. PayrollService 클래스 생성 및 PayrollCalculationEngine, AttendanceRecordRepository, LeaveRequestRepository, PayrollRepository 의존성 주입\n2. calculatePayroll(employeeId, period): 개별 급여 산정 - 해당 기간 AttendanceRecord 조회, 근무 시간 집계, 근무 유형 판단, 가산율 적용, 승인된 휴가 반영, Payroll 및 PayrollDetail 엔티티 생성 및 저장\n3. calculateBatch(storeId, period): 매장 전체 급여 산정 - 해당 매장의 모든 활성 직원 조회, 각 직원별 calculatePayroll 호출\n4. getPayrollList(): 급여 내역 조회 (매장/기간 필터링)\n5. getMyPayroll(): 본인 급여 내역 조회\n6. getPayrollDetail(): 급여 상세 조회\n7. 트랜잭션 처리 (@Transactional) 및 예외 처리",
            "status": "done",
            "testStrategy": "1. 개별 급여 산정 서비스 테스트\n2. 배치 급여 산정 서비스 테스트\n3. 급여 조회 서비스 테스트 (필터링 포함)\n4. 트랜잭션 롤백 테스트\n5. 예외 상황 처리 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-17T00:53:03.420Z"
          },
          {
            "id": 4,
            "title": "PayrollController 및 DTO 구현",
            "description": "급여 산정 및 조회를 위한 REST API 엔드포인트 및 DTO 구현",
            "dependencies": [
              3
            ],
            "details": "1. DTO 클래스 생성: PayrollCalculationRequest(employeeId, period), PayrollBatchRequest(storeId, period), PayrollResponse(payrollId, employeeId, period, baseAmount, overtimeAmount, totalAmount, status, calculatedAt), PayrollDetailResponse(workDate, workType, hours, rate, multiplier, amount), PayrollListResponse\n2. PayrollController 클래스 생성 및 PayrollService 의존성 주입\n3. POST /api/payroll/calculate: 급여 산정 실행 (@PreAuthorize SUPER_ADMIN/MANAGER)\n4. GET /api/payroll: 급여 내역 조회 (매장/기간 필터링, @RequestParam)\n5. GET /api/payroll/my-payroll: 본인 급여 내역 조회 (EMPLOYEE)\n6. GET /api/payroll/{payrollId}: 급여 상세 조회\n7. 입력 검증 (@Valid) 및 예외 처리",
            "status": "done",
            "testStrategy": "1. 급여 산정 API 통합 테스트\n2. 급여 조회 API 테스트 (필터링 포함)\n3. 본인 급여 조회 API 테스트\n4. 권한 검증 테스트 (SUPER_ADMIN/MANAGER/EMPLOYEE)\n5. 입력 검증 테스트\n6. 예외 응답 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-17T01:36:33.262Z"
          },
          {
            "id": 5,
            "title": "급여 자동 산정 배치 처리 구현",
            "description": "매월 말일 자동으로 급여를 산정하는 배치 작업 구현",
            "dependencies": [
              3
            ],
            "details": "1. PayrollBatchScheduler 클래스 생성 및 @EnableScheduling 설정\n2. @Scheduled(cron = \"0 0 1 L * ?\") 어노테이션으로 매월 말일 01:00 실행 설정\n3. executeMonthlyPayrollCalculation(): 모든 매장 조회, 각 매장별 calculateBatch 호출\n4. 배치 실행 로그 기록 (시작/종료 시간, 처리 건수, 성공/실패)\n5. 배치 실패 시 알림 또는 재시도 로직 구현\n6. 수동 배치 실행 API 추가 (POST /api/payroll/batch, SUPER_ADMIN)\n7. 배치 실행 이력 조회 API 추가 (GET /api/payroll/batch-history)\n8. 트랜잭션 처리 및 대량 데이터 처리 최적화 (청크 단위 처리)",
            "status": "done",
            "testStrategy": "1. 스케줄러 동작 테스트 (cron 표현식 검증)\n2. 배치 처리 테스트 (전체 매장 급여 산정)\n3. 배치 실행 로그 기록 테스트\n4. 배치 실패 시 롤백 테스트\n5. 수동 배치 실행 API 테스트\n6. 대량 데이터 처리 성능 테스트\n7. 배치 이력 조회 API 테스트",
            "parentId": "undefined",
            "updatedAt": "2026-01-17T01:43:21.627Z"
          }
        ],
        "complexity": 9,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Payroll 엔티티 및 Repository, 급여 계산 엔진(근무시간/유형/가산율 계산), PayrollService(개별/배치 급여 산정), PayrollController 및 DTO, 급여 자동 산정 배치 처리를 포함하는 5개의 세부 작업으로 분해하세요. 각 작업은 출퇴근 기록, 근무 일정, 휴가, 가산율을 통합하는 복잡한 계산 로직과 배치 처리를 포함해야 합니다.",
        "updatedAt": "2026-01-17T01:43:21.627Z"
      },
      {
        "id": "10",
        "title": "Flutter 모바일 앱 및 웹 어드민 구현",
        "description": "근로자용 Flutter 모바일 앱과 관리자용 Flutter Web 어드민 개발",
        "details": "1. Flutter 프로젝트 초기화:\n   - flutter create --platforms=ios,android,web\n   - 필요한 패키지 추가:\n     - http / dio (API 통신)\n     - provider / riverpod (상태 관리)\n     - flutter_secure_storage (토큰 저장)\n     - intl (날짜/시간 포맷)\n\n2. 모바일 앱 (근로자용):\n   - 로그인 화면\n   - 출근/퇴근 버튼 화면\n   - 본인 근무 일정 조회 화면\n   - 휴가 신청/취소 화면\n   - 본인 출퇴근 기록 조회 화면\n   - 본인 급여 내역 조회 화면\n\n3. 웹 어드민 (관리자용):\n   - 로그인 화면\n   - 대시보드 (매장 현황, 출근 현황)\n   - 매장 관리 화면 (SUPER_ADMIN)\n   - 근로자 관리 화면 (등록/수정/비활성화)\n   - 근무 일정 관리 화면 (캘린더 뷰)\n   - 출퇴근 기록 관리 화면 (수정 기능)\n   - 휴가 승인/반려 화면\n   - 급여 산정 및 조회 화면\n   - 급여 정책 관리 화면 (SUPER_ADMIN)\n\n4. API 통신 레이어:\n   - ApiService 클래스 (Dio 기반)\n   - JWT 토큰 자동 헤더 추가 인터셉터\n   - 에러 처리 및 재시도 로직\n\n5. 상태 관리:\n   - Provider 또는 Riverpod 활용\n   - AuthProvider (로그인 상태 관리)\n   - AttendanceProvider, ScheduleProvider 등\n\n6. UI/UX:\n   - Material Design 3 적용\n   - 반응형 레이아웃 (웹 어드민)\n   - 로딩 인디케이터, 에러 메시지 표시\n\n7. 보안:\n   - flutter_secure_storage로 토큰 안전하게 저장\n   - HTTPS 통신 강제",
        "testStrategy": "1. 로그인 플로우 테스트 (모바일/웹)\n2. 출퇴근 기능 테스트 (모바일)\n3. 근무 일정 조회 테스트\n4. 휴가 신청/승인 플로우 테스트\n5. 급여 조회 테스트\n6. 관리자 권한별 화면 접근 테스트\n7. API 통신 에러 처리 테스트\n8. 토큰 만료 시 재로그인 플로우 테스트\n9. 반응형 레이아웃 테스트 (웹)\n10. iOS/Android 빌드 및 실행 테스트",
        "priority": "medium",
        "dependencies": [
          "3",
          "4",
          "5",
          "6",
          "7",
          "9"
        ],
        "status": "cancelled",
        "subtasks": [
          {
            "id": 1,
            "title": "Flutter 프로젝트 초기화 및 기본 설정",
            "description": "Flutter 프로젝트 생성, 필요한 패키지 추가, 프로젝트 구조 설정 및 기본 환경 구성",
            "dependencies": [],
            "details": "flutter create --platforms=ios,android,web 명령으로 프로젝트 생성. pubspec.yaml에 dio, provider/riverpod, flutter_secure_storage, intl 패키지 추가. lib 폴더 내 screens, services, providers, models, utils 디렉토리 구조 생성. API 베이스 URL 및 환경 변수 설정. Material Design 3 테마 설정.",
            "status": "pending",
            "testStrategy": "Flutter 프로젝트 빌드 테스트 (flutter build), 패키지 의존성 확인 (flutter pub get), iOS/Android/Web 플랫폼별 실행 테스트",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "API 통신 레이어 및 인증 시스템 구현",
            "description": "Dio 기반 API 서비스 클래스, JWT 토큰 관리, 인터셉터, 에러 처리 및 인증 상태 관리 구현",
            "dependencies": [
              1
            ],
            "details": "ApiService 클래스 생성 (Dio 인스턴스 설정). JWT 토큰 자동 헤더 추가 인터셉터 구현. 토큰 만료 시 재로그인 처리 로직. flutter_secure_storage를 활용한 토큰 안전 저장. AuthProvider/AuthNotifier 구현 (로그인, 로그아웃, 토큰 갱신). 에러 처리 및 재시도 로직 구현. HTTPS 통신 강제 설정.",
            "status": "pending",
            "testStrategy": "API 통신 단위 테스트, JWT 토큰 저장/로드 테스트, 인터셉터 동작 확인, 토큰 만료 시나리오 테스트, 에러 핸들링 테스트",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "근로자용 모바일 앱 화면 구현",
            "description": "근로자용 Flutter 모바일 앱의 모든 화면 개발 (로그인, 출퇴근, 일정 조회, 휴가 신청, 급여 조회)",
            "dependencies": [
              2
            ],
            "details": "로그인 화면 (이메일/비밀번호 입력, 유효성 검증). 출근/퇴근 버튼 화면 (현재 시간 표시, 출퇴근 기록 API 호출). 본인 근무 일정 조회 화면 (월별 캘린더 뷰). 휴가 신청/취소 화면 (날짜 선택, 사유 입력, 잔여 휴가 표시). 본인 출퇴근 기록 조회 화면 (리스트 뷰, 날짜 필터). 본인 급여 내역 조회 화면 (기간별 급여 상세). 각 화면별 Provider 연결 및 상태 관리.",
            "status": "pending",
            "testStrategy": "각 화면별 UI 렌더링 테스트, 출퇴근 버튼 동작 테스트, 휴가 신청 플로우 테스트, API 연동 통합 테스트, 로딩/에러 상태 표시 테스트",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "관리자용 웹 어드민 화면 구현",
            "description": "관리자용 Flutter Web 어드민의 모든 화면 개발 (대시보드, 매장/근로자/일정/출퇴근/휴가/급여 관리)",
            "dependencies": [
              2
            ],
            "details": "로그인 화면 (웹 반응형). 대시보드 (매장 현황, 출근 현황 차트). 매장 관리 화면 (SUPER_ADMIN 전용, CRUD). 근로자 관리 화면 (등록/수정/비활성화, 테이블 뷰). 근무 일정 관리 화면 (캘린더 뷰, 드래그 앤 드롭). 출퇴근 기록 관리 화면 (수정 기능, 필터링). 휴가 승인/반려 화면 (대기 목록, 승인 버튼). 급여 산정 및 조회 화면 (기간 선택, 계산 실행). 급여 정책 관리 화면 (SUPER_ADMIN 전용). 반응형 레이아웃 적용.",
            "status": "pending",
            "testStrategy": "웹 화면별 렌더링 테스트, 권한별 화면 접근 제어 테스트, 반응형 레이아웃 테스트 (다양한 화면 크기), CRUD 기능 통합 테스트, 대시보드 데이터 로딩 테스트",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "통합 테스트 및 배포 준비",
            "description": "전체 시스템 통합 테스트, 보안 검증, 성능 최적화 및 iOS/Android/Web 빌드 및 배포 준비",
            "dependencies": [
              3,
              4
            ],
            "details": "전체 사용자 플로우 통합 테스트 (근로자/관리자). 보안 검증 (토큰 저장, HTTPS 통신, 권한 체크). 성능 최적화 (이미지 최적화, 레이지 로딩). iOS/Android 빌드 설정 (앱 아이콘, 스플래시 스크린). Web 빌드 및 호스팅 준비. 에러 로깅 및 모니터링 설정. 사용자 매뉴얼 작성.",
            "status": "pending",
            "testStrategy": "E2E 테스트 (로그인부터 급여 조회까지 전체 플로우), iOS/Android 실기기 테스트, 웹 브라우저 호환성 테스트, 보안 취약점 스캔, 성능 테스트 (로딩 시간, 메모리 사용량)",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Flutter 프로젝트 초기화 및 기본 설정, API 통신 레이어 및 인증 시스템, 근로자용 모바일 앱 화면, 관리자용 웹 어드민 화면, 통합 테스트 및 배포 준비를 포함하는 5개의 세부 작업으로 분해하세요. 각 작업은 iOS/Android/Web 멀티 플랫폼 지원, JWT 토큰 관리, 상태 관리, 반응형 레이아웃을 포함해야 합니다.",
        "updatedAt": "2026-01-17T00:34:48.476Z"
      },
      {
        "id": "11",
        "title": "DDD 아키텍처 리팩토링 - User/Employee 분리 및 순수 도메인 모델 구축",
        "description": "User와 Employee를 분리하여 인증/인가와 근로자 정보를 독립적으로 관리하고, 순수 Kotlin 도메인 모델(Aggregate Root)과 Infrastructure 구현체를 가이드라인에 따라 재구성",
        "details": "## 1. Domain 모듈 - 순수 도메인 모델 생성\n\n### 1.1 DomainContext 인터페이스 정의\n**위치:** `domain/src/main/kotlin/com/lms/domain/common/DomainContext.kt`\n```kotlin\npackage com.lms.domain.common\n\nimport java.time.Instant\nimport java.util.UUID\n\n/**\n * 모든 도메인 요청의 공통 컨텍스트\n * HTTP, Kafka 등 외부 요청에서 추출한 메타데이터\n */\ninterface DomainContext {\n    val serviceName: String      // 요청 도메인/서비스명\n    val userId: String            // 사용자 ID\n    val userName: String          // 사용자 이름\n    val roleId: String            // 역할 ID (Role enum의 name)\n    val requestId: UUID           // 요청 추적용 UUID\n    val requestedAt: Instant      // 요청 시각\n    val clientIp: String          // 클라이언트 IP\n}\n\n/**\n * DomainContext 기본 구현체\n */\ndata class DomainContextBase(\n    override val serviceName: String,\n    override val userId: String,\n    override val userName: String,\n    override val roleId: String,\n    override val requestId: UUID = UUID.randomUUID(),\n    override val requestedAt: Instant = Instant.now(),\n    override val clientIp: String\n) : DomainContext\n```\n\n### 1.2 User Aggregate Root (인증/인가 전용)\n**위치:** `domain/src/main/kotlin/com/lms/domain/model/user/User.kt`\n```kotlin\npackage com.lms.domain.model.user\n\nimport com.lms.domain.common.DomainContext\nimport java.time.Instant\n\n/**\n * User Aggregate Root\n * 인증 및 인가 정보만 관리 (순수 Kotlin, Spring/JPA 의존 금지)\n */\ndata class User private constructor(\n    val id: UserId,\n    val email: Email,\n    val password: Password,\n    val role: Role,\n    val isActive: Boolean,\n    val createdAt: Instant,\n    val lastLoginAt: Instant?\n) {\n    companion object {\n        /**\n         * 새로운 사용자 생성\n         */\n        fun create(\n            context: DomainContext,\n            email: Email,\n            password: Password,\n            role: Role\n        ): User {\n            require(role != Role.SUPER_ADMIN) { \n                \"SUPER_ADMIN은 시스템에서만 생성 가능합니다.\" \n            }\n            \n            return User(\n                id = UserId.generate(),\n                email = email,\n                password = password,\n                role = role,\n                isActive = true,\n                createdAt = context.requestedAt,\n                lastLoginAt = null\n            )\n        }\n        \n        /**\n         * 기존 사용자 재구성 (Repository에서 조회 시)\n         */\n        fun reconstruct(\n            id: UserId,\n            email: Email,\n            password: Password,\n            role: Role,\n            isActive: Boolean,\n            createdAt: Instant,\n            lastLoginAt: Instant?\n        ): User = User(id, email, password, role, isActive, createdAt, lastLoginAt)\n    }\n    \n    /**\n     * 로그인 처리\n     */\n    fun login(context: DomainContext, inputPassword: String): User {\n        require(isActive) { \"비활성화된 사용자입니다.\" }\n        require(password.matches(inputPassword)) { \"비밀번호가 일치하지 않습니다.\" }\n        \n        return this.copy(lastLoginAt = context.requestedAt)\n    }\n    \n    /**\n     * 비밀번호 변경\n     */\n    fun changePassword(\n        context: DomainContext,\n        currentPassword: String,\n        newPassword: Password\n    ): User {\n        require(password.matches(currentPassword)) { \"현재 비밀번호가 일치하지 않습니다.\" }\n        return this.copy(password = newPassword)\n    }\n    \n    /**\n     * 사용자 비활성화\n     */\n    fun deactivate(context: DomainContext): User {\n        require(isActive) { \"이미 비활성화된 사용자입니다.\" }\n        return this.copy(isActive = false)\n    }\n    \n    /**\n     * 사용자 활성화\n     */\n    fun activate(context: DomainContext): User {\n        require(!isActive) { \"이미 활성화된 사용자입니다.\" }\n        return this.copy(isActive = true)\n    }\n}\n```\n\n### 1.3 User Value Objects\n**UserId:** `domain/src/main/kotlin/com/lms/domain/model/user/UserId.kt`\n```kotlin\npackage com.lms.domain.model.user\n\nimport java.util.UUID\n\n@JvmInline\nvalue class UserId(val value: String) {\n    init {\n        require(value.isNotBlank()) { \"UserId는 비어있을 수 없습니다.\" }\n    }\n    \n    companion object {\n        fun generate(): UserId = UserId(UUID.randomUUID().toString())\n        fun from(value: String): UserId = UserId(value)\n    }\n}\n```\n\n**Email:** `domain/src/main/kotlin/com/lms/domain/model/user/Email.kt`\n```kotlin\npackage com.lms.domain.model.user\n\n@JvmInline\nvalue class Email(val value: String) {\n    init {\n        require(value.matches(Regex(\"^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}$\"))) {\n            \"유효하지 않은 이메일 형식입니다: $value\"\n        }\n    }\n}\n```\n\n**Password:** `domain/src/main/kotlin/com/lms/domain/model/user/Password.kt`\n```kotlin\npackage com.lms.domain.model.user\n\n@JvmInline\nvalue class Password(val encodedValue: String) {\n    init {\n        require(encodedValue.isNotBlank()) { \"비밀번호는 비어있을 수 없습니다.\" }\n    }\n    \n    /**\n     * 평문 비밀번호와 비교\n     * 실제 비교는 Infrastructure 레이어의 PasswordEncoder 사용\n     */\n    fun matches(plainPassword: String): Boolean {\n        // 도메인에서는 인터페이스만 정의, 실제 구현은 infrastructure\n        throw UnsupportedOperationException(\n            \"Password matching must be delegated to infrastructure PasswordEncoder\"\n        )\n    }\n}\n```\n\n### 1.4 Employee Aggregate Root (근로자 정보)\n**위치:** `domain/src/main/kotlin/com/lms/domain/model/employee/Employee.kt`\n```kotlin\npackage com.lms.domain.model.employee\n\nimport com.lms.domain.common.DomainContext\nimport com.lms.domain.model.store.StoreId\nimport com.lms.domain.model.user.UserId\nimport java.math.BigDecimal\nimport java.time.Instant\n\n/**\n * Employee Aggregate Root\n * 근로자 정보 관리 (순수 Kotlin)\n */\ndata class Employee private constructor(\n    val id: EmployeeId,\n    val userId: UserId,              // User 1:1 관계\n    val name: EmployeeName,\n    val employeeType: EmployeeType,\n    val storeId: StoreId?,\n    val remainingLeave: RemainingLeave,\n    val isActive: Boolean,\n    val createdAt: Instant\n) {\n    companion object {\n        /**\n         * 새로운 근로자 생성\n         */\n        fun create(\n            context: DomainContext,\n            userId: UserId,\n            name: EmployeeName,\n            employeeType: EmployeeType,\n            storeId: StoreId?\n        ): Employee {\n            // 직급별 초기 연차 설정\n            val initialLeave = when (employeeType) {\n                EmployeeType.REGULAR -> RemainingLeave(BigDecimal(\"15\"))\n                EmployeeType.IRREGULAR -> RemainingLeave(BigDecimal(\"11\"))\n                EmployeeType.PART_TIME -> RemainingLeave(BigDecimal.ZERO)\n            }\n            \n            return Employee(\n                id = EmployeeId.generate(),\n                userId = userId,\n                name = name,\n                employeeType = employeeType,\n                storeId = storeId,\n                remainingLeave = initialLeave,\n                isActive = true,\n                createdAt = context.requestedAt\n            )\n        }\n        \n        /**\n         * 기존 근로자 재구성\n         */\n        fun reconstruct(\n            id: EmployeeId,\n            userId: UserId,\n            name: EmployeeName,\n            employeeType: EmployeeType,\n            storeId: StoreId?,\n            remainingLeave: RemainingLeave,\n            isActive: Boolean,\n            createdAt: Instant\n        ): Employee = Employee(\n            id, userId, name, employeeType, storeId, \n            remainingLeave, isActive, createdAt\n        )\n    }\n    \n    /**\n     * 연차 차감 (휴가 승인 시)\n     */\n    fun deductLeave(context: DomainContext, days: BigDecimal): Employee {\n        val newLeave = remainingLeave.deduct(days)\n        return this.copy(remainingLeave = newLeave)\n    }\n    \n    /**\n     * 연차 복구 (휴가 취소 시)\n     */\n    fun restoreLeave(context: DomainContext, days: BigDecimal): Employee {\n        val newLeave = remainingLeave.add(days)\n        return this.copy(remainingLeave = newLeave)\n    }\n    \n    /**\n     * 매장 배정\n     */\n    fun assignStore(context: DomainContext, storeId: StoreId): Employee {\n        return this.copy(storeId = storeId)\n    }\n    \n    /**\n     * 근로자 유형 변경\n     */\n    fun changeType(context: DomainContext, newType: EmployeeType): Employee {\n        return this.copy(employeeType = newType)\n    }\n    \n    /**\n     * 비활성화\n     */\n    fun deactivate(context: DomainContext): Employee {\n        require(isActive) { \"이미 비활성화된 근로자입니다.\" }\n        return this.copy(isActive = false)\n    }\n}\n```\n\n### 1.5 Employee Value Objects\n**EmployeeId, EmployeeName, RemainingLeave** 생성\n- `domain/src/main/kotlin/com/lms/domain/model/employee/`\n\n```kotlin\n@JvmInline\nvalue class EmployeeId(val value: String) {\n    companion object {\n        fun generate(): EmployeeId = EmployeeId(UUID.randomUUID().toString())\n    }\n}\n\n@JvmInline\nvalue class EmployeeName(val value: String) {\n    init {\n        require(value.isNotBlank()) { \"이름은 비어있을 수 없습니다.\" }\n        require(value.length <= 100) { \"이름은 100자를 초과할 수 없습니다.\" }\n    }\n}\n\n@JvmInline\nvalue class RemainingLeave(val value: BigDecimal) {\n    init {\n        require(value >= BigDecimal.ZERO) { \"잔여 연차는 음수일 수 없습니다.\" }\n    }\n    \n    fun deduct(days: BigDecimal): RemainingLeave {\n        require(days > BigDecimal.ZERO) { \"차감할 연차는 0보다 커야 합니다.\" }\n        require(value >= days) { \"잔여 연차가 부족합니다. 현재: $value, 요청: $days\" }\n        return RemainingLeave(value - days)\n    }\n    \n    fun add(days: BigDecimal): RemainingLeave {\n        require(days > BigDecimal.ZERO) { \"복구할 연차는 0보다 커야 합니다.\" }\n        return RemainingLeave(value + days)\n    }\n}\n```\n\n### 1.6 Store Aggregate Root\n**위치:** `domain/src/main/kotlin/com/lms/domain/model/store/Store.kt`\n```kotlin\npackage com.lms.domain.model.store\n\nimport com.lms.domain.common.DomainContext\nimport java.time.Instant\n\ndata class Store private constructor(\n    val id: StoreId,\n    val name: StoreName,\n    val location: StoreLocation,\n    val createdAt: Instant\n) {\n    companion object {\n        fun create(\n            context: DomainContext,\n            name: StoreName,\n            location: StoreLocation\n        ): Store = Store(\n            id = StoreId.generate(),\n            name = name,\n            location = location,\n            createdAt = context.requestedAt\n        )\n        \n        fun reconstruct(\n            id: StoreId,\n            name: StoreName,\n            location: StoreLocation,\n            createdAt: Instant\n        ): Store = Store(id, name, location, createdAt)\n    }\n    \n    fun update(context: DomainContext, name: StoreName, location: StoreLocation): Store {\n        return this.copy(name = name, location = location)\n    }\n}\n\n@JvmInline\nvalue class StoreId(val value: String) {\n    companion object {\n        fun generate(): StoreId = StoreId(UUID.randomUUID().toString())\n    }\n}\n\n@JvmInline\nvalue class StoreName(val value: String) {\n    init {\n        require(value.isNotBlank()) { \"매장 이름은 비어있을 수 없습니다.\" }\n    }\n}\n\n@JvmInline\nvalue class StoreLocation(val value: String) {\n    init {\n        require(value.isNotBlank()) { \"매장 위치는 비어있을 수 없습니다.\" }\n    }\n}\n```\n\n### 1.7 Repository 인터페이스 (Domain에 정의)\n**UserRepository:** `domain/src/main/kotlin/com/lms/domain/model/user/UserRepository.kt`\n```kotlin\npackage com.lms.domain.model.user\n\ninterface UserRepository {\n    fun save(user: User): User\n    fun findById(userId: UserId): User?\n    fun findByEmail(email: Email): User?\n    fun existsByEmail(email: Email): Boolean\n    fun delete(userId: UserId)\n}\n```\n\n**EmployeeRepository:** `domain/src/main/kotlin/com/lms/domain/model/employee/EmployeeRepository.kt`\n```kotlin\npackage com.lms.domain.model.employee\n\nimport com.lms.domain.model.store.StoreId\nimport com.lms.domain.model.user.UserId\n\ninterface EmployeeRepository {\n    fun save(employee: Employee): Employee\n    fun findById(employeeId: EmployeeId): Employee?\n    fun findByUserId(userId: UserId): Employee?\n    fun findByStoreId(storeId: StoreId): List<Employee>\n    fun findAll(): List<Employee>\n    fun delete(employeeId: EmployeeId)\n}\n```\n\n**StoreRepository:** `domain/src/main/kotlin/com/lms/domain/model/store/StoreRepository.kt`\n```kotlin\npackage com.lms.domain.model.store\n\ninterface StoreRepository {\n    fun save(store: Store): Store\n    fun findById(storeId: StoreId): Store?\n    fun findAll(): List<Store>\n    fun delete(storeId: StoreId)\n}\n```\n\n---\n\n## 2. Infrastructure 모듈 - JPA Entity 및 Repository 구현\n\n### 2.1 UserEntity (JPA)\n**위치:** `infrastructure/src/main/kotlin/com/lms/infrastructure/persistence/entity/UserEntity.kt`\n```kotlin\npackage com.lms.infrastructure.persistence.entity\n\nimport jakarta.persistence.*\nimport java.time.Instant\nimport java.util.UUID\n\n@Entity\n@Table(\n    name = \"users\",\n    indexes = [Index(name = \"idx_user_email\", columnList = \"email\", unique = true)]\n)\nclass UserEntity(\n    @Id\n    @Column(name = \"user_id\", length = 36)\n    val id: String = UUID.randomUUID().toString(),\n    \n    @Column(nullable = false, unique = true, length = 100)\n    var email: String,\n    \n    @Column(nullable = false, length = 255)\n    var password: String,\n    \n    @Enumerated(EnumType.STRING)\n    @Column(nullable = false, length = 20)\n    var role: String,  // Role enum의 name\n    \n    @Column(name = \"is_active\", nullable = false)\n    var isActive: Boolean = true,\n    \n    @Column(name = \"created_at\", nullable = false)\n    val createdAt: Instant = Instant.now(),\n    \n    @Column(name = \"last_login_at\")\n    var lastLoginAt: Instant? = null\n) : BaseEntity()\n```\n\n### 2.2 EmployeeEntity 수정 (User 참조)\n**위치:** `infrastructure/src/main/kotlin/com/lms/infrastructure/persistence/entity/EmployeeEntity.kt`\n```kotlin\npackage com.lms.infrastructure.persistence.entity\n\nimport jakarta.persistence.*\nimport java.math.BigDecimal\nimport java.time.Instant\nimport java.util.UUID\n\n@Entity\n@Table(\n    name = \"employees\",\n    indexes = [\n        Index(name = \"idx_employee_user\", columnList = \"user_id\", unique = true),\n        Index(name = \"idx_employee_store\", columnList = \"store_id\")\n    ]\n)\nclass EmployeeEntity(\n    @Id\n    @Column(name = \"employee_id\", length = 36)\n    val id: String = UUID.randomUUID().toString(),\n    \n    @Column(name = \"user_id\", nullable = false, length = 36)\n    var userId: String,  // User 1:1 관계\n    \n    @Column(nullable = false, length = 100)\n    var name: String,\n    \n    @Column(name = \"employee_type\", nullable = false, length = 20)\n    var employeeType: String,  // EmployeeType enum의 name\n    \n    @Column(name = \"store_id\", length = 36)\n    var storeId: String? = null,\n    \n    @Column(name = \"remaining_leave\", nullable = false, precision = 5, scale = 1)\n    var remainingLeave: BigDecimal = BigDecimal.ZERO,\n    \n    @Column(name = \"is_active\", nullable = false)\n    var isActive: Boolean = true,\n    \n    @Column(name = \"created_at\", nullable = false)\n    val createdAt: Instant = Instant.now()\n) : BaseEntity()\n```\n\n### 2.3 Mapper (Domain ↔ Entity 변환)\n**UserMapper:** `infrastructure/src/main/kotlin/com/lms/infrastructure/persistence/mapper/UserMapper.kt`\n```kotlin\npackage com.lms.infrastructure.persistence.mapper\n\nimport com.lms.domain.model.user.*\nimport com.lms.infrastructure.persistence.entity.UserEntity\n\nobject UserMapper {\n    fun toDomain(entity: UserEntity): User {\n        return User.reconstruct(\n            id = UserId.from(entity.id),\n            email = Email(entity.email),\n            password = Password(entity.password),\n            role = Role.valueOf(entity.role),\n            isActive = entity.isActive,\n            createdAt = entity.createdAt,\n            lastLoginAt = entity.lastLoginAt\n        )\n    }\n    \n    fun toEntity(domain: User): UserEntity {\n        return UserEntity(\n            id = domain.id.value,\n            email = domain.email.value,\n            password = domain.password.encodedValue,\n            role = domain.role.name,\n            isActive = domain.isActive,\n            createdAt = domain.createdAt,\n            lastLoginAt = domain.lastLoginAt\n        )\n    }\n}\n```\n\n**EmployeeMapper:** `infrastructure/src/main/kotlin/com/lms/infrastructure/persistence/mapper/EmployeeMapper.kt`\n```kotlin\npackage com.lms.infrastructure.persistence.mapper\n\nimport com.lms.domain.model.employee.*\nimport com.lms.domain.model.store.StoreId\nimport com.lms.domain.model.user.UserId\nimport com.lms.infrastructure.persistence.entity.EmployeeEntity\n\nobject EmployeeMapper {\n    fun toDomain(entity: EmployeeEntity): Employee {\n        return Employee.reconstruct(\n            id = EmployeeId(entity.id),\n            userId = UserId(entity.userId),\n            name = EmployeeName(entity.name),\n            employeeType = EmployeeType.valueOf(entity.employeeType),\n            storeId = entity.storeId?.let { StoreId(it) },\n            remainingLeave = RemainingLeave(entity.remainingLeave),\n            isActive = entity.isActive,\n            createdAt = entity.createdAt\n        )\n    }\n    \n    fun toEntity(domain: Employee): EmployeeEntity {\n        return EmployeeEntity(\n            id = domain.id.value,\n            userId = domain.userId.value,\n            name = domain.name.value,\n            employeeType = domain.employeeType.name,\n            storeId = domain.storeId?.value,\n            remainingLeave = domain.remainingLeave.value,\n            isActive = domain.isActive,\n            createdAt = domain.createdAt\n        )\n    }\n}\n```\n\n### 2.4 Repository 구현\n**UserRepositoryImpl:** `infrastructure/src/main/kotlin/com/lms/infrastructure/persistence/repository/UserRepositoryImpl.kt`\n```kotlin\npackage com.lms.infrastructure.persistence.repository\n\nimport com.lms.domain.model.user.*\nimport com.lms.infrastructure.persistence.mapper.UserMapper\nimport org.springframework.data.jpa.repository.JpaRepository\nimport org.springframework.stereotype.Repository\n\ninterface UserJpaRepository : JpaRepository<UserEntity, String> {\n    fun findByEmail(email: String): UserEntity?\n    fun existsByEmail(email: String): Boolean\n}\n\n@Repository\nclass UserRepositoryImpl(\n    private val jpaRepository: UserJpaRepository\n) : UserRepository {\n    \n    override fun save(user: User): User {\n        val entity = UserMapper.toEntity(user)\n        val saved = jpaRepository.save(entity)\n        return UserMapper.toDomain(saved)\n    }\n    \n    override fun findById(userId: UserId): User? {\n        return jpaRepository.findById(userId.value)\n            .map { UserMapper.toDomain(it) }\n            .orElse(null)\n    }\n    \n    override fun findByEmail(email: Email): User? {\n        return jpaRepository.findByEmail(email.value)\n            ?.let { UserMapper.toDomain(it) }\n    }\n    \n    override fun existsByEmail(email: Email): Boolean {\n        return jpaRepository.existsByEmail(email.value)\n    }\n    \n    override fun delete(userId: UserId) {\n        jpaRepository.deleteById(userId.value)\n    }\n}\n```\n\n**EmployeeRepositoryImpl:** `infrastructure/src/main/kotlin/com/lms/infrastructure/persistence/repository/EmployeeRepositoryImpl.kt`\n```kotlin\npackage com.lms.infrastructure.persistence.repository\n\nimport com.lms.domain.model.employee.*\nimport com.lms.domain.model.store.StoreId\nimport com.lms.domain.model.user.UserId\nimport com.lms.infrastructure.persistence.mapper.EmployeeMapper\nimport org.springframework.data.jpa.repository.JpaRepository\nimport org.springframework.stereotype.Repository\n\ninterface EmployeeJpaRepository : JpaRepository<EmployeeEntity, String> {\n    fun findByUserId(userId: String): EmployeeEntity?\n    fun findByStoreId(storeId: String): List<EmployeeEntity>\n}\n\n@Repository\nclass EmployeeRepositoryImpl(\n    private val jpaRepository: EmployeeJpaRepository\n) : EmployeeRepository {\n    \n    override fun save(employee: Employee): Employee {\n        val entity = EmployeeMapper.toEntity(employee)\n        val saved = jpaRepository.save(entity)\n        return EmployeeMapper.toDomain(saved)\n    }\n    \n    override fun findById(employeeId: EmployeeId): Employee? {\n        return jpaRepository.findById(employeeId.value)\n            .map { EmployeeMapper.toDomain(it) }\n            .orElse(null)\n    }\n    \n    override fun findByUserId(userId: UserId): Employee? {\n        return jpaRepository.findByUserId(userId.value)\n            ?.let { EmployeeMapper.toDomain(it) }\n    }\n    \n    override fun findByStoreId(storeId: StoreId): List<Employee> {\n        return jpaRepository.findByStoreId(storeId.value)\n            .map { EmployeeMapper.toDomain(it) }\n    }\n    \n    override fun findAll(): List<Employee> {\n        return jpaRepository.findAll()\n            .map { EmployeeMapper.toDomain(it) }\n    }\n    \n    override fun delete(employeeId: EmployeeId) {\n        jpaRepository.deleteById(employeeId.value)\n    }\n}\n```\n\n---\n\n## 3. 데이터베이스 마이그레이션\n\n### 3.1 기존 employees 테이블 백업 및 분리\n```sql\n-- 1. users 테이블 생성\nCREATE TABLE users (\n    user_id VARCHAR(36) PRIMARY KEY,\n    email VARCHAR(100) NOT NULL UNIQUE,\n    password VARCHAR(255) NOT NULL,\n    role VARCHAR(20) NOT NULL,\n    is_active BOOLEAN NOT NULL DEFAULT TRUE,\n    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    last_login_at TIMESTAMP NULL,\n    INDEX idx_user_email (email)\n);\n\n-- 2. 기존 employees 데이터에서 users 생성\nINSERT INTO users (user_id, email, password, role, is_active, created_at)\nSELECT \n    UUID() as user_id,\n    email,\n    password,\n    role,\n    is_active,\n    created_at\nFROM employees;\n\n-- 3. employees 테이블 재구성\nALTER TABLE employees \n    ADD COLUMN user_id VARCHAR(36) AFTER employee_id,\n    DROP COLUMN email,\n    DROP COLUMN password,\n    DROP COLUMN role;\n\n-- 4. user_id 매핑 (이메일 기준)\nUPDATE employees e\nJOIN users u ON e.원본email = u.email\nSET e.user_id = u.user_id;\n\n-- 5. user_id NOT NULL 제약조건 추가\nALTER TABLE employees \n    MODIFY COLUMN user_id VARCHAR(36) NOT NULL,\n    ADD CONSTRAINT fk_employee_user FOREIGN KEY (user_id) REFERENCES users(user_id),\n    ADD UNIQUE INDEX idx_employee_user (user_id);\n```\n\n---\n\n## 4. Application 레이어 수정\n\n기존 Application Service들을 새로운 도메인 모델에 맞게 수정:\n- UserRepository와 EmployeeRepository를 분리하여 주입\n- DomainContext를 첫 번째 인자로 받도록 수정\n- 도메인 로직은 Aggregate Root의 메서드 호출로 위임\n\n**예시:** `application/src/main/kotlin/com/lms/application/employee/RegisterEmployeeAppService.kt`\n```kotlin\n@Service\n@Transactional\nclass RegisterEmployeeAppService(\n    private val userRepository: UserRepository,\n    private val employeeRepository: EmployeeRepository,\n    private val passwordEncoder: PasswordEncoder\n) {\n    fun execute(context: DomainContext, command: RegisterEmployeeCommand): EmployeeResult {\n        // 1. 이메일 중복 검증\n        val email = Email(command.email)\n        require(!userRepository.existsByEmail(email)) { \n            \"이미 사용 중인 이메일입니다: ${email.value}\" \n        }\n        \n        // 2. User 생성\n        val encodedPassword = Password(passwordEncoder.encode(command.password))\n        val user = User.create(\n            context = context,\n            email = email,\n            password = encodedPassword,\n            role = command.role\n        )\n        val savedUser = userRepository.save(user)\n        \n        // 3. Employee 생성\n        val employee = Employee.create(\n            context = context,\n            userId = savedUser.id,\n            name = EmployeeName(command.name),\n            employeeType = command.employeeType,\n            storeId = command.storeId?.let { StoreId(it) }\n        )\n        val savedEmployee = employeeRepository.save(employee)\n        \n        return EmployeeResult.from(savedEmployee)\n    }\n}\n```\n\n---\n\n## 5. 가이드라인 준수 체크리스트\n\n### ✅ Domain 모듈\n- [x] 순수 Kotlin 코드 (Spring, JPA 의존 금지)\n- [x] Aggregate Root에 비즈니스 로직 포함\n- [x] 모든 Aggregate 함수는 DomainContext를 첫 인자로 받음\n- [x] Repository 인터페이스를 domain에 정의\n- [x] Value Object는 @JvmInline 또는 data class\n- [x] sealed class 사용 (필요시 EmployeeType을 sealed class로 변환 가능)\n\n### ✅ Infrastructure 모듈\n- [x] JPA Entity 구현 (Jakarta Persistence)\n- [x] Domain Repository 인터페이스 구현\n- [x] Mapper를 통한 Domain ↔ Entity 변환\n- [x] domain 모듈만 의존\n\n### ✅ Application 모듈\n- [x] @Service, @Transactional 사용\n- [x] domain만 의존 (infrastructure 직접 의존 금지)\n- [x] UseCase별 AppService 분리\n- [x] 비즈니스 로직은 도메인에 위임\n\n---\n\n## 6. 추가 고려사항\n\n### 6.1 도메인 이벤트\nUser/Employee 변경 시 이벤트 발행:\n```kotlin\n// domain/event/UserCreatedEvent.kt\ndata class UserCreatedEvent(\n    override val context: DomainContext,\n    override val payload: UserCreatedPayload\n) : DomainEventBase<UserCreatedPayload>()\n\ndata class UserCreatedPayload(\n    val userId: String,\n    val email: String,\n    val role: String\n)\n```\n\n### 6.2 도메인 서비스\n복수 Aggregate 간 로직:\n```kotlin\n// domain/service/EmployeeRegistrationService.kt\nclass EmployeeRegistrationService {\n    fun validateEmployeeRegistration(\n        context: DomainContext,\n        user: User,\n        employee: Employee,\n        store: Store?\n    ) {\n        // User와 Employee, Store 간 복잡한 검증 로직\n    }\n}\n```",
        "testStrategy": "## 테스트 전략\n\n### 1. Domain 모듈 단위 테스트 (Kotest)\n\n#### 1.1 User Aggregate Root 테스트\n**파일:** `domain/src/test/kotlin/com/lms/domain/model/user/UserTest.kt`\n```kotlin\nclass UserTest : StringSpec({\n    \"새로운 User를 생성할 수 있다\" {\n        // Given\n        val context = createMockContext()\n        val email = Email(\"test@example.com\")\n        val password = Password(\"encoded123\")\n        \n        // When\n        val user = User.create(context, email, password, Role.EMPLOYEE)\n        \n        // Then\n        user.email shouldBe email\n        user.role shouldBe Role.EMPLOYEE\n        user.isActive shouldBe true\n    }\n    \n    \"SUPER_ADMIN은 create로 생성할 수 없다\" {\n        // Given\n        val context = createMockContext()\n        \n        // When & Then\n        shouldThrow<IllegalArgumentException> {\n            User.create(context, Email(\"admin@test.com\"), Password(\"pw\"), Role.SUPER_ADMIN)\n        }\n    }\n    \n    \"비밀번호 변경 시 현재 비밀번호가 일치해야 한다\" {\n        // Given\n        val user = createTestUser()\n        val context = createMockContext()\n        \n        // When & Then\n        shouldThrow<IllegalArgumentException> {\n            user.changePassword(context, \"wrongPassword\", Password(\"newPw\"))\n        }\n    }\n    \n    \"비활성화된 사용자는 로그인할 수 없다\" {\n        // Given\n        val user = createTestUser().deactivate(createMockContext())\n        \n        // When & Then\n        shouldThrow<IllegalArgumentException> {\n            user.login(createMockContext(), \"password\")\n        }\n    }\n})\n```\n\n#### 1.2 Employee Aggregate Root 테스트\n```kotlin\nclass EmployeeTest : StringSpec({\n    \"근로자 생성 시 직급별로 초기 연차가 다르다\" {\n        // Given\n        val context = createMockContext()\n        \n        // When\n        val regular = Employee.create(context, UserId.generate(), \n            EmployeeName(\"정규직\"), EmployeeType.REGULAR, null)\n        val irregular = Employee.create(context, UserId.generate(), \n            EmployeeName(\"계약직\"), EmployeeType.IRREGULAR, null)\n        val partTime = Employee.create(context, UserId.generate(), \n            EmployeeName(\"알바\"), EmployeeType.PART_TIME, null)\n        \n        // Then\n        regular.remainingLeave.value shouldBe BigDecimal(\"15\")\n        irregular.remainingLeave.value shouldBe BigDecimal(\"11\")\n        partTime.remainingLeave.value shouldBe BigDecimal.ZERO\n    }\n    \n    \"잔여 연차보다 많이 차감할 수 없다\" {\n        // Given\n        val employee = createTestEmployee(remainingLeave = BigDecimal(\"5\"))\n        \n        // When & Then\n        shouldThrow<IllegalArgumentException> {\n            employee.deductLeave(createMockContext(), BigDecimal(\"10\"))\n        }\n    }\n    \n    \"연차 차감 후 정확히 차감된다\" {\n        // Given\n        val employee = createTestEmployee(remainingLeave = BigDecimal(\"15\"))\n        \n        // When\n        val updated = employee.deductLeave(createMockContext(), BigDecimal(\"2.5\"))\n        \n        // Then\n        updated.remainingLeave.value shouldBe BigDecimal(\"12.5\")\n    }\n})\n```\n\n#### 1.3 Value Object 테스트\n```kotlin\nclass EmailTest : StringSpec({\n    \"유효한 이메일 형식을 검증한다\" {\n        Email(\"test@example.com\") shouldNotBe null\n    }\n    \n    \"잘못된 이메일 형식은 예외를 발생시킨다\" {\n        shouldThrow<IllegalArgumentException> {\n            Email(\"invalid-email\")\n        }\n    }\n})\n\nclass RemainingLeaveTest : StringSpec({\n    \"음수 연차는 생성할 수 없다\" {\n        shouldThrow<IllegalArgumentException> {\n            RemainingLeave(BigDecimal(\"-5\"))\n        }\n    }\n    \n    \"연차 차감이 정확히 동작한다\" {\n        val leave = RemainingLeave(BigDecimal(\"10\"))\n        val result = leave.deduct(BigDecimal(\"3\"))\n        result.value shouldBe BigDecimal(\"7\")\n    }\n})\n```\n\n---\n\n### 2. Infrastructure 모듈 통합 테스트\n\n#### 2.1 Repository 구현 테스트\n**파일:** `infrastructure/src/test/kotlin/com/lms/infrastructure/persistence/repository/UserRepositoryImplTest.kt`\n```kotlin\n@SpringBootTest\n@Transactional\nclass UserRepositoryImplTest : StringSpec() {\n    \n    @Autowired\n    private lateinit var userRepository: UserRepository\n    \n    init {\n        \"User를 저장하고 조회할 수 있다\" {\n            // Given\n            val user = createTestUser()\n            \n            // When\n            val saved = userRepository.save(user)\n            val found = userRepository.findById(saved.id)\n            \n            // Then\n            found shouldNotBe null\n            found?.email shouldBe user.email\n        }\n        \n        \"이메일로 User를 조회할 수 있다\" {\n            // Given\n            val email = Email(\"unique@test.com\")\n            val user = createTestUser(email = email)\n            userRepository.save(user)\n            \n            // When\n            val found = userRepository.findByEmail(email)\n            \n            // Then\n            found shouldNotBe null\n            found?.id shouldBe user.id\n        }\n        \n        \"중복 이메일 존재 여부를 확인할 수 있다\" {\n            // Given\n            val email = Email(\"duplicate@test.com\")\n            userRepository.save(createTestUser(email = email))\n            \n            // When & Then\n            userRepository.existsByEmail(email) shouldBe true\n            userRepository.existsByEmail(Email(\"notexist@test.com\")) shouldBe false\n        }\n    }\n}\n```\n\n#### 2.2 Mapper 테스트\n```kotlin\nclass UserMapperTest : StringSpec({\n    \"Domain User를 Entity로 변환할 수 있다\" {\n        // Given\n        val domainUser = createTestUser()\n        \n        // When\n        val entity = UserMapper.toEntity(domainUser)\n        \n        // Then\n        entity.id shouldBe domainUser.id.value\n        entity.email shouldBe domainUser.email.value\n        entity.role shouldBe domainUser.role.name\n    }\n    \n    \"Entity User를 Domain으로 변환할 수 있다\" {\n        // Given\n        val entity = createTestUserEntity()\n        \n        // When\n        val domain = UserMapper.toDomain(entity)\n        \n        // Then\n        domain.id.value shouldBe entity.id\n        domain.email.value shouldBe entity.email\n    }\n    \n    \"Domain ↔ Entity 양방향 변환이 일관성을 유지한다\" {\n        // Given\n        val original = createTestUser()\n        \n        // When\n        val entity = UserMapper.toEntity(original)\n        val converted = UserMapper.toDomain(entity)\n        \n        // Then\n        converted.id shouldBe original.id\n        converted.email shouldBe original.email\n        converted.role shouldBe original.role\n    }\n})\n```\n\n---\n\n### 3. Application 모듈 통합 테스트\n\n#### 3.1 RegisterEmployeeAppService 테스트\n```kotlin\n@SpringBootTest\n@Transactional\nclass RegisterEmployeeAppServiceTest : StringSpec() {\n    \n    @Autowired\n    private lateinit var registerEmployeeAppService: RegisterEmployeeAppService\n    \n    @Autowired\n    private lateinit var userRepository: UserRepository\n    \n    @Autowired\n    private lateinit var employeeRepository: EmployeeRepository\n    \n    init {\n        \"근로자를 등록하면 User와 Employee가 모두 생성된다\" {\n            // Given\n            val context = createMockContext()\n            val command = RegisterEmployeeCommand(\n                email = \"new@employee.com\",\n                password = \"password123\",\n                name = \"홍길동\",\n                role = Role.EMPLOYEE,\n                employeeType = EmployeeType.REGULAR,\n                storeId = null\n            )\n            \n            // When\n            val result = registerEmployeeAppService.execute(context, command)\n            \n            // Then\n            result shouldNotBe null\n            \n            val user = userRepository.findByEmail(Email(command.email))\n            user shouldNotBe null\n            user?.role shouldBe Role.EMPLOYEE\n            \n            val employee = employeeRepository.findByUserId(user!!.id)\n            employee shouldNotBe null\n            employee?.name?.value shouldBe \"홍길동\"\n            employee?.remainingLeave?.value shouldBe BigDecimal(\"15\")\n        }\n        \n        \"중복된 이메일로 등록하면 예외가 발생한다\" {\n            // Given\n            val existingEmail = \"existing@test.com\"\n            userRepository.save(createTestUser(email = Email(existingEmail)))\n            \n            val command = RegisterEmployeeCommand(\n                email = existingEmail,\n                password = \"pw\",\n                name = \"테스트\",\n                role = Role.EMPLOYEE,\n                employeeType = EmployeeType.PART_TIME,\n                storeId = null\n            )\n            \n            // When & Then\n            shouldThrow<IllegalArgumentException> {\n                registerEmployeeAppService.execute(createMockContext(), command)\n            }\n        }\n    }\n}\n```\n\n---\n\n### 4. End-to-End 시나리오 테스트\n\n```kotlin\n@SpringBootTest\n@Transactional\nclass EmployeeManagementE2ETest : StringSpec() {\n    \n    @Autowired\n    private lateinit var registerEmployeeAppService: RegisterEmployeeAppService\n    \n    @Autowired\n    private lateinit var deductLeaveAppService: DeductLeaveAppService\n    \n    @Autowired\n    private lateinit var employeeRepository: EmployeeRepository\n    \n    init {\n        \"근로자 등록 → 휴가 신청 → 연차 차감 전체 플로우\" {\n            // Given: 근로자 등록\n            val context = createMockContext()\n            val registerCommand = RegisterEmployeeCommand(\n                email = \"employee@test.com\",\n                password = \"password\",\n                name = \"김사원\",\n                role = Role.EMPLOYEE,\n                employeeType = EmployeeType.REGULAR,\n                storeId = null\n            )\n            val registered = registerEmployeeAppService.execute(context, registerCommand)\n            \n            // When: 휴가 신청 (연차 차감)\n            val employee = employeeRepository.findById(EmployeeId(registered.id))!!\n            val updated = employee.deductLeave(context, BigDecimal(\"2.5\"))\n            employeeRepository.save(updated)\n            \n            // Then: 연차가 정확히 차감되었는지 확인\n            val result = employeeRepository.findById(EmployeeId(registered.id))\n            result?.remainingLeave?.value shouldBe BigDecimal(\"12.5\")\n        }\n    }\n}\n```\n\n---\n\n### 5. 데이터베이스 마이그레이션 검증\n\n```kotlin\n@SpringBootTest\n@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)\nclass DatabaseMigrationTest : StringSpec() {\n    \n    @Autowired\n    private lateinit var dataSource: DataSource\n    \n    init {\n        \"users 테이블이 정상적으로 생성되었다\" {\n            dataSource.connection.use { conn ->\n                val metadata = conn.metaData\n                val rs = metadata.getTables(null, null, \"users\", null)\n                rs.next() shouldBe true\n            }\n        }\n        \n        \"employees 테이블에 user_id 컬럼이 존재한다\" {\n            dataSource.connection.use { conn ->\n                val metadata = conn.metaData\n                val rs = metadata.getColumns(null, null, \"employees\", \"user_id\")\n                rs.next() shouldBe true\n            }\n        }\n        \n        \"employees 테이블에 email, password, role 컬럼이 제거되었다\" {\n            dataSource.connection.use { conn ->\n                val metadata = conn.metaData\n                \n                val emailRs = metadata.getColumns(null, null, \"employees\", \"email\")\n                emailRs.next() shouldBe false\n                \n                val passwordRs = metadata.getColumns(null, null, \"employees\", \"password\")\n                passwordRs.next() shouldBe false\n                \n                val roleRs = metadata.getColumns(null, null, \"employees\", \"role\")\n                roleRs.next() shouldBe false\n            }\n        }\n    }\n}\n```\n\n---\n\n### 6. 가이드라인 준수 검증\n\n#### 6.1 Domain 순수성 테스트\n```kotlin\nclass DomainPurityTest : StringSpec({\n    \"Domain 모듈은 Spring에 의존하지 않는다\" {\n        val domainClasses = listOf(\n            User::class,\n            Employee::class,\n            Store::class\n        )\n        \n        domainClasses.forEach { clazz ->\n            clazz.annotations.none { \n                it.annotationClass.qualifiedName?.startsWith(\"org.springframework\") == true \n            } shouldBe true\n        }\n    }\n    \n    \"Domain 모듈은 JPA에 의존하지 않는다\" {\n        val domainClasses = listOf(User::class, Employee::class)\n        \n        domainClasses.forEach { clazz ->\n            clazz.annotations.none {\n                it.annotationClass.qualifiedName?.startsWith(\"jakarta.persistence\") == true\n            } shouldBe true\n        }\n    }\n})\n```\n\n---\n\n### 7. 테스트 커버리지 목표\n\n- **Domain 모듈:** 90% 이상 (비즈니스 로직 중심)\n- **Infrastructure 모듈:** 80% 이상 (Mapper, Repository 구현)\n- **Application 모듈:** 85% 이상 (UseCase 시나리오)\n\n### 8. CI/CD 파이프라인 검증\n\n```bash\n# 전체 테스트 실행\n./gradlew clean test\n\n# 모듈별 테스트\n./gradlew :domain:test\n./gradlew :infrastructure:test\n./gradlew :application:test\n\n# 테스트 커버리지 리포트 생성\n./gradlew jacocoTestReport\n```",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-01-16T07:26:17.981Z"
      },
      {
        "id": "12",
        "title": "DDD 아키텍처 리팩토링 - User/Employee 분리 및 순수 도메인 모델 구축",
        "description": "인증용 User 엔티티와 근로자 정보용 Employee를 분리하고, 순수 Kotlin 도메인 모델(Aggregate Root)을 생성하여 DDD 가이드라인에 따라 도메인, 애플리케이션, 인프라 계층을 재구성합니다.",
        "details": "## 1. Domain 모듈 - 순수 도메인 모델 생성\n\n### 1.1 DomainContext 인터페이스 정의\n**위치:** `domain/src/main/kotlin/com/lms/domain/common/DomainContext.kt`\n```kotlin\npackage com.lms.domain.common\n\nimport java.time.Instant\nimport java.util.UUID\n\n/**\n * 모든 도메인 요청의 공통 컨텍스트\n */\ninterface DomainContext {\n    val serviceName: String\n    val userId: String\n    val userName: String\n    val roleId: String\n    val requestId: UUID\n    val requestedAt: Instant\n    val clientIp: String?\n}\n\ndata class DomainContextImpl(\n    override val serviceName: String,\n    override val userId: String,\n    override val userName: String,\n    override val roleId: String,\n    override val requestId: UUID = UUID.randomUUID(),\n    override val requestedAt: Instant = Instant.now(),\n    override val clientIp: String? = null\n) : DomainContext\n```\n\n### 1.2 User Aggregate Root (인증용)\n**위치:** `domain/src/main/kotlin/com/lms/domain/model/user/`\n\n```kotlin\n// UserId.kt (Value Object)\n@JvmInline\nvalue class UserId(val value: String) {\n    init {\n        require(value.isNotBlank()) { \"UserId는 비어있을 수 없습니다\" }\n    }\n}\n\n// Email.kt (Value Object)\n@JvmInline\nvalue class Email(val value: String) {\n    init {\n        require(value.matches(Regex(\"^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}$\"))) {\n            \"올바른 이메일 형식이 아닙니다\"\n        }\n    }\n}\n\n// Password.kt (Value Object)\n@JvmInline\nvalue class EncryptedPassword(val value: String) {\n    init {\n        require(value.isNotBlank()) { \"암호화된 비밀번호는 비어있을 수 없습니다\" }\n    }\n}\n\n// UserRole.kt (Sealed Class)\nsealed class UserRole(val name: String) {\n    data object SuperAdmin : UserRole(\"SUPER_ADMIN\")\n    data object Manager : UserRole(\"MANAGER\")\n    data object Employee : UserRole(\"EMPLOYEE\")\n    \n    companion object {\n        fun from(name: String): UserRole = when (name) {\n            \"SUPER_ADMIN\" -> SuperAdmin\n            \"MANAGER\" -> Manager\n            \"EMPLOYEE\" -> Employee\n            else -> throw IllegalArgumentException(\"알 수 없는 권한: $name\")\n        }\n    }\n}\n\n// User.kt (Aggregate Root)\ndata class User private constructor(\n    val id: UserId,\n    val email: Email,\n    val password: EncryptedPassword,\n    val role: UserRole,\n    val isActive: Boolean,\n    val createdAt: Instant,\n    val updatedAt: Instant\n) {\n    companion object {\n        fun create(\n            context: DomainContext,\n            id: UserId,\n            email: Email,\n            encryptedPassword: EncryptedPassword,\n            role: UserRole\n        ): User {\n            return User(\n                id = id,\n                email = email,\n                password = encryptedPassword,\n                role = role,\n                isActive = true,\n                createdAt = context.requestedAt,\n                updatedAt = context.requestedAt\n            )\n        }\n    }\n    \n    fun deactivate(context: DomainContext): User {\n        require(isActive) { \"이미 비활성화된 사용자입니다\" }\n        return copy(\n            isActive = false,\n            updatedAt = context.requestedAt\n        )\n    }\n    \n    fun changePassword(context: DomainContext, newPassword: EncryptedPassword): User {\n        return copy(\n            password = newPassword,\n            updatedAt = context.requestedAt\n        )\n    }\n}\n```\n\n**UserRepository.kt (인터페이스)**\n```kotlin\ninterface UserRepository {\n    fun save(user: User): User\n    fun findById(id: UserId): User?\n    fun findByEmail(email: Email): User?\n    fun existsByEmail(email: Email): Boolean\n}\n```\n\n### 1.3 Employee Aggregate Root (근로자 정보)\n**위치:** `domain/src/main/kotlin/com/lms/domain/model/employee/`\n\n```kotlin\n// EmployeeId.kt\n@JvmInline\nvalue class EmployeeId(val value: String) {\n    init {\n        require(value.isNotBlank()) { \"EmployeeId는 비어있을 수 없습니다\" }\n    }\n}\n\n// EmployeeName.kt\ndata class EmployeeName(\n    val firstName: String,\n    val lastName: String\n) {\n    init {\n        require(firstName.isNotBlank()) { \"이름은 비어있을 수 없습니다\" }\n        require(lastName.isNotBlank()) { \"성은 비어있을 수 없습니다\" }\n    }\n    \n    val fullName: String\n        get() = \"$lastName$firstName\"\n}\n\n// PhoneNumber.kt\n@JvmInline\nvalue class PhoneNumber(val value: String) {\n    init {\n        require(value.matches(Regex(\"^01[0-9]-?[0-9]{3,4}-?[0-9]{4}$\"))) {\n            \"올바른 전화번호 형식이 아닙니다\"\n        }\n    }\n}\n\n// HourlyWage.kt\n@JvmInline\nvalue class HourlyWage(val value: Int) {\n    init {\n        require(value > 0) { \"시급은 0보다 커야 합니다\" }\n    }\n}\n\n// AnnualLeave.kt\ndata class AnnualLeave(\n    val total: Double,\n    val remaining: Double\n) {\n    init {\n        require(total >= 0) { \"총 연차는 0 이상이어야 합니다\" }\n        require(remaining >= 0) { \"잔여 연차는 0 이상이어야 합니다\" }\n        require(remaining <= total) { \"잔여 연차는 총 연차를 초과할 수 없습니다\" }\n    }\n    \n    fun use(days: Double): AnnualLeave {\n        require(remaining >= days) { \"잔여 연차가 부족합니다\" }\n        return copy(remaining = remaining - days)\n    }\n    \n    fun restore(days: Double): AnnualLeave {\n        val newRemaining = (remaining + days).coerceAtMost(total)\n        return copy(remaining = newRemaining)\n    }\n}\n\n// Employee.kt (Aggregate Root)\ndata class Employee private constructor(\n    val id: EmployeeId,\n    val userId: UserId,  // User Aggregate 참조 (FK)\n    val storeId: String,\n    val name: EmployeeName,\n    val phoneNumber: PhoneNumber,\n    val hourlyWage: HourlyWage,\n    val annualLeave: AnnualLeave,\n    val hireDate: Instant,\n    val isActive: Boolean,\n    val createdAt: Instant,\n    val updatedAt: Instant\n) {\n    companion object {\n        fun create(\n            context: DomainContext,\n            id: EmployeeId,\n            userId: UserId,\n            storeId: String,\n            name: EmployeeName,\n            phoneNumber: PhoneNumber,\n            hourlyWage: HourlyWage,\n            annualLeaveDays: Double,\n            hireDate: Instant\n        ): Employee {\n            return Employee(\n                id = id,\n                userId = userId,\n                storeId = storeId,\n                name = name,\n                phoneNumber = phoneNumber,\n                hourlyWage = hourlyWage,\n                annualLeave = AnnualLeave(annualLeaveDays, annualLeaveDays),\n                hireDate = hireDate,\n                isActive = true,\n                createdAt = context.requestedAt,\n                updatedAt = context.requestedAt\n            )\n        }\n    }\n    \n    fun updateWage(context: DomainContext, newWage: HourlyWage): Employee {\n        return copy(\n            hourlyWage = newWage,\n            updatedAt = context.requestedAt\n        )\n    }\n    \n    fun useAnnualLeave(context: DomainContext, days: Double): Employee {\n        return copy(\n            annualLeave = annualLeave.use(days),\n            updatedAt = context.requestedAt\n        )\n    }\n    \n    fun restoreAnnualLeave(context: DomainContext, days: Double): Employee {\n        return copy(\n            annualLeave = annualLeave.restore(days),\n            updatedAt = context.requestedAt\n        )\n    }\n    \n    fun deactivate(context: DomainContext): Employee {\n        require(isActive) { \"이미 비활성화된 근로자입니다\" }\n        return copy(\n            isActive = false,\n            updatedAt = context.requestedAt\n        )\n    }\n}\n```\n\n**EmployeeRepository.kt (인터페이스)**\n```kotlin\ninterface EmployeeRepository {\n    fun save(employee: Employee): Employee\n    fun findById(id: EmployeeId): Employee?\n    fun findByUserId(userId: UserId): Employee?\n    fun findByStoreId(storeId: String): List<Employee>\n    fun existsByUserId(userId: UserId): Boolean\n}\n```\n\n### 1.4 Store Aggregate Root\n**위치:** `domain/src/main/kotlin/com/lms/domain/model/store/`\n\n```kotlin\n// StoreId.kt\n@JvmInline\nvalue class StoreId(val value: String) {\n    init {\n        require(value.isNotBlank()) { \"StoreId는 비어있을 수 없습니다\" }\n    }\n}\n\n// StoreName.kt\n@JvmInline\nvalue class StoreName(val value: String) {\n    init {\n        require(value.isNotBlank()) { \"매장명은 비어있을 수 없습니다\" }\n    }\n}\n\n// Store.kt (Aggregate Root)\ndata class Store private constructor(\n    val id: StoreId,\n    val name: StoreName,\n    val address: String,\n    val isActive: Boolean,\n    val createdAt: Instant,\n    val updatedAt: Instant\n) {\n    companion object {\n        fun create(\n            context: DomainContext,\n            id: StoreId,\n            name: StoreName,\n            address: String\n        ): Store {\n            return Store(\n                id = id,\n                name = name,\n                address = address,\n                isActive = true,\n                createdAt = context.requestedAt,\n                updatedAt = context.requestedAt\n            )\n        }\n    }\n    \n    fun updateInfo(context: DomainContext, name: StoreName, address: String): Store {\n        return copy(\n            name = name,\n            address = address,\n            updatedAt = context.requestedAt\n        )\n    }\n    \n    fun deactivate(context: DomainContext): Store {\n        require(isActive) { \"이미 비활성화된 매장입니다\" }\n        return copy(\n            isActive = false,\n            updatedAt = context.requestedAt\n        )\n    }\n}\n```\n\n**StoreRepository.kt (인터페이스)**\n```kotlin\ninterface StoreRepository {\n    fun save(store: Store): Store\n    fun findById(id: StoreId): Store?\n    fun findAll(): List<Store>\n    fun existsById(id: StoreId): Boolean\n}\n```\n\n### 1.5 Domain Exception\n**위치:** `domain/src/main/kotlin/com/lms/domain/exception/`\n\n```kotlin\nopen class DomainException(\n    val code: String,\n    message: String,\n    originalError: Throwable? = null\n) : RuntimeException(message, originalError)\n\nenum class ErrorCode(val code: String, val message: String) {\n    // User\n    USER_NOT_FOUND(\"U001\", \"사용자를 찾을 수 없습니다\"),\n    EMAIL_DUPLICATED(\"U002\", \"이미 사용 중인 이메일입니다\"),\n    INVALID_CREDENTIALS(\"U003\", \"이메일 또는 비밀번호가 올바르지 않습니다\"),\n    USER_ALREADY_INACTIVE(\"U004\", \"이미 비활성화된 사용자입니다\"),\n    \n    // Employee\n    EMPLOYEE_NOT_FOUND(\"E001\", \"근로자를 찾을 수 없습니다\"),\n    EMPLOYEE_ALREADY_EXISTS(\"E002\", \"이미 등록된 근로자입니다\"),\n    INSUFFICIENT_ANNUAL_LEAVE(\"E003\", \"잔여 연차가 부족합니다\"),\n    EMPLOYEE_ALREADY_INACTIVE(\"E004\", \"이미 비활성화된 근로자입니다\"),\n    \n    // Store\n    STORE_NOT_FOUND(\"S001\", \"매장을 찾을 수 없습니다\"),\n    STORE_ALREADY_INACTIVE(\"S002\", \"이미 비활성화된 매장입니다\")\n}\n\nclass UserNotFoundException : DomainException(ErrorCode.USER_NOT_FOUND.code, ErrorCode.USER_NOT_FOUND.message)\nclass EmailDuplicatedException : DomainException(ErrorCode.EMAIL_DUPLICATED.code, ErrorCode.EMAIL_DUPLICATED.message)\nclass EmployeeNotFoundException : DomainException(ErrorCode.EMPLOYEE_NOT_FOUND.code, ErrorCode.EMPLOYEE_NOT_FOUND.message)\nclass InsufficientAnnualLeaveException : DomainException(ErrorCode.INSUFFICIENT_ANNUAL_LEAVE.code, ErrorCode.INSUFFICIENT_ANNUAL_LEAVE.message)\nclass StoreNotFoundException : DomainException(ErrorCode.STORE_NOT_FOUND.code, ErrorCode.STORE_NOT_FOUND.message)\n```\n\n### 1.6 Domain Event\n**위치:** `domain/src/main/kotlin/com/lms/domain/event/`\n\n```kotlin\ninterface DomainEvent<T> {\n    val eventId: UUID\n    val occurredOn: Long\n    val context: DomainContext\n    val payload: T\n}\n\nabstract class DomainEventBase<T> : DomainEvent<T> {\n    override val eventId: UUID = UUID.randomUUID()\n    override val occurredOn: Long = Date().time\n}\n\n// User Events\ndata class UserCreatedEvent(\n    override val context: DomainContext,\n    override val payload: User\n) : DomainEventBase<User>()\n\ndata class UserDeactivatedEvent(\n    override val context: DomainContext,\n    override val payload: UserId\n) : DomainEventBase<UserId>()\n\n// Employee Events\ndata class EmployeeCreatedEvent(\n    override val context: DomainContext,\n    override val payload: Employee\n) : DomainEventBase<Employee>()\n\ndata class EmployeeWageUpdatedEvent(\n    override val context: DomainContext,\n    override val payload: Pair<EmployeeId, HourlyWage>\n) : DomainEventBase<Pair<EmployeeId, HourlyWage>>()\n\ndata class AnnualLeaveUsedEvent(\n    override val context: DomainContext,\n    override val payload: Pair<EmployeeId, Double>\n) : DomainEventBase<Pair<EmployeeId, Double>>()\n```\n\n## 2. Infrastructure 모듈 - JPA 엔티티 및 Repository 구현\n\n### 2.1 JPA 엔티티 (도메인 모델과 분리)\n**위치:** `infrastructure/src/main/kotlin/com/lms/infrastructure/persistence/entity/`\n\n```kotlin\n// UserJpaEntity.kt\n@Entity\n@Table(name = \"users\")\nclass UserJpaEntity(\n    @Id\n    @Column(name = \"user_id\")\n    val id: String,\n    \n    @Column(unique = true, nullable = false)\n    val email: String,\n    \n    @Column(nullable = false)\n    val password: String,\n    \n    @Enumerated(EnumType.STRING)\n    @Column(nullable = false)\n    val role: RoleType,\n    \n    @Column(nullable = false)\n    val isActive: Boolean = true,\n    \n    @Column(nullable = false)\n    val createdAt: Instant,\n    \n    @Column(nullable = false)\n    val updatedAt: Instant\n) {\n    enum class RoleType {\n        SUPER_ADMIN, MANAGER, EMPLOYEE\n    }\n}\n\n// EmployeeJpaEntity.kt\n@Entity\n@Table(name = \"employees\")\nclass EmployeeJpaEntity(\n    @Id\n    @Column(name = \"employee_id\")\n    val id: String,\n    \n    @Column(name = \"user_id\", nullable = false, unique = true)\n    val userId: String,\n    \n    @Column(name = \"store_id\", nullable = false)\n    val storeId: String,\n    \n    @Column(nullable = false)\n    val firstName: String,\n    \n    @Column(nullable = false)\n    val lastName: String,\n    \n    @Column(nullable = false)\n    val phoneNumber: String,\n    \n    @Column(nullable = false)\n    val hourlyWage: Int,\n    \n    @Column(nullable = false)\n    val totalAnnualLeave: Double,\n    \n    @Column(nullable = false)\n    val remainingAnnualLeave: Double,\n    \n    @Column(nullable = false)\n    val hireDate: Instant,\n    \n    @Column(nullable = false)\n    val isActive: Boolean = true,\n    \n    @Column(nullable = false)\n    val createdAt: Instant,\n    \n    @Column(nullable = false)\n    val updatedAt: Instant\n)\n\n// StoreJpaEntity.kt\n@Entity\n@Table(name = \"stores\")\nclass StoreJpaEntity(\n    @Id\n    @Column(name = \"store_id\")\n    val id: String,\n    \n    @Column(nullable = false)\n    val name: String,\n    \n    @Column(nullable = false)\n    val address: String,\n    \n    @Column(nullable = false)\n    val isActive: Boolean = true,\n    \n    @Column(nullable = false)\n    val createdAt: Instant,\n    \n    @Column(nullable = false)\n    val updatedAt: Instant\n)\n```\n\n### 2.2 Mapper (도메인 ↔ JPA 변환)\n**위치:** `infrastructure/src/main/kotlin/com/lms/infrastructure/persistence/mapper/`\n\n```kotlin\n// UserMapper.kt\nobject UserMapper {\n    fun toDomain(entity: UserJpaEntity): User {\n        return User(\n            id = UserId(entity.id),\n            email = Email(entity.email),\n            password = EncryptedPassword(entity.password),\n            role = when (entity.role) {\n                UserJpaEntity.RoleType.SUPER_ADMIN -> UserRole.SuperAdmin\n                UserJpaEntity.RoleType.MANAGER -> UserRole.Manager\n                UserJpaEntity.RoleType.EMPLOYEE -> UserRole.Employee\n            },\n            isActive = entity.isActive,\n            createdAt = entity.createdAt,\n            updatedAt = entity.updatedAt\n        )\n    }\n    \n    fun toEntity(domain: User): UserJpaEntity {\n        return UserJpaEntity(\n            id = domain.id.value,\n            email = domain.email.value,\n            password = domain.password.value,\n            role = when (domain.role) {\n                UserRole.SuperAdmin -> UserJpaEntity.RoleType.SUPER_ADMIN\n                UserRole.Manager -> UserJpaEntity.RoleType.MANAGER\n                UserRole.Employee -> UserJpaEntity.RoleType.EMPLOYEE\n            },\n            isActive = domain.isActive,\n            createdAt = domain.createdAt,\n            updatedAt = domain.updatedAt\n        )\n    }\n}\n\n// EmployeeMapper.kt\nobject EmployeeMapper {\n    fun toDomain(entity: EmployeeJpaEntity): Employee {\n        return Employee(\n            id = EmployeeId(entity.id),\n            userId = UserId(entity.userId),\n            storeId = entity.storeId,\n            name = EmployeeName(entity.firstName, entity.lastName),\n            phoneNumber = PhoneNumber(entity.phoneNumber),\n            hourlyWage = HourlyWage(entity.hourlyWage),\n            annualLeave = AnnualLeave(entity.totalAnnualLeave, entity.remainingAnnualLeave),\n            hireDate = entity.hireDate,\n            isActive = entity.isActive,\n            createdAt = entity.createdAt,\n            updatedAt = entity.updatedAt\n        )\n    }\n    \n    fun toEntity(domain: Employee): EmployeeJpaEntity {\n        return EmployeeJpaEntity(\n            id = domain.id.value,\n            userId = domain.userId.value,\n            storeId = domain.storeId,\n            firstName = domain.name.firstName,\n            lastName = domain.name.lastName,\n            phoneNumber = domain.phoneNumber.value,\n            hourlyWage = domain.hourlyWage.value,\n            totalAnnualLeave = domain.annualLeave.total,\n            remainingAnnualLeave = domain.annualLeave.remaining,\n            hireDate = domain.hireDate,\n            isActive = domain.isActive,\n            createdAt = domain.createdAt,\n            updatedAt = domain.updatedAt\n        )\n    }\n}\n\n// StoreMapper.kt\nobject StoreMapper {\n    fun toDomain(entity: StoreJpaEntity): Store {\n        return Store(\n            id = StoreId(entity.id),\n            name = StoreName(entity.name),\n            address = entity.address,\n            isActive = entity.isActive,\n            createdAt = entity.createdAt,\n            updatedAt = entity.updatedAt\n        )\n    }\n    \n    fun toEntity(domain: Store): StoreJpaEntity {\n        return StoreJpaEntity(\n            id = domain.id.value,\n            name = domain.name.value,\n            address = domain.address,\n            isActive = domain.isActive,\n            createdAt = domain.createdAt,\n            updatedAt = domain.updatedAt\n        )\n    }\n}\n```\n\n### 2.3 JPA Repository 인터페이스\n**위치:** `infrastructure/src/main/kotlin/com/lms/infrastructure/persistence/jpa/`\n\n```kotlin\ninterface UserJpaRepository : JpaRepository<UserJpaEntity, String> {\n    fun findByEmail(email: String): UserJpaEntity?\n    fun existsByEmail(email: String): Boolean\n}\n\ninterface EmployeeJpaRepository : JpaRepository<EmployeeJpaEntity, String> {\n    fun findByUserId(userId: String): EmployeeJpaEntity?\n    fun findByStoreId(storeId: String): List<EmployeeJpaEntity>\n    fun existsByUserId(userId: String): Boolean\n}\n\ninterface StoreJpaRepository : JpaRepository<StoreJpaEntity, String>\n```\n\n### 2.4 도메인 Repository 구현체\n**위치:** `infrastructure/src/main/kotlin/com/lms/infrastructure/persistence/repository/`\n\n```kotlin\n// UserRepositoryImpl.kt\n@Repository\nclass UserRepositoryImpl(\n    private val jpaRepository: UserJpaRepository\n) : UserRepository {\n    override fun save(user: User): User {\n        val entity = UserMapper.toEntity(user)\n        val savedEntity = jpaRepository.save(entity)\n        return UserMapper.toDomain(savedEntity)\n    }\n    \n    override fun findById(id: UserId): User? {\n        return jpaRepository.findById(id.value)\n            .map { UserMapper.toDomain(it) }\n            .orElse(null)\n    }\n    \n    override fun findByEmail(email: Email): User? {\n        return jpaRepository.findByEmail(email.value)\n            ?.let { UserMapper.toDomain(it) }\n    }\n    \n    override fun existsByEmail(email: Email): Boolean {\n        return jpaRepository.existsByEmail(email.value)\n    }\n}\n\n// EmployeeRepositoryImpl.kt\n@Repository\nclass EmployeeRepositoryImpl(\n    private val jpaRepository: EmployeeJpaRepository\n) : EmployeeRepository {\n    override fun save(employee: Employee): Employee {\n        val entity = EmployeeMapper.toEntity(employee)\n        val savedEntity = jpaRepository.save(entity)\n        return EmployeeMapper.toDomain(savedEntity)\n    }\n    \n    override fun findById(id: EmployeeId): Employee? {\n        return jpaRepository.findById(id.value)\n            .map { EmployeeMapper.toDomain(it) }\n            .orElse(null)\n    }\n    \n    override fun findByUserId(userId: UserId): Employee? {\n        return jpaRepository.findByUserId(userId.value)\n            ?.let { EmployeeMapper.toDomain(it) }\n    }\n    \n    override fun findByStoreId(storeId: String): List<Employee> {\n        return jpaRepository.findByStoreId(storeId)\n            .map { EmployeeMapper.toDomain(it) }\n    }\n    \n    override fun existsByUserId(userId: UserId): Boolean {\n        return jpaRepository.existsByUserId(userId.value)\n    }\n}\n\n// StoreRepositoryImpl.kt\n@Repository\nclass StoreRepositoryImpl(\n    private val jpaRepository: StoreJpaRepository\n) : StoreRepository {\n    override fun save(store: Store): Store {\n        val entity = StoreMapper.toEntity(store)\n        val savedEntity = jpaRepository.save(entity)\n        return StoreMapper.toDomain(savedEntity)\n    }\n    \n    override fun findById(id: StoreId): Store? {\n        return jpaRepository.findById(id.value)\n            .map { StoreMapper.toDomain(it) }\n            .orElse(null)\n    }\n    \n    override fun findAll(): List<Store> {\n        return jpaRepository.findAll()\n            .map { StoreMapper.toDomain(it) }\n    }\n    \n    override fun existsById(id: StoreId): Boolean {\n        return jpaRepository.existsById(id.value)\n    }\n}\n```\n\n## 3. Application 모듈 - UseCase 리팩토링\n\n### 3.1 기존 Service를 AppService로 변환\n**예시: RegisterEmployeeAppService.kt**\n```kotlin\npackage com.lms.application.employee\n\nimport com.lms.domain.common.DomainContext\nimport com.lms.domain.model.employee.*\nimport com.lms.domain.model.user.*\nimport org.springframework.stereotype.Service\nimport org.springframework.transaction.annotation.Transactional\nimport java.time.Instant\nimport java.util.UUID\n\ndata class RegisterEmployeeCommand(\n    val email: String,\n    val password: String,\n    val storeId: String,\n    val firstName: String,\n    val lastName: String,\n    val phoneNumber: String,\n    val hourlyWage: Int,\n    val annualLeaveDays: Double,\n    val hireDate: Instant\n)\n\ndata class EmployeeResult(\n    val employeeId: String,\n    val userId: String,\n    val email: String,\n    val fullName: String\n)\n\n@Service\n@Transactional\nclass RegisterEmployeeAppService(\n    private val userRepository: UserRepository,\n    private val employeeRepository: EmployeeRepository,\n    private val passwordEncoder: PasswordEncoder  // Infrastructure 구현체\n) {\n    fun execute(context: DomainContext, command: RegisterEmployeeCommand): EmployeeResult {\n        val email = Email(command.email)\n        \n        // 중복 체크\n        if (userRepository.existsByEmail(email)) {\n            throw EmailDuplicatedException()\n        }\n        \n        // User 생성\n        val userId = UserId(UUID.randomUUID().toString())\n        val encryptedPassword = EncryptedPassword(passwordEncoder.encode(command.password))\n        val user = User.create(\n            context = context,\n            id = userId,\n            email = email,\n            encryptedPassword = encryptedPassword,\n            role = UserRole.Employee\n        )\n        userRepository.save(user)\n        \n        // Employee 생성\n        val employee = Employee.create(\n            context = context,\n            id = EmployeeId(UUID.randomUUID().toString()),\n            userId = userId,\n            storeId = command.storeId,\n            name = EmployeeName(command.firstName, command.lastName),\n            phoneNumber = PhoneNumber(command.phoneNumber),\n            hourlyWage = HourlyWage(command.hourlyWage),\n            annualLeaveDays = command.annualLeaveDays,\n            hireDate = command.hireDate\n        )\n        val savedEmployee = employeeRepository.save(employee)\n        \n        return EmployeeResult(\n            employeeId = savedEmployee.id.value,\n            userId = user.id.value,\n            email = user.email.value,\n            fullName = savedEmployee.name.fullName\n        )\n    }\n}\n```\n\n## 4. Interfaces 모듈 - Controller 수정\n\n### 4.1 DomainContext 추출 인터셉터\n**위치:** `interfaces/src/main/kotlin/com/lms/interfaces/web/interceptor/`\n\n```kotlin\n@Component\nclass DomainContextInterceptor : HandlerInterceptor {\n    companion object {\n        const val DOMAIN_CONTEXT_ATTRIBUTE = \"domainContext\"\n    }\n    \n    override fun preHandle(\n        request: HttpServletRequest,\n        response: HttpServletResponse,\n        handler: Any\n    ): Boolean {\n        val authentication = SecurityContextHolder.getContext().authentication\n        val userDetails = authentication?.principal as? UserDetails\n        \n        val context = DomainContextImpl(\n            serviceName = request.servletPath.split(\"/\").getOrNull(2) ?: \"unknown\",\n            userId = userDetails?.username ?: \"anonymous\",\n            userName = userDetails?.username ?: \"anonymous\",\n            roleId = authentication?.authorities?.firstOrNull()?.authority ?: \"GUEST\",\n            requestId = UUID.randomUUID(),\n            requestedAt = Instant.now(),\n            clientIp = request.remoteAddr\n        )\n        \n        request.setAttribute(DOMAIN_CONTEXT_ATTRIBUTE, context)\n        return true\n    }\n}\n```\n\n### 4.2 Controller 수정\n```kotlin\n@RestController\n@RequestMapping(\"/api/employees\")\nclass EmployeeController(\n    private val registerEmployeeAppService: RegisterEmployeeAppService\n) {\n    @PostMapping\n    fun registerEmployee(\n        @RequestAttribute(DomainContextInterceptor.DOMAIN_CONTEXT_ATTRIBUTE) context: DomainContext,\n        @RequestBody request: RegisterEmployeeRequest\n    ): ResponseEntity<EmployeeResponse> {\n        val command = request.toCommand()\n        val result = registerEmployeeAppService.execute(context, command)\n        return ResponseEntity.ok(EmployeeResponse.from(result))\n    }\n}\n```\n\n## 5. build.gradle.kts 의존성 설정\n\n```kotlin\n// domain/build.gradle.kts\nplugins {\n    alias(libs.plugins.kotlin.jvm)\n}\n\ndependencies {\n    implementation(libs.kotlin.stdlib)\n    // 외부 의존성 없음 - 순수 Kotlin\n    \n    testImplementation(libs.kotest.runner.junit5)\n    testImplementation(libs.kotest.assertions.core)\n}\n\n// infrastructure/build.gradle.kts\nplugins {\n    alias(libs.plugins.kotlin.jvm)\n    alias(libs.plugins.kotlin.spring)\n    alias(libs.plugins.kotlin.jpa)\n}\n\ndependencies {\n    implementation(project(\":domain\"))\n    implementation(libs.spring.boot.starter.data.jpa)\n    implementation(libs.mysql.connector)\n}\n\n// application/build.gradle.kts\nplugins {\n    alias(libs.plugins.kotlin.jvm)\n    alias(libs.plugins.kotlin.spring)\n}\n\ndependencies {\n    implementation(project(\":domain\"))\n    // infrastructure는 의존하지 않음!\n    implementation(libs.spring.boot.starter)\n    implementation(libs.spring.tx)\n}\n```",
        "testStrategy": "## 테스트 전략\n\n### 1. Domain 모듈 단위 테스트 (Kotest)\n\n#### 1.1 User Aggregate Root 테스트\n**파일:** `domain/src/test/kotlin/com/lms/domain/model/user/UserTest.kt`\n```kotlin\nclass UserTest : StringSpec({\n    \"새로운 User를 생성할 수 있다\" {\n        // Given\n        val context = createMockContext()\n        val email = Email(\"test@example.com\")\n        val password = EncryptedPassword(\"encrypted123\")\n        \n        // When\n        val user = User.create(\n            context = context,\n            id = UserId(\"user-1\"),\n            email = email,\n            encryptedPassword = password,\n            role = UserRole.Employee\n        )\n        \n        // Then\n        user.id.value shouldBe \"user-1\"\n        user.email.value shouldBe \"test@example.com\"\n        user.role shouldBe UserRole.Employee\n        user.isActive shouldBe true\n    }\n    \n    \"User를 비활성화할 수 있다\" {\n        // Given\n        val context = createMockContext()\n        val user = createUser(isActive = true)\n        \n        // When\n        val deactivated = user.deactivate(context)\n        \n        // Then\n        deactivated.isActive shouldBe false\n    }\n    \n    \"이미 비활성화된 User는 다시 비활성화할 수 없다\" {\n        // Given\n        val context = createMockContext()\n        val user = createUser(isActive = false)\n        \n        // When & Then\n        shouldThrow<IllegalArgumentException> {\n            user.deactivate(context)\n        }\n    }\n    \n    \"비밀번호를 변경할 수 있다\" {\n        // Given\n        val context = createMockContext()\n        val user = createUser()\n        val newPassword = EncryptedPassword(\"newEncrypted456\")\n        \n        // When\n        val updated = user.changePassword(context, newPassword)\n        \n        // Then\n        updated.password shouldBe newPassword\n    }\n})\n```\n\n#### 1.2 Employee Aggregate Root 테스트\n```kotlin\nclass EmployeeTest : StringSpec({\n    \"새로운 Employee를 생성할 수 있다\" {\n        // Given\n        val context = createMockContext()\n        \n        // When\n        val employee = Employee.create(\n            context = context,\n            id = EmployeeId(\"emp-1\"),\n            userId = UserId(\"user-1\"),\n            storeId = \"store-1\",\n            name = EmployeeName(\"길동\", \"홍\"),\n            phoneNumber = PhoneNumber(\"010-1234-5678\"),\n            hourlyWage = HourlyWage(10000),\n            annualLeaveDays = 15.0,\n            hireDate = Instant.now()\n        )\n        \n        // Then\n        employee.name.fullName shouldBe \"홍길동\"\n        employee.annualLeave.total shouldBe 15.0\n        employee.annualLeave.remaining shouldBe 15.0\n    }\n    \n    \"연차를 사용할 수 있다\" {\n        // Given\n        val context = createMockContext()\n        val employee = createEmployee(annualLeave = AnnualLeave(15.0, 15.0))\n        \n        // When\n        val updated = employee.useAnnualLeave(context, 1.0)\n        \n        // Then\n        updated.annualLeave.remaining shouldBe 14.0\n    }\n    \n    \"잔여 연차가 부족하면 사용할 수 없다\" {\n        // Given\n        val context = createMockContext()\n        val employee = createEmployee(annualLeave = AnnualLeave(15.0, 0.5))\n        \n        // When & Then\n        shouldThrow<IllegalArgumentException> {\n            employee.useAnnualLeave(context, 1.0)\n        }\n    }\n    \n    \"시급을 변경할 수 있다\" {\n        // Given\n        val context = createMockContext()\n        val employee = createEmployee(hourlyWage = HourlyWage(10000))\n        \n        // When\n        val updated = employee.updateWage(context, HourlyWage(12000))\n        \n        // Then\n        updated.hourlyWage.value shouldBe 12000\n    }\n})\n```\n\n#### 1.3 Value Object 검증 테스트\n```kotlin\nclass EmailTest : StringSpec({\n    \"올바른 이메일 형식은 생성할 수 있다\" {\n        Email(\"test@example.com\").value shouldBe \"test@example.com\"\n    }\n    \n    \"잘못된 이메일 형식은 예외를 발생시킨다\" {\n        shouldThrow<IllegalArgumentException> {\n            Email(\"invalid-email\")\n        }\n    }\n})\n\nclass PhoneNumberTest : StringSpec({\n    \"올바른 전화번호 형식은 생성할 수 있다\" {\n        PhoneNumber(\"010-1234-5678\").value shouldBe \"010-1234-5678\"\n        PhoneNumber(\"01012345678\").value shouldBe \"01012345678\"\n    }\n    \n    \"잘못된 전화번호 형식은 예외를 발생시킨다\" {\n        shouldThrow<IllegalArgumentException> {\n            PhoneNumber(\"123-456\")\n        }\n    }\n})\n\nclass HourlyWageTest : StringSpec({\n    \"시급은 0보다 커야 한다\" {\n        shouldThrow<IllegalArgumentException> {\n            HourlyWage(0)\n        }\n        shouldThrow<IllegalArgumentException> {\n            HourlyWage(-1000)\n        }\n    }\n})\n```\n\n### 2. Infrastructure 모듈 통합 테스트\n\n#### 2.1 Repository 구현체 테스트\n**파일:** `infrastructure/src/test/kotlin/com/lms/infrastructure/persistence/UserRepositoryImplTest.kt`\n```kotlin\n@DataJpaTest\n@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)\n@Testcontainers\nclass UserRepositoryImplTest : StringSpec() {\n    @Container\n    val mysql = MySQLContainer<Nothing>(\"mysql:8.0\")\n    \n    init {\n        \"User를 저장하고 조회할 수 있다\" {\n            // Given\n            val context = createMockContext()\n            val user = User.create(\n                context = context,\n                id = UserId(\"user-1\"),\n                email = Email(\"test@example.com\"),\n                encryptedPassword = EncryptedPassword(\"encrypted\"),\n                role = UserRole.Employee\n            )\n            \n            // When\n            val saved = userRepository.save(user)\n            val found = userRepository.findById(UserId(\"user-1\"))\n            \n            // Then\n            found shouldNotBe null\n            found?.email?.value shouldBe \"test@example.com\"\n        }\n        \n        \"이메일로 User를 조회할 수 있다\" {\n            // Given\n            val user = createAndSaveUser(email = \"unique@example.com\")\n            \n            // When\n            val found = userRepository.findByEmail(Email(\"unique@example.com\"))\n            \n            // Then\n            found shouldNotBe null\n            found?.id shouldBe user.id\n        }\n        \n        \"이메일 중복을 확인할 수 있다\" {\n            // Given\n            createAndSaveUser(email = \"duplicate@example.com\")\n            \n            // When\n            val exists = userRepository.existsByEmail(Email(\"duplicate@example.com\"))\n            val notExists = userRepository.existsByEmail(Email(\"unique@example.com\"))\n            \n            // Then\n            exists shouldBe true\n            notExists shouldBe false\n        }\n    }\n}\n```\n\n#### 2.2 Mapper 테스트\n```kotlin\nclass UserMapperTest : StringSpec({\n    \"도메인 User를 JPA Entity로 변환할 수 있다\" {\n        // Given\n        val user = createUser()\n        \n        // When\n        val entity = UserMapper.toEntity(user)\n        \n        // Then\n        entity.id shouldBe user.id.value\n        entity.email shouldBe user.email.value\n    }\n    \n    \"JPA Entity를 도메인 User로 변환할 수 있다\" {\n        // Given\n        val entity = createUserEntity()\n        \n        // When\n        val domain = UserMapper.toDomain(entity)\n        \n        // Then\n        domain.id.value shouldBe entity.id\n        domain.email.value shouldBe entity.email\n    }\n    \n    \"도메인 → Entity → 도메인 변환 시 데이터가 보존된다\" {\n        // Given\n        val original = createUser()\n        \n        // When\n        val entity = UserMapper.toEntity(original)\n        val restored = UserMapper.toDomain(entity)\n        \n        // Then\n        restored shouldBe original\n    }\n})\n```\n\n### 3. Application 모듈 서비스 테스트\n\n#### 3.1 AppService 단위 테스트 (Mock 사용)\n```kotlin\nclass RegisterEmployeeAppServiceTest : StringSpec({\n    val userRepository = mockk<UserRepository>()\n    val employeeRepository = mockk<EmployeeRepository>()\n    val passwordEncoder = mockk<PasswordEncoder>()\n    val service = RegisterEmployeeAppService(userRepository, employeeRepository, passwordEncoder)\n    \n    beforeEach {\n        clearAllMocks()\n    }\n    \n    \"새로운 근로자를 등록할 수 있다\" {\n        // Given\n        val context = createMockContext()\n        val command = RegisterEmployeeCommand(\n            email = \"new@example.com\",\n            password = \"password123\",\n            storeId = \"store-1\",\n            firstName = \"길동\",\n            lastName = \"홍\",\n            phoneNumber = \"010-1234-5678\",\n            hourlyWage = 10000,\n            annualLeaveDays = 15.0,\n            hireDate = Instant.now()\n        )\n        \n        every { userRepository.existsByEmail(any()) } returns false\n        every { passwordEncoder.encode(any()) } returns \"encrypted123\"\n        every { userRepository.save(any()) } answers { firstArg() }\n        every { employeeRepository.save(any()) } answers { firstArg() }\n        \n        // When\n        val result = service.execute(context, command)\n        \n        // Then\n        result.email shouldBe \"new@example.com\"\n        result.fullName shouldBe \"홍길동\"\n        verify(exactly = 1) { userRepository.save(any()) }\n        verify(exactly = 1) { employeeRepository.save(any()) }\n    }\n    \n    \"이메일이 중복되면 예외가 발생한다\" {\n        // Given\n        val context = createMockContext()\n        val command = createRegisterCommand(email = \"duplicate@example.com\")\n        \n        every { userRepository.existsByEmail(any()) } returns true\n        \n        // When & Then\n        shouldThrow<EmailDuplicatedException> {\n            service.execute(context, command)\n        }\n        verify(exactly = 0) { userRepository.save(any()) }\n    }\n})\n```\n\n### 4. Interfaces 모듈 API 테스트\n\n#### 4.1 Controller 통합 테스트\n```kotlin\n@WebMvcTest(EmployeeController::class)\nclass EmployeeControllerTest : StringSpec() {\n    @Autowired\n    lateinit var mockMvc: MockMvc\n    \n    @MockBean\n    lateinit var registerEmployeeAppService: RegisterEmployeeAppService\n    \n    init {\n        \"POST /api/employees - 근로자를 등록할 수 있다\" {\n            // Given\n            val request = RegisterEmployeeRequest(\n                email = \"test@example.com\",\n                password = \"password123\",\n                storeId = \"store-1\",\n                firstName = \"길동\",\n                lastName = \"홍\",\n                phoneNumber = \"010-1234-5678\",\n                hourlyWage = 10000,\n                annualLeaveDays = 15.0,\n                hireDate = Instant.now()\n            )\n            \n            every { registerEmployeeAppService.execute(any(), any()) } returns EmployeeResult(\n                employeeId = \"emp-1\",\n                userId = \"user-1\",\n                email = \"test@example.com\",\n                fullName = \"홍길동\"\n            )\n            \n            // When & Then\n            mockMvc.perform(\n                post(\"/api/employees\")\n                    .contentType(MediaType.APPLICATION_JSON)\n                    .content(objectMapper.writeValueAsString(request))\n            )\n                .andExpect(status().isOk)\n                .andExpect(jsonPath(\"$.email\").value(\"test@example.com\"))\n                .andExpect(jsonPath(\"$.fullName\").value(\"홍길동\"))\n        }\n    }\n}\n```\n\n### 5. 엔드투엔드 시나리오 테스트\n\n```kotlin\n@SpringBootTest\n@AutoConfigureMockMvc\n@Testcontainers\nclass EmployeeRegistrationE2ETest : StringSpec() {\n    @Container\n    val mysql = MySQLContainer<Nothing>(\"mysql:8.0\")\n    \n    @Autowired\n    lateinit var mockMvc: MockMvc\n    \n    init {\n        \"근로자 등록 전체 플로우 테스트\" {\n            // 1. 근로자 등록 요청\n            val registerResponse = mockMvc.perform(\n                post(\"/api/employees\")\n                    .contentType(MediaType.APPLICATION_JSON)\n                    .content(createRegisterRequest())\n            )\n                .andExpect(status().isOk)\n                .andReturn()\n            \n            val employeeId = extractEmployeeId(registerResponse)\n            \n            // 2. 등록된 근로자 조회\n            mockMvc.perform(get(\"/api/employees/$employeeId\"))\n                .andExpect(status().isOk)\n                .andExpect(jsonPath(\"$.id\").value(employeeId))\n            \n            // 3. User 로그인 확인\n            mockMvc.perform(\n                post(\"/api/auth/login\")\n                    .contentType(MediaType.APPLICATION_JSON)\n                    .content(\"\"\"{ \"email\": \"test@example.com\", \"password\": \"password123\" }\"\"\")\n            )\n                .andExpect(status().isOk)\n                .andExpect(jsonPath(\"$.token\").exists())\n        }\n    }\n}\n```\n\n### 6. 테스트 커버리지 목표\n\n- **Domain 모듈**: 100% (순수 비즈니스 로직)\n- **Application 모듈**: 90% 이상\n- **Infrastructure 모듈**: 80% 이상 (Repository 구현체 중심)\n- **Interfaces 모듈**: 70% 이상 (Controller 중심)\n\n### 7. 테스트 실행 명령어\n\n```bash\n# 전체 테스트 실행\n./gradlew test\n\n# 모듈별 테스트\n./gradlew :domain:test\n./gradlew :application:test\n./gradlew :infrastructure:test\n./gradlew :interfaces:test\n\n# 커버리지 리포트 생성\n./gradlew jacocoTestReport\n```",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "medium",
        "updatedAt": "2026-01-17T05:09:01.018Z",
        "subtasks": [
          {
            "id": 1,
            "title": "도메인 모듈 구조 설정 및 DomainContext 구현",
            "description": "도메인 모듈의 기본 구조를 설정하고 DomainContext 인터페이스 및 구현체를 작성합니다.",
            "dependencies": [],
            "details": "1. 도메인 모듈 디렉토리 구조 생성 (model, common, exception, event 등)\n2. DomainContext 인터페이스 정의 및 DomainContextImpl 구현\n3. 도메인 모듈의 build.gradle.kts 설정 (순수 Kotlin 의존성만 포함)\n4. 도메인 예외 클래스 기본 구조 작성 (DomainException, ErrorCode 등)",
            "status": "pending",
            "testStrategy": "1. DomainContext 생성 및 속성 접근 테스트\n2. DomainContextImpl이 인터페이스를 올바르게 구현하는지 검증\n3. 도메인 모듈이 외부 의존성 없이 순수 Kotlin으로만 구성되었는지 확인",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "User와 Employee 도메인 모델 분리 및 구현",
            "description": "인증용 User와 근로자 정보용 Employee 도메인 모델을 분리하여 구현합니다.",
            "dependencies": [
              1
            ],
            "details": "1. User 도메인 모델 구현 (UserId, Email, EncryptedPassword, UserRole 등 Value Object 포함)\n2. Employee 도메인 모델 구현 (EmployeeId, EmployeeName, PhoneNumber, HourlyWage, AnnualLeave 등 Value Object 포함)\n3. Store 도메인 모델 구현 (StoreId, StoreName 등 Value Object 포함)\n4. 각 도메인 모델의 Repository 인터페이스 정의\n5. 도메인 이벤트 클래스 구현 (UserCreatedEvent, EmployeeCreatedEvent 등)",
            "status": "pending",
            "testStrategy": "1. 각 Value Object의 유효성 검증 테스트\n2. User, Employee, Store 도메인 모델 생성 및 메서드 테스트\n3. 도메인 모델 불변성 검증\n4. 비즈니스 규칙 준수 여부 테스트 (예: 연차 사용 시 잔여 연차 검증)",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "인프라스트럭처 모듈 구현 - JPA 엔티티 및 Repository",
            "description": "도메인 모델과 분리된 JPA 엔티티 및 Repository 구현체를 작성합니다.",
            "dependencies": [
              2
            ],
            "details": "1. UserJpaEntity, EmployeeJpaEntity, StoreJpaEntity 클래스 구현\n2. JPA Repository 인터페이스 정의 (UserJpaRepository, EmployeeJpaRepository, StoreJpaRepository)\n3. 도메인 모델과 JPA 엔티티 간 매핑을 위한 Mapper 클래스 구현 (UserMapper, EmployeeMapper, StoreMapper)\n4. 도메인 Repository 인터페이스 구현체 작성 (UserRepositoryImpl, EmployeeRepositoryImpl, StoreRepositoryImpl)\n5. 인프라스트럭처 모듈의 build.gradle.kts 설정 (JPA, MySQL 등 의존성 포함)",
            "status": "pending",
            "testStrategy": "1. JPA 엔티티 매핑 테스트 (컬럼명, 제약조건 등)\n2. Mapper 클래스의 도메인 모델 ↔ JPA 엔티티 변환 테스트\n3. Repository 구현체의 CRUD 기능 테스트\n4. 트랜잭션 처리 테스트",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "애플리케이션 모듈 구현 - UseCase 및 서비스",
            "description": "도메인 모델을 활용하는 애플리케이션 서비스 및 UseCase를 구현합니다.",
            "dependencies": [
              2,
              3
            ],
            "details": "1. 애플리케이션 모듈 디렉토리 구조 생성 (user, employee, store 등)\n2. Command/Result 데이터 클래스 정의\n3. RegisterUserAppService, RegisterEmployeeAppService 등 애플리케이션 서비스 구현\n4. 트랜잭션 경계 설정\n5. 도메인 이벤트 발행 로직 구현\n6. 애플리케이션 모듈의 build.gradle.kts 설정 (도메인 모듈에만 의존, 인프라스트럭처 모듈에는 의존하지 않음)",
            "status": "pending",
            "testStrategy": "1. 애플리케이션 서비스 단위 테스트 (Mock Repository 사용)\n2. 유효성 검증 및 예외 처리 테스트\n3. 트랜잭션 롤백 테스트\n4. 도메인 이벤트 발행 테스트",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "인터페이스 모듈 구현 - Controller 및 DomainContext 통합",
            "description": "웹 컨트롤러 및 DomainContext 추출 인터셉터를 구현하여 전체 아키텍처를 통합합니다.",
            "dependencies": [
              4
            ],
            "details": "1. DomainContextInterceptor 구현 (SecurityContext에서 사용자 정보 추출)\n2. WebMvcConfigurer에 인터셉터 등록\n3. Controller 클래스 수정 (UserController, EmployeeController, StoreController)\n4. Request/Response DTO 및 Mapper 구현\n5. 전역 예외 처리기 구현 (DomainException → ApiError 변환)\n6. 인터페이스 모듈의 build.gradle.kts 설정\n7. 전체 모듈 통합 테스트",
            "status": "pending",
            "testStrategy": "1. DomainContextInterceptor 테스트\n2. Controller 통합 테스트\n3. API 응답 형식 및 상태 코드 테스트\n4. 예외 처리 테스트\n5. 권한 검사 테스트\n6. E2E 테스트 (전체 흐름 검증)",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "13",
        "title": "Flutter 프로젝트 초기화 및 공통 인프라 구축",
        "description": "Flutter 멀티플랫폼 프로젝트를 생성하고, 패키지 관리, 폴더 구조, 환경 변수, 테마 설정, API 클라이언트, 상태 관리, 인증 인프라 등 모바일 앱과 웹 어드민의 공통 기반 인프라를 구축합니다.",
        "details": "## 1. Flutter 프로젝트 생성\n\n### 1.1 프로젝트 초기화\n```bash\n# 프로젝트 루트에 Flutter 프로젝트 생성\nflutter create --platforms=ios,android,web lms_mobile_web\ncd lms_mobile_web\n\n# Flutter 버전 확인 (3.19+ 권장)\nflutter --version\nflutter doctor\n```\n\n### 1.2 필수 패키지 설치 (pubspec.yaml)\n```yaml\nname: lms_mobile_web\ndescription: LMS 근태 관리 시스템 - 모바일 앱 및 웹 어드민\npublish_to: 'none'\nversion: 1.0.0+1\n\nenvironment:\n  sdk: '>=3.0.0 <4.0.0'\n\ndependencies:\n  flutter:\n    sdk: flutter\n\n  # 상태 관리\n  flutter_riverpod: ^2.5.1          # Riverpod (Provider 2.0)\n  \n  # API 통신\n  dio: ^5.4.3                        # HTTP 클라이언트\n  retrofit: ^4.1.0                   # Type-safe REST API\n  json_annotation: ^4.9.0            # JSON 직렬화\n  \n  # 보안 저장소\n  flutter_secure_storage: ^9.0.0     # 토큰 저장\n  \n  # 날짜/시간\n  intl: ^0.19.0                      # 국제화 및 날짜 포맷\n  \n  # 라우팅\n  go_router: ^13.2.0                 # 선언적 라우팅\n  \n  # UI 컴포넌트\n  flutter_svg: ^2.0.10               # SVG 지원\n  cached_network_image: ^3.3.1       # 이미지 캐싱\n  \n  # 유틸리티\n  freezed_annotation: ^2.4.1         # 불변 모델\n  logger: ^2.3.0                     # 로깅\n  \n  # 환경 변수\n  flutter_dotenv: ^5.1.0             # .env 파일 지원\n\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n    \n  # 코드 생성\n  build_runner: ^2.4.9\n  freezed: ^2.5.2\n  json_serializable: ^6.8.0\n  retrofit_generator: ^8.1.0\n  \n  # 린팅\n  flutter_lints: ^3.0.1\n  \n  # 테스팅\n  mockito: ^5.4.4\n  \nflutter:\n  uses-material-design: true\n  \n  # Assets\n  assets:\n    - assets/images/\n    - assets/icons/\n    - .env\n```\n\n## 2. 프로젝트 폴더 구조 (Clean Architecture + Feature-First)\n\n```\nlms_mobile_web/\n├── lib/\n│   ├── main.dart                       # 앱 진입점\n│   ├── app.dart                        # App Widget (MaterialApp 설정)\n│   │\n│   ├── core/                           # 공통 인프라\n│   │   ├── api/\n│   │   │   ├── api_client.dart         # Dio 클라이언트 설정\n│   │   │   ├── api_interceptor.dart    # JWT 인터셉터\n│   │   │   ├── api_error_handler.dart  # 에러 처리\n│   │   │   └── endpoints.dart          # API 엔드포인트 상수\n│   │   │\n│   │   ├── storage/\n│   │   │   ├── secure_storage.dart     # SecureStorage 래퍼\n│   │   │   └── storage_keys.dart       # 저장소 키 상수\n│   │   │\n│   │   ├── config/\n│   │   │   ├── env_config.dart         # 환경 설정\n│   │   │   ├── app_config.dart         # 앱 설정\n│   │   │   └── theme_config.dart       # 테마 설정\n│   │   │\n│   │   ├── router/\n│   │   │   ├── app_router.dart         # GoRouter 설정\n│   │   │   └── route_names.dart        # 라우트 이름 상수\n│   │   │\n│   │   ├── models/\n│   │   │   ├── api_response.dart       # 공통 API 응답 모델\n│   │   │   └── error_response.dart     # 에러 응답 모델\n│   │   │\n│   │   ├── widgets/                    # 공통 UI 컴포넌트\n│   │   │   ├── loading_indicator.dart\n│   │   │   ├── error_view.dart\n│   │   │   └── custom_button.dart\n│   │   │\n│   │   └── utils/\n│   │       ├── date_formatter.dart     # 날짜 포맷팅\n│   │       ├── validators.dart         # 입력 검증\n│   │       └── logger.dart             # 로깅 유틸\n│   │\n│   ├── features/                       # Feature-First 구조\n│   │   ├── auth/\n│   │   │   ├── data/\n│   │   │   │   ├── models/\n│   │   │   │   │   ├── login_request.dart\n│   │   │   │   │   ├── login_response.dart\n│   │   │   │   │   └── user_model.dart\n│   │   │   │   ├── repositories/\n│   │   │   │   │   └── auth_repository_impl.dart\n│   │   │   │   └── datasources/\n│   │   │   │       └── auth_api.dart\n│   │   │   │\n│   │   │   ├── domain/\n│   │   │   │   ├── entities/\n│   │   │   │   │   └── user.dart\n│   │   │   │   └── repositories/\n│   │   │   │       └── auth_repository.dart\n│   │   │   │\n│   │   │   └── presentation/\n│   │   │       ├── providers/\n│   │   │       │   └── auth_provider.dart\n│   │   │       ├── screens/\n│   │   │       │   └── login_screen.dart\n│   │   │       └── widgets/\n│   │   │           └── login_form.dart\n│   │   │\n│   │   ├── attendance/                 # 출퇴근 기능\n│   │   ├── schedule/                   # 근무 일정\n│   │   ├── leave/                      # 휴가 관리\n│   │   ├── payroll/                    # 급여 조회\n│   │   └── admin/                      # 관리자 기능\n│   │\n│   └── shared/                         # 도메인 공통 요소\n│       ├── models/\n│       └── providers/\n│\n├── assets/\n│   ├── images/\n│   ├── icons/\n│   └── fonts/\n│\n├── .env                                # 환경 변수\n├── .env.example                        # 환경 변수 템플릿\n├── analysis_options.yaml               # 린트 규칙\n└── README.md\n```\n\n## 3. 환경 변수 설정\n\n### 3.1 .env 파일 생성\n```bash\n# .env\nAPI_BASE_URL=http://localhost:8080/api\nAPI_TIMEOUT=30000\nLOG_LEVEL=debug\nSTORAGE_ENCRYPTION_KEY=your-encryption-key-here\n```\n\n### 3.2 .env.example (버전 관리용)\n```bash\n# .env.example\nAPI_BASE_URL=\nAPI_TIMEOUT=30000\nLOG_LEVEL=debug\nSTORAGE_ENCRYPTION_KEY=\n```\n\n### 3.3 EnvConfig 클래스\n**파일:** `lib/core/config/env_config.dart`\n```dart\nimport 'package:flutter_dotenv/flutter_dotenv.dart';\n\nclass EnvConfig {\n  static String get apiBaseUrl => dotenv.env['API_BASE_URL'] ?? 'http://localhost:8080/api';\n  static int get apiTimeout => int.parse(dotenv.env['API_TIMEOUT'] ?? '30000');\n  static String get logLevel => dotenv.env['LOG_LEVEL'] ?? 'info';\n  static String get storageEncryptionKey => dotenv.env['STORAGE_ENCRYPTION_KEY'] ?? '';\n  \n  static Future<void> load() async {\n    await dotenv.load(fileName: '.env');\n  }\n}\n```\n\n## 4. 테마 설정 (Material Design 3)\n\n**파일:** `lib/core/config/theme_config.dart`\n```dart\nimport 'package:flutter/material.dart';\n\nclass ThemeConfig {\n  static ThemeData lightTheme() {\n    return ThemeData(\n      useMaterial3: true,\n      colorScheme: ColorScheme.fromSeed(\n        seedColor: const Color(0xFF2196F3), // Primary Blue\n        brightness: Brightness.light,\n      ),\n      appBarTheme: const AppBarTheme(\n        centerTitle: true,\n        elevation: 0,\n      ),\n      elevatedButtonTheme: ElevatedButtonThemeData(\n        style: ElevatedButton.styleFrom(\n          minimumSize: const Size(double.infinity, 48),\n          shape: RoundedRectangleBorder(\n            borderRadius: BorderRadius.circular(8),\n          ),\n        ),\n      ),\n      inputDecorationTheme: InputDecorationTheme(\n        border: OutlineInputBorder(\n          borderRadius: BorderRadius.circular(8),\n        ),\n        filled: true,\n      ),\n    );\n  }\n\n  static ThemeData darkTheme() {\n    return ThemeData(\n      useMaterial3: true,\n      colorScheme: ColorScheme.fromSeed(\n        seedColor: const Color(0xFF2196F3),\n        brightness: Brightness.dark,\n      ),\n      appBarTheme: const AppBarTheme(\n        centerTitle: true,\n        elevation: 0,\n      ),\n      elevatedButtonTheme: ElevatedButtonThemeData(\n        style: ElevatedButton.styleFrom(\n          minimumSize: const Size(double.infinity, 48),\n          shape: RoundedRectangleBorder(\n            borderRadius: BorderRadius.circular(8),\n          ),\n        ),\n      ),\n      inputDecorationTheme: InputDecorationTheme(\n        border: OutlineInputBorder(\n          borderRadius: BorderRadius.circular(8),\n        ),\n        filled: true,\n      ),\n    );\n  }\n}\n```\n\n## 5. API 클라이언트 설정 (Dio + Interceptor)\n\n### 5.1 API Client\n**파일:** `lib/core/api/api_client.dart`\n```dart\nimport 'package:dio/dio.dart';\nimport 'package:lms_mobile_web/core/api/api_interceptor.dart';\nimport 'package:lms_mobile_web/core/config/env_config.dart';\n\nclass ApiClient {\n  late final Dio dio;\n\n  ApiClient() {\n    dio = Dio(\n      BaseOptions(\n        baseUrl: EnvConfig.apiBaseUrl,\n        connectTimeout: Duration(milliseconds: EnvConfig.apiTimeout),\n        receiveTimeout: Duration(milliseconds: EnvConfig.apiTimeout),\n        headers: {\n          'Content-Type': 'application/json',\n          'Accept': 'application/json',\n        },\n      ),\n    );\n\n    // Interceptor 추가\n    dio.interceptors.add(ApiInterceptor());\n    \n    // 로그 인터셉터 (디버그 모드)\n    if (EnvConfig.logLevel == 'debug') {\n      dio.interceptors.add(LogInterceptor(\n        requestBody: true,\n        responseBody: true,\n      ));\n    }\n  }\n}\n```\n\n### 5.2 JWT Interceptor\n**파일:** `lib/core/api/api_interceptor.dart`\n```dart\nimport 'package:dio/dio.dart';\nimport 'package:lms_mobile_web/core/storage/secure_storage.dart';\nimport 'package:lms_mobile_web/core/storage/storage_keys.dart';\n\nclass ApiInterceptor extends Interceptor {\n  final SecureStorage _storage = SecureStorage();\n\n  @override\n  Future<void> onRequest(\n    RequestOptions options,\n    RequestInterceptorHandler handler,\n  ) async {\n    // Access Token 추가\n    final accessToken = await _storage.read(StorageKeys.accessToken);\n    if (accessToken != null) {\n      options.headers['Authorization'] = 'Bearer $accessToken';\n    }\n    \n    super.onRequest(options, handler);\n  }\n\n  @override\n  Future<void> onError(\n    DioException err,\n    ErrorInterceptorHandler handler,\n  ) async {\n    // 401 Unauthorized - 토큰 갱신 로직\n    if (err.response?.statusCode == 401) {\n      try {\n        final refreshToken = await _storage.read(StorageKeys.refreshToken);\n        if (refreshToken != null) {\n          // Refresh Token으로 새 Access Token 요청\n          final response = await Dio().post(\n            '${err.requestOptions.baseUrl}/auth/refresh',\n            data: {'refreshToken': refreshToken},\n          );\n          \n          final newAccessToken = response.data['accessToken'];\n          await _storage.write(StorageKeys.accessToken, newAccessToken);\n          \n          // 원래 요청 재시도\n          final retryOptions = err.requestOptions;\n          retryOptions.headers['Authorization'] = 'Bearer $newAccessToken';\n          \n          final retryResponse = await Dio().fetch(retryOptions);\n          return handler.resolve(retryResponse);\n        }\n      } catch (e) {\n        // Refresh 실패 시 로그아웃 처리\n        await _storage.deleteAll();\n        // TODO: 로그인 화면으로 이동\n      }\n    }\n    \n    super.onError(err, handler);\n  }\n}\n```\n\n### 5.3 API Endpoints\n**파일:** `lib/core/api/endpoints.dart`\n```dart\nclass ApiEndpoints {\n  // Auth\n  static const String login = '/auth/login';\n  static const String register = '/auth/register';\n  static const String refresh = '/auth/refresh';\n  static const String logout = '/auth/logout';\n  \n  // Attendance\n  static const String checkIn = '/attendance/check-in';\n  static const String checkOut = '/attendance/check-out';\n  static const String myAttendance = '/attendance/my-records';\n  \n  // Schedule\n  static const String mySchedule = '/work-schedules/my-schedules';\n  \n  // Leave\n  static const String leaveRequests = '/leave-requests';\n  static const String myLeaveRequests = '/leave-requests/my-requests';\n  \n  // Payroll\n  static const String myPayroll = '/payroll/my-payroll';\n}\n```\n\n## 6. SecureStorage 래퍼\n\n**파일:** `lib/core/storage/secure_storage.dart`\n```dart\nimport 'package:flutter_secure_storage/flutter_secure_storage.dart';\n\nclass SecureStorage {\n  static final SecureStorage _instance = SecureStorage._internal();\n  factory SecureStorage() => _instance;\n  SecureStorage._internal();\n\n  final FlutterSecureStorage _storage = const FlutterSecureStorage(\n    aOptions: AndroidOptions(\n      encryptedSharedPreferences: true,\n    ),\n    iOptions: IOSOptions(\n      accessibility: KeychainAccessibility.first_unlock,\n    ),\n  );\n\n  Future<void> write(String key, String value) async {\n    await _storage.write(key: key, value: value);\n  }\n\n  Future<String?> read(String key) async {\n    return await _storage.read(key: key);\n  }\n\n  Future<void> delete(String key) async {\n    await _storage.delete(key: key);\n  }\n\n  Future<void> deleteAll() async {\n    await _storage.deleteAll();\n  }\n}\n```\n\n**파일:** `lib/core/storage/storage_keys.dart`\n```dart\nclass StorageKeys {\n  static const String accessToken = 'access_token';\n  static const String refreshToken = 'refresh_token';\n  static const String userId = 'user_id';\n  static const String userEmail = 'user_email';\n  static const String userRole = 'user_role';\n}\n```\n\n## 7. 상태 관리 (Riverpod) 기본 설정\n\n**파일:** `lib/core/providers/dio_provider.dart`\n```dart\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:lms_mobile_web/core/api/api_client.dart';\nimport 'package:dio/dio.dart';\n\nfinal dioProvider = Provider<Dio>((ref) {\n  return ApiClient().dio;\n});\n```\n\n## 8. 라우팅 설정 (GoRouter)\n\n**파일:** `lib/core/router/app_router.dart`\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:go_router/go_router.dart';\nimport 'package:lms_mobile_web/features/auth/presentation/screens/login_screen.dart';\nimport 'package:lms_mobile_web/core/router/route_names.dart';\n\nfinal appRouter = GoRouter(\n  initialLocation: RouteNames.login,\n  routes: [\n    GoRoute(\n      path: RouteNames.login,\n      name: 'login',\n      builder: (context, state) => const LoginScreen(),\n    ),\n    // TODO: 추가 라우트 정의\n  ],\n);\n```\n\n**파일:** `lib/core/router/route_names.dart`\n```dart\nclass RouteNames {\n  static const String login = '/login';\n  static const String home = '/home';\n  static const String attendance = '/attendance';\n  static const String schedule = '/schedule';\n  static const String leave = '/leave';\n  static const String payroll = '/payroll';\n}\n```\n\n## 9. 앱 진입점 설정\n\n**파일:** `lib/main.dart`\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:lms_mobile_web/app.dart';\nimport 'package:lms_mobile_web/core/config/env_config.dart';\n\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  \n  // 환경 변수 로드\n  await EnvConfig.load();\n  \n  runApp(\n    const ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n```\n\n**파일:** `lib/app.dart`\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:lms_mobile_web/core/config/theme_config.dart';\nimport 'package:lms_mobile_web/core/router/app_router.dart';\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp.router(\n      title: 'LMS 근태 관리',\n      theme: ThemeConfig.lightTheme(),\n      darkTheme: ThemeConfig.darkTheme(),\n      themeMode: ThemeMode.system,\n      routerConfig: appRouter,\n    );\n  }\n}\n```\n\n## 10. 린팅 규칙 설정\n\n**파일:** `analysis_options.yaml`\n```yaml\ninclude: package:flutter_lints/flutter.yaml\n\nlinter:\n  rules:\n    - prefer_const_constructors\n    - prefer_const_literals_to_create_immutables\n    - avoid_print\n    - prefer_single_quotes\n    - require_trailing_commas\n    - sort_child_properties_last\n\nanalyzer:\n  exclude:\n    - \"**/*.g.dart\"\n    - \"**/*.freezed.dart\"\n```\n\n## 11. .gitignore 설정\n\n```gitignore\n# Flutter\n.dart_tool/\n.packages\n.pub/\nbuild/\n\n# IDE\n.idea/\n.vscode/\n*.iml\n\n# 환경 변수\n.env\n\n# iOS\nios/Pods/\nios/.symlinks/\nios/Flutter/Flutter.framework\nios/Flutter/Flutter.podspec\n\n# Android\nandroid/.gradle/\nandroid/captures/\nandroid/local.properties\n\n# Web\nweb/flutter_service_worker.js\n```",
        "testStrategy": "## 테스트 전략\n\n### 1. 프로젝트 초기화 검증\n- ✅ `flutter doctor` 실행하여 환경 설정 확인\n- ✅ `flutter pub get` 실행하여 모든 패키지 설치 성공 확인\n- ✅ `flutter analyze` 실행하여 코드 분석 통과 확인\n- ✅ iOS/Android/Web 플랫폼별 빌드 성공 확인\n\n### 2. 환경 변수 로드 테스트\n- ✅ `.env` 파일 존재 확인\n- ✅ `EnvConfig.load()` 호출 후 환경 변수 정상 로드 확인\n- ✅ API Base URL, Timeout 등 설정값 정상 출력 확인\n\n### 3. API 클라이언트 테스트\n**파일:** `test/core/api/api_client_test.dart`\n```dart\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:lms_mobile_web/core/api/api_client.dart';\n\nvoid main() {\n  test('ApiClient는 올바른 BaseURL을 가져야 함', () {\n    final client = ApiClient();\n    expect(client.dio.options.baseUrl, contains('http'));\n  });\n\n  test('ApiClient는 JSON 헤더를 포함해야 함', () {\n    final client = ApiClient();\n    expect(client.dio.options.headers['Content-Type'], 'application/json');\n  });\n}\n```\n\n### 4. SecureStorage 테스트\n**파일:** `test/core/storage/secure_storage_test.dart`\n```dart\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:lms_mobile_web/core/storage/secure_storage.dart';\nimport 'package:lms_mobile_web/core/storage/storage_keys.dart';\n\nvoid main() {\n  late SecureStorage storage;\n\n  setUp(() {\n    storage = SecureStorage();\n  });\n\n  test('토큰 저장 및 읽기', () async {\n    const testToken = 'test-access-token';\n    await storage.write(StorageKeys.accessToken, testToken);\n    \n    final result = await storage.read(StorageKeys.accessToken);\n    expect(result, testToken);\n  });\n\n  test('토큰 삭제', () async {\n    await storage.write(StorageKeys.accessToken, 'test');\n    await storage.delete(StorageKeys.accessToken);\n    \n    final result = await storage.read(StorageKeys.accessToken);\n    expect(result, isNull);\n  });\n}\n```\n\n### 5. 테마 설정 테스트\n- ✅ Light/Dark 테마 전환 동작 확인\n- ✅ Material Design 3 컴포넌트 렌더링 확인\n- ✅ 커스텀 컬러 스킴 적용 확인\n\n### 6. 라우팅 테스트\n**파일:** `test/core/router/app_router_test.dart`\n```dart\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:lms_mobile_web/core/router/app_router.dart';\n\nvoid main() {\n  test('초기 라우트는 로그인 화면이어야 함', () {\n    expect(appRouter.routeInformationProvider.value.uri.path, '/login');\n  });\n}\n```\n\n### 7. JWT Interceptor 테스트\n- ✅ Access Token이 요청 헤더에 자동 추가되는지 확인\n- ✅ 401 에러 발생 시 Refresh Token으로 갱신 시도 확인\n- ✅ Refresh 실패 시 로그아웃 및 로그인 화면 이동 확인\n\n### 8. 플랫폼별 빌드 및 실행 테스트\n```bash\n# iOS 빌드\nflutter build ios --debug\n\n# Android 빌드\nflutter build apk --debug\n\n# Web 빌드\nflutter build web --debug\n\n# 실제 실행\nflutter run -d chrome  # Web\nflutter run -d <device-id>  # iOS/Android\n```\n\n### 9. 폴더 구조 검증\n- ✅ `lib/core/` 디렉토리 구조 확인\n- ✅ `lib/features/` 디렉토리 구조 확인\n- ✅ `assets/` 디렉토리 및 `.env` 파일 존재 확인\n\n### 10. 통합 테스트 (앱 시작 플로우)\n**파일:** `integration_test/app_test.dart`\n```dart\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:integration_test/integration_test.dart';\nimport 'package:lms_mobile_web/main.dart' as app;\n\nvoid main() {\n  IntegrationTestWidgetsFlutterBinding.ensureInitialized();\n\n  testWidgets('앱이 정상적으로 시작되어야 함', (tester) async {\n    app.main();\n    await tester.pumpAndSettle();\n    \n    // 로그인 화면이 표시되는지 확인\n    expect(find.text('로그인'), findsOneWidget);\n  });\n}\n```\n\n### 11. 코드 품질 검증\n```bash\n# 린트 검사\nflutter analyze\n\n# 포맷팅 검사\nflutter format --set-exit-if-changed .\n\n# 단위 테스트 실행\nflutter test\n\n# 커버리지 리포트\nflutter test --coverage\n```",
        "status": "done",
        "dependencies": [
          "3",
          "4",
          "5",
          "6",
          "7",
          "9"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Flutter 프로젝트 생성 및 필수 패키지 설치",
            "description": "Flutter CLI를 사용하여 iOS/Android/Web 멀티플랫폼 프로젝트를 생성하고, pubspec.yaml에 필수 패키지(Riverpod, Dio, Retrofit, flutter_secure_storage, go_router, freezed 등)를 추가한 후 의존성을 설치합니다.",
            "dependencies": [],
            "details": "## 구현 세부사항\n\n### 1. Flutter 프로젝트 생성\n```bash\n# 프로젝트 루트에 Flutter 프로젝트 생성 (lms-demo/lms_mobile_web)\ncd c:\\Users\\kitek\\IdeaProjects\\lms-demo\nflutter create --platforms=ios,android,web lms_mobile_web\ncd lms_mobile_web\n\n# Flutter 환경 확인 (3.19+ 권장)\nflutter --version\nflutter doctor\n```\n\n### 2. pubspec.yaml 패키지 추가\n필수 패키지를 추가하고 `flutter pub get` 실행:\n- flutter_riverpod: ^2.5.1 (상태 관리)\n- dio: ^5.4.3 (HTTP 클라이언트)\n- retrofit: ^4.1.0 (Type-safe REST API)\n- json_annotation: ^4.9.0 (JSON 직렬화)\n- flutter_secure_storage: ^9.0.0 (토큰 저장)\n- intl: ^0.19.0 (날짜 포맷)\n- go_router: ^13.2.0 (라우팅)\n- flutter_svg: ^2.0.10, cached_network_image: ^3.3.1 (UI)\n- freezed_annotation: ^2.4.1, logger: ^2.3.0 (유틸)\n- flutter_dotenv: ^5.1.0 (환경 변수)\n\ndev_dependencies:\n- build_runner: ^2.4.9\n- freezed: ^2.5.2\n- json_serializable: ^6.8.0\n- retrofit_generator: ^8.1.0\n- flutter_lints: ^3.0.1\n- mockito: ^5.4.4\n\n### 3. 패키지 설치 및 검증\n```bash\nflutter pub get\nflutter analyze\n```\n\n### 4. .gitignore 업데이트\n기존 .gitignore에 Flutter 관련 항목 추가:\n```\n# Flutter\nlms_mobile_web/.dart_tool/\nlms_mobile_web/.packages\nlms_mobile_web/.pub/\nlms_mobile_web/build/\nlms_mobile_web/ios/Pods/\nlms_mobile_web/ios/.symlinks/\nlms_mobile_web/android/.gradle/\nlms_mobile_web/android/local.properties\n```",
            "status": "done",
            "testStrategy": "1. `flutter doctor` 실행하여 모든 플랫폼 환경 설정 완료 확인\n2. `flutter pub get` 실행하여 모든 패키지 설치 성공 확인\n3. `flutter analyze` 실행하여 코드 분석 통과 확인\n4. `flutter build apk --debug`, `flutter build ios --debug --no-codesign`, `flutter build web` 실행하여 각 플랫폼 빌드 성공 확인",
            "parentId": "undefined",
            "updatedAt": "2026-01-17T05:33:14.432Z"
          },
          {
            "id": 2,
            "title": "Clean Architecture 기반 폴더 구조 및 린팅 규칙 설정",
            "description": "Feature-First 방식의 Clean Architecture 폴더 구조(core, features, shared)를 생성하고, analysis_options.yaml에 린팅 규칙을 설정하여 코드 품질 기준을 확립합니다.",
            "dependencies": [
              1
            ],
            "details": "## 구현 세부사항\n\n### 1. 폴더 구조 생성\n```bash\ncd lms_mobile_web/lib\n\n# Core 인프라\nmkdir -p core/{api,storage,config,router,models,widgets,utils}\n\n# Features (각 도메인별)\nmkdir -p features/auth/{data/{models,repositories,datasources},domain/{entities,repositories},presentation/{providers,screens,widgets}}\nmkdir -p features/attendance/{data,domain,presentation}\nmkdir -p features/schedule/{data,domain,presentation}\nmkdir -p features/leave/{data,domain,presentation}\nmkdir -p features/payroll/{data,domain,presentation}\nmkdir -p features/admin/{data,domain,presentation}\n\n# Shared (도메인 공통)\nmkdir -p shared/{models,providers}\n\n# Assets\ncd ..\nmkdir -p assets/{images,icons,fonts}\n```\n\n### 2. analysis_options.yaml 작성\n```yaml\ninclude: package:flutter_lints/flutter.yaml\n\nlinter:\n  rules:\n    - prefer_const_constructors\n    - prefer_const_literals_to_create_immutables\n    - avoid_print\n    - prefer_single_quotes\n    - require_trailing_commas\n    - sort_child_properties_last\n    - always_use_package_imports\n    - avoid_dynamic_calls\n    - avoid_empty_else\n    - avoid_redundant_argument_values\n    - prefer_final_fields\n    - prefer_final_locals\n    - use_key_in_widget_constructors\n\nanalyzer:\n  exclude:\n    - \"**/*.g.dart\"\n    - \"**/*.freezed.dart\"\n  errors:\n    invalid_annotation_target: ignore\n```\n\n### 3. 폴더 구조 검증\n```bash\nflutter analyze\ntree lib (구조 확인)\n```",
            "status": "done",
            "testStrategy": "1. `tree lib` 명령어로 폴더 구조가 올바르게 생성되었는지 확인\n2. `flutter analyze` 실행하여 린팅 규칙이 적용되었는지 확인\n3. 임시 코드 작성하여 린트 규칙(예: prefer_single_quotes) 위반 시 경고 표시 확인",
            "parentId": "undefined",
            "updatedAt": "2026-01-17T05:49:31.044Z"
          },
          {
            "id": 3,
            "title": "환경 변수 설정 및 테마 구성",
            "description": ".env 파일을 생성하여 API 엔드포인트와 환경 설정을 관리하고, EnvConfig 클래스와 ThemeConfig 클래스를 구현하여 Material Design 3 기반 라이트/다크 테마를 설정합니다.",
            "dependencies": [
              2
            ],
            "details": "## 구현 세부사항\n\n### 1. .env 파일 생성\n**위치:** `lms_mobile_web/.env`\n```\nAPI_BASE_URL=http://localhost:8080/api\nAPI_TIMEOUT=30000\nLOG_LEVEL=debug\nSTORAGE_ENCRYPTION_KEY=lms-demo-encryption-key-2024\n```\n\n**위치:** `lms_mobile_web/.env.example` (버전 관리용)\n```\nAPI_BASE_URL=\nAPI_TIMEOUT=30000\nLOG_LEVEL=debug\nSTORAGE_ENCRYPTION_KEY=\n```\n\n**pubspec.yaml assets 섹션에 추가:**\n```yaml\nflutter:\n  assets:\n    - .env\n    - assets/images/\n    - assets/icons/\n```\n\n### 2. EnvConfig 클래스 구현\n**위치:** `lib/core/config/env_config.dart`\n```dart\nimport 'package:flutter_dotenv/flutter_dotenv.dart';\n\nclass EnvConfig {\n  static String get apiBaseUrl => dotenv.env['API_BASE_URL'] ?? 'http://localhost:8080/api';\n  static int get apiTimeout => int.parse(dotenv.env['API_TIMEOUT'] ?? '30000');\n  static String get logLevel => dotenv.env['LOG_LEVEL'] ?? 'info';\n  static String get storageEncryptionKey => dotenv.env['STORAGE_ENCRYPTION_KEY'] ?? '';\n  \n  static Future<void> load() async {\n    await dotenv.load(fileName: '.env');\n  }\n}\n```\n\n### 3. ThemeConfig 클래스 구현\n**위치:** `lib/core/config/theme_config.dart`\n- Material Design 3 적용 (`useMaterial3: true`)\n- Primary Color: #2196F3 (Blue)\n- Light/Dark 테마 각각 구현\n- AppBar, ElevatedButton, InputDecoration 스타일 통일\n\n### 4. .gitignore 업데이트\n```\nlms_mobile_web/.env\n```",
            "status": "done",
            "testStrategy": "1. EnvConfig.load() 호출 후 각 환경 변수 값이 올바르게 로드되는지 단위 테스트\n2. .env 파일 없이 실행 시 기본값이 적용되는지 확인\n3. ThemeConfig.lightTheme()와 darkTheme()를 MaterialApp에 적용 후 UI 렌더링 확인\n4. 시스템 테마 변경 시 자동으로 테마가 전환되는지 확인",
            "parentId": "undefined",
            "updatedAt": "2026-01-17T05:50:17.120Z"
          },
          {
            "id": 4,
            "title": "API 클라이언트 및 JWT 인터셉터 구현",
            "description": "Dio 기반 ApiClient 클래스를 구현하고, JWT 토큰 자동 추가 및 401 에러 시 토큰 갱신 로직을 처리하는 ApiInterceptor를 구현하여 백엔드와의 안전한 통신 인프라를 구축합니다.",
            "dependencies": [
              3
            ],
            "details": "## 구현 세부사항\n\n### 1. SecureStorage 래퍼 구현\n**위치:** `lib/core/storage/secure_storage.dart`\n- FlutterSecureStorage 싱글톤 패턴으로 구현\n- write, read, delete, deleteAll 메서드 제공\n- Android: encryptedSharedPreferences 사용\n- iOS: KeychainAccessibility.first_unlock 설정\n\n**위치:** `lib/core/storage/storage_keys.dart`\n```dart\nclass StorageKeys {\n  static const String accessToken = 'access_token';\n  static const String refreshToken = 'refresh_token';\n  static const String userId = 'user_id';\n  static const String userEmail = 'user_email';\n  static const String userRole = 'user_role';\n}\n```\n\n### 2. ApiClient 구현\n**위치:** `lib/core/api/api_client.dart`\n- Dio 인스턴스 생성 및 BaseOptions 설정\n- EnvConfig에서 baseUrl, timeout 로드\n- LogInterceptor 추가 (debug 모드에서만)\n- ApiInterceptor 추가\n\n### 3. ApiInterceptor 구현\n**위치:** `lib/core/api/api_interceptor.dart`\n- onRequest: SecureStorage에서 accessToken 읽어서 Authorization 헤더 추가\n- onError: \n  - 401 Unauthorized 감지\n  - refreshToken으로 /auth/refresh 호출\n  - 새 accessToken 저장 후 원래 요청 재시도\n  - Refresh 실패 시 모든 토큰 삭제 및 로그인 화면으로 이동\n\n### 4. API Endpoints 상수 정의\n**위치:** `lib/core/api/endpoints.dart`\n- Auth: /auth/login, /auth/register, /auth/refresh, /auth/logout\n- Attendance: /attendance/check-in, /attendance/check-out, /attendance/my-records\n- Schedule: /work-schedules/my-schedules\n- Leave: /leave-requests, /leave-requests/my-requests\n- Payroll: /payroll/my-payroll\n\n### 5. Dio Provider 생성\n**위치:** `lib/core/providers/dio_provider.dart`\n```dart\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:dio/dio.dart';\nimport '../api/api_client.dart';\n\nfinal dioProvider = Provider<Dio>((ref) {\n  return ApiClient().dio;\n});\n```",
            "status": "done",
            "testStrategy": "1. ApiClient 인스턴스 생성 후 baseUrl, timeout 설정 확인\n2. Mock SecureStorage로 토큰 저장 후 ApiInterceptor가 Authorization 헤더를 자동 추가하는지 확인\n3. 401 응답 시뮬레이션하여 토큰 갱신 로직이 동작하는지 통합 테스트\n4. Refresh 실패 시 토큰 삭제 및 로그아웃 처리 확인\n5. LogInterceptor가 debug 모드에서만 동작하는지 확인",
            "parentId": "undefined",
            "updatedAt": "2026-01-17T05:52:47.865Z"
          },
          {
            "id": 5,
            "title": "앱 진입점 및 라우팅 설정",
            "description": "main.dart와 app.dart를 구성하여 환경 변수 로드, ProviderScope 설정, MaterialApp 초기화를 수행하고, GoRouter를 사용한 선언적 라우팅을 구현하여 앱의 기본 실행 환경을 완성합니다.",
            "dependencies": [
              4
            ],
            "details": "## 구현 세부사항\n\n### 1. 라우트 이름 상수 정의\n**위치:** `lib/core/router/route_names.dart`\n```dart\nclass RouteNames {\n  static const String login = '/login';\n  static const String home = '/home';\n  static const String attendance = '/attendance';\n  static const String schedule = '/schedule';\n  static const String leave = '/leave';\n  static const String payroll = '/payroll';\n  static const String adminDashboard = '/admin/dashboard';\n  static const String adminStores = '/admin/stores';\n  static const String adminEmployees = '/admin/employees';\n}\n```\n\n### 2. GoRouter 설정\n**위치:** `lib/core/router/app_router.dart`\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:go_router/go_router.dart';\nimport 'package:lms_mobile_web/features/auth/presentation/screens/login_screen.dart';\nimport 'route_names.dart';\n\nfinal appRouter = GoRouter(\n  initialLocation: RouteNames.login,\n  routes: [\n    GoRoute(\n      path: RouteNames.login,\n      name: 'login',\n      builder: (context, state) => const LoginScreen(),\n    ),\n    // TODO: Task 14, 15에서 추가 라우트 구현\n  ],\n  errorBuilder: (context, state) => Scaffold(\n    body: Center(\n      child: Text('페이지를 찾을 수 없습니다: ${state.uri}'),\n    ),\n  ),\n);\n```\n\n### 3. 임시 LoginScreen 생성\n**위치:** `lib/features/auth/presentation/screens/login_screen.dart`\n```dart\nimport 'package:flutter/material.dart';\n\nclass LoginScreen extends StatelessWidget {\n  const LoginScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('로그인')),\n      body: const Center(\n        child: Text('로그인 화면 (Task 14에서 구현 예정)'),\n      ),\n    );\n  }\n}\n```\n\n### 4. main.dart 구현\n**위치:** `lib/main.dart`\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'app.dart';\nimport 'core/config/env_config.dart';\n\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  \n  // 환경 변수 로드\n  await EnvConfig.load();\n  \n  runApp(\n    const ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n```\n\n### 5. app.dart 구현\n**위치:** `lib/app.dart`\n```dart\nimport 'package:flutter/material.dart';\nimport 'core/config/theme_config.dart';\nimport 'core/router/app_router.dart';\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp.router(\n      title: 'LMS 근태 관리',\n      theme: ThemeConfig.lightTheme(),\n      darkTheme: ThemeConfig.darkTheme(),\n      themeMode: ThemeMode.system,\n      routerConfig: appRouter,\n      debugShowCheckedModeBanner: false,\n    );\n  }\n}\n```\n\n### 6. 최종 검증\n```bash\nflutter run -d chrome  # 웹으로 실행\nflutter run            # Android/iOS 에뮬레이터로 실행\n```",
            "status": "done",
            "testStrategy": "1. `flutter run` 실행하여 앱이 정상적으로 시작되고 LoginScreen이 표시되는지 확인\n2. EnvConfig.load()가 main()에서 정상 호출되어 환경 변수가 로드되는지 확인\n3. 시스템 테마 변경 시 앱 테마가 자동 전환되는지 확인\n4. 존재하지 않는 라우트 접근 시 에러 화면이 표시되는지 확인\n5. iOS/Android/Web 각 플랫폼에서 앱 실행 및 라우팅 동작 확인",
            "parentId": "undefined",
            "updatedAt": "2026-01-17T05:52:47.873Z"
          }
        ],
        "updatedAt": "2026-01-17T05:52:47.873Z"
      },
      {
        "id": "14",
        "title": "Flutter API 통신 및 인증 시스템 구축",
        "description": "Dio 기반 API 클라이언트, JWT 인터셉터, 토큰 관리, AuthProvider, 에러 처리 시스템을 구현하여 Spring Boot 백엔드와의 안전한 통신 인프라를 구축합니다.",
        "details": "## 1. Dio API 클라이언트 구성\n\n### 1.1 Dio 패키지 설치 (pubspec.yaml 추가)\n```yaml\ndependencies:\n  dio: ^5.4.0                              # HTTP 클라이언트\n  flutter_secure_storage: ^9.0.0          # 토큰 안전 저장\n  pretty_dio_logger: ^1.3.1               # API 로그 (개발용)\n```\n\n### 1.2 API 클라이언트 Base 클래스 구현\n**위치:** `lib/core/network/api_client.dart`\n```dart\nimport 'package:dio/dio.dart';\nimport 'package:pretty_dio_logger/pretty_dio_logger.dart';\nimport '../config/env_config.dart';\nimport '../auth/token_manager.dart';\nimport 'jwt_interceptor.dart';\n\nclass ApiClient {\n  late final Dio _dio;\n  final TokenManager _tokenManager;\n\n  ApiClient(this._tokenManager) {\n    _dio = Dio(\n      BaseOptions(\n        baseUrl: EnvConfig.apiBaseUrl,\n        connectTimeout: Duration(milliseconds: EnvConfig.connectTimeout),\n        receiveTimeout: Duration(milliseconds: EnvConfig.receiveTimeout),\n        headers: {\n          'Content-Type': 'application/json',\n          'Accept': 'application/json',\n        },\n      ),\n    );\n\n    // 인터셉터 추가\n    _dio.interceptors.addAll([\n      JwtInterceptor(_tokenManager, _dio),\n      if (EnvConfig.isDevelopment) \n        PrettyDioLogger(\n          requestHeader: true,\n          requestBody: true,\n          responseBody: true,\n          responseHeader: false,\n          error: true,\n          compact: true,\n        ),\n    ]);\n  }\n\n  Dio get dio => _dio;\n\n  // HTTP Methods\n  Future<Response<T>> get<T>(\n    String path, {\n    Map<String, dynamic>? queryParameters,\n    Options? options,\n  }) async {\n    return _dio.get<T>(\n      path,\n      queryParameters: queryParameters,\n      options: options,\n    );\n  }\n\n  Future<Response<T>> post<T>(\n    String path, {\n    dynamic data,\n    Map<String, dynamic>? queryParameters,\n    Options? options,\n  }) async {\n    return _dio.post<T>(\n      path,\n      data: data,\n      queryParameters: queryParameters,\n      options: options,\n    );\n  }\n\n  Future<Response<T>> put<T>(\n    String path, {\n    dynamic data,\n    Options? options,\n  }) async {\n    return _dio.put<T>(path, data: data, options: options);\n  }\n\n  Future<Response<T>> delete<T>(\n    String path, {\n    dynamic data,\n    Options? options,\n  }) async {\n    return _dio.delete<T>(path, data: data, options: options);\n  }\n}\n```\n\n---\n\n## 2. JWT 토큰 관리 시스템\n\n### 2.1 TokenManager 구현\n**위치:** `lib/core/auth/token_manager.dart`\n```dart\nimport 'package:flutter_secure_storage/flutter_secure_storage.dart';\n\nclass TokenManager {\n  static const _keyAccessToken = 'access_token';\n  static const _keyRefreshToken = 'refresh_token';\n  \n  final FlutterSecureStorage _storage;\n\n  TokenManager() : _storage = const FlutterSecureStorage(\n    aOptions: AndroidOptions(encryptedSharedPreferences: true),\n    iOptions: IOSOptions(accessibility: KeychainAccessibility.first_unlock),\n  );\n\n  // Access Token 저장\n  Future<void> saveAccessToken(String token) async {\n    await _storage.write(key: _keyAccessToken, value: token);\n  }\n\n  // Refresh Token 저장\n  Future<void> saveRefreshToken(String token) async {\n    await _storage.write(key: _keyRefreshToken, value: token);\n  }\n\n  // Access Token 조회\n  Future<String?> getAccessToken() async {\n    return await _storage.read(key: _keyAccessToken);\n  }\n\n  // Refresh Token 조회\n  Future<String?> getRefreshToken() async {\n    return await _storage.read(key: _keyRefreshToken);\n  }\n\n  // 토큰 모두 삭제 (로그아웃)\n  Future<void> clearTokens() async {\n    await _storage.delete(key: _keyAccessToken);\n    await _storage.delete(key: _keyRefreshToken);\n  }\n\n  // 토큰 존재 여부 확인\n  Future<bool> hasAccessToken() async {\n    final token = await getAccessToken();\n    return token != null && token.isNotEmpty;\n  }\n\n  // JWT 토큰 파싱 (만료 시간 확인용)\n  bool isTokenExpired(String token) {\n    try {\n      final parts = token.split('.');\n      if (parts.length != 3) return true;\n\n      final payload = _decodeBase64(parts[1]);\n      final payloadMap = json.decode(payload);\n      \n      if (payloadMap is! Map<String, dynamic>) return true;\n      \n      final exp = payloadMap['exp'];\n      if (exp == null) return true;\n\n      final expiryDate = DateTime.fromMillisecondsSinceEpoch(exp * 1000);\n      return DateTime.now().isAfter(expiryDate);\n    } catch (e) {\n      return true;\n    }\n  }\n\n  String _decodeBase64(String str) {\n    String output = str.replaceAll('-', '+').replaceAll('_', '/');\n    switch (output.length % 4) {\n      case 0:\n        break;\n      case 2:\n        output += '==';\n        break;\n      case 3:\n        output += '=';\n        break;\n      default:\n        throw Exception('Illegal base64url string!');\n    }\n    return utf8.decode(base64Url.decode(output));\n  }\n}\n```\n\n### 2.2 JWT 인터셉터 구현\n**위치:** `lib/core/network/jwt_interceptor.dart`\n```dart\nimport 'package:dio/dio.dart';\nimport '../auth/token_manager.dart';\nimport '../exception/api_exception.dart';\n\nclass JwtInterceptor extends Interceptor {\n  final TokenManager _tokenManager;\n  final Dio _dio;\n\n  JwtInterceptor(this._tokenManager, this._dio);\n\n  @override\n  void onRequest(\n    RequestOptions options,\n    RequestInterceptorHandler handler,\n  ) async {\n    // 인증이 필요 없는 경로 (로그인, 회원가입)\n    final excludedPaths = ['/api/auth/login', '/api/auth/register'];\n    \n    if (!excludedPaths.contains(options.path)) {\n      final accessToken = await _tokenManager.getAccessToken();\n      \n      if (accessToken != null && accessToken.isNotEmpty) {\n        options.headers['Authorization'] = 'Bearer $accessToken';\n      }\n    }\n    \n    handler.next(options);\n  }\n\n  @override\n  void onError(DioException err, ErrorInterceptorHandler handler) async {\n    // 401 Unauthorized - Access Token 만료\n    if (err.response?.statusCode == 401) {\n      try {\n        // Refresh Token으로 Access Token 갱신 시도\n        await _refreshAccessToken();\n        \n        // 원래 요청 재시도\n        final options = err.requestOptions;\n        final newAccessToken = await _tokenManager.getAccessToken();\n        options.headers['Authorization'] = 'Bearer $newAccessToken';\n        \n        final response = await _dio.fetch(options);\n        return handler.resolve(response);\n      } catch (e) {\n        // Refresh Token도 만료됨 - 로그아웃 필요\n        await _tokenManager.clearTokens();\n        return handler.reject(\n          DioException(\n            requestOptions: err.requestOptions,\n            error: UnauthorizedException('토큰이 만료되었습니다. 다시 로그인해주세요.'),\n          ),\n        );\n      }\n    }\n\n    // 403 Forbidden - 권한 없음\n    if (err.response?.statusCode == 403) {\n      return handler.reject(\n        DioException(\n          requestOptions: err.requestOptions,\n          error: ForbiddenException('접근 권한이 없습니다.'),\n        ),\n      );\n    }\n\n    handler.next(err);\n  }\n\n  Future<void> _refreshAccessToken() async {\n    final refreshToken = await _tokenManager.getRefreshToken();\n    \n    if (refreshToken == null || refreshToken.isEmpty) {\n      throw UnauthorizedException('Refresh Token이 없습니다.');\n    }\n\n    try {\n      final response = await _dio.post(\n        '/api/auth/refresh',\n        data: {'refreshToken': refreshToken},\n        options: Options(headers: {'Authorization': ''}), // 인증 헤더 제거\n      );\n\n      final newAccessToken = response.data['accessToken'];\n      await _tokenManager.saveAccessToken(newAccessToken);\n    } catch (e) {\n      throw UnauthorizedException('토큰 갱신 실패');\n    }\n  }\n}\n```\n\n---\n\n## 3. API 예외 처리 시스템\n\n### 3.1 커스텀 예외 클래스\n**위치:** `lib/core/exception/api_exception.dart`\n```dart\nabstract class ApiException implements Exception {\n  final String message;\n  final String? code;\n\n  ApiException(this.message, {this.code});\n\n  @override\n  String toString() => message;\n}\n\n// 401 Unauthorized\nclass UnauthorizedException extends ApiException {\n  UnauthorizedException(String message) : super(message, code: 'UNAUTHORIZED');\n}\n\n// 403 Forbidden\nclass ForbiddenException extends ApiException {\n  ForbiddenException(String message) : super(message, code: 'FORBIDDEN');\n}\n\n// 404 Not Found\nclass NotFoundException extends ApiException {\n  NotFoundException(String message) : super(message, code: 'NOT_FOUND');\n}\n\n// 409 Conflict\nclass ConflictException extends ApiException {\n  ConflictException(String message) : super(message, code: 'CONFLICT');\n}\n\n// 422 Validation Error\nclass ValidationException extends ApiException {\n  ValidationException(String message) : super(message, code: 'VALIDATION_ERROR');\n}\n\n// 500 Server Error\nclass ServerException extends ApiException {\n  ServerException(String message) : super(message, code: 'SERVER_ERROR');\n}\n\n// Network Error\nclass NetworkException extends ApiException {\n  NetworkException(String message) : super(message, code: 'NETWORK_ERROR');\n}\n```\n\n### 3.2 에러 핸들러\n**위치:** `lib/core/exception/error_handler.dart`\n```dart\nimport 'package:dio/dio.dart';\nimport 'api_exception.dart';\n\nclass ErrorHandler {\n  static ApiException handleError(dynamic error) {\n    if (error is DioException) {\n      switch (error.type) {\n        case DioExceptionType.connectionTimeout:\n        case DioExceptionType.sendTimeout:\n        case DioExceptionType.receiveTimeout:\n          return NetworkException('연결 시간이 초과되었습니다.');\n        \n        case DioExceptionType.badResponse:\n          return _handleHttpError(error.response);\n        \n        case DioExceptionType.cancel:\n          return NetworkException('요청이 취소되었습니다.');\n        \n        default:\n          return NetworkException('네트워크 오류가 발생했습니다.');\n      }\n    }\n\n    if (error is ApiException) {\n      return error;\n    }\n\n    return ServerException('알 수 없는 오류가 발생했습니다.');\n  }\n\n  static ApiException _handleHttpError(Response? response) {\n    final statusCode = response?.statusCode;\n    final data = response?.data;\n\n    String message = '오류가 발생했습니다.';\n    \n    if (data is Map<String, dynamic> && data.containsKey('message')) {\n      message = data['message'];\n    }\n\n    switch (statusCode) {\n      case 400:\n        return ValidationException(message);\n      case 401:\n        return UnauthorizedException(message);\n      case 403:\n        return ForbiddenException(message);\n      case 404:\n        return NotFoundException(message);\n      case 409:\n        return ConflictException(message);\n      case 500:\n      case 502:\n      case 503:\n        return ServerException(message);\n      default:\n        return ServerException(message);\n    }\n  }\n}\n```\n\n---\n\n## 4. 인증 서비스 구현\n\n### 4.1 AuthService (API 호출 계층)\n**위치:** `lib/features/auth/data/auth_service.dart`\n```dart\nimport '../../../core/network/api_client.dart';\nimport '../../../core/exception/error_handler.dart';\nimport '../models/login_request.dart';\nimport '../models/login_response.dart';\nimport '../models/user_info.dart';\n\nclass AuthService {\n  final ApiClient _apiClient;\n\n  AuthService(this._apiClient);\n\n  Future<LoginResponse> login(LoginRequest request) async {\n    try {\n      final response = await _apiClient.post(\n        '/api/auth/login',\n        data: request.toJson(),\n      );\n\n      return LoginResponse.fromJson(response.data);\n    } catch (e) {\n      throw ErrorHandler.handleError(e);\n    }\n  }\n\n  Future<void> logout() async {\n    try {\n      await _apiClient.post('/api/auth/logout');\n    } catch (e) {\n      // 로그아웃은 실패해도 로컬 토큰 삭제\n      print('Logout API error: $e');\n    }\n  }\n\n  Future<String> refreshToken(String refreshToken) async {\n    try {\n      final response = await _apiClient.post(\n        '/api/auth/refresh',\n        data: {'refreshToken': refreshToken},\n      );\n\n      return response.data['accessToken'];\n    } catch (e) {\n      throw ErrorHandler.handleError(e);\n    }\n  }\n}\n```\n\n### 4.2 AuthProvider (Riverpod 상태 관리)\n**위치:** `lib/features/auth/providers/auth_provider.dart`\n```dart\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport '../../../core/auth/token_manager.dart';\nimport '../data/auth_service.dart';\nimport '../models/login_request.dart';\nimport '../models/user_info.dart';\n\n// AuthState 정의\nclass AuthState {\n  final UserInfo? user;\n  final bool isAuthenticated;\n  final bool isLoading;\n  final String? error;\n\n  AuthState({\n    this.user,\n    this.isAuthenticated = false,\n    this.isLoading = false,\n    this.error,\n  });\n\n  AuthState copyWith({\n    UserInfo? user,\n    bool? isAuthenticated,\n    bool? isLoading,\n    String? error,\n  }) {\n    return AuthState(\n      user: user ?? this.user,\n      isAuthenticated: isAuthenticated ?? this.isAuthenticated,\n      isLoading: isLoading ?? this.isLoading,\n      error: error,\n    );\n  }\n}\n\n// AuthNotifier\nclass AuthNotifier extends StateNotifier<AuthState> {\n  final AuthService _authService;\n  final TokenManager _tokenManager;\n\n  AuthNotifier(this._authService, this._tokenManager) : super(AuthState()) {\n    _checkAuthStatus();\n  }\n\n  // 인증 상태 확인\n  Future<void> _checkAuthStatus() async {\n    final hasToken = await _tokenManager.hasAccessToken();\n    \n    if (hasToken) {\n      state = state.copyWith(isAuthenticated: true);\n      // TODO: 사용자 정보 로드 (GET /api/users/me 등)\n    }\n  }\n\n  // 로그인\n  Future<void> login(String email, String password) async {\n    state = state.copyWith(isLoading: true, error: null);\n\n    try {\n      final request = LoginRequest(email: email, password: password);\n      final response = await _authService.login(request);\n\n      // 토큰 저장\n      await _tokenManager.saveAccessToken(response.accessToken);\n      await _tokenManager.saveRefreshToken(response.refreshToken);\n\n      state = state.copyWith(\n        user: response.userInfo,\n        isAuthenticated: true,\n        isLoading: false,\n      );\n    } catch (e) {\n      state = state.copyWith(\n        isLoading: false,\n        error: e.toString(),\n      );\n      rethrow;\n    }\n  }\n\n  // 로그아웃\n  Future<void> logout() async {\n    try {\n      await _authService.logout();\n    } finally {\n      await _tokenManager.clearTokens();\n      state = AuthState(); // 초기 상태로 리셋\n    }\n  }\n}\n\n// Provider 정의\nfinal authProvider = StateNotifierProvider<AuthNotifier, AuthState>((ref) {\n  final authService = ref.watch(authServiceProvider);\n  final tokenManager = ref.watch(tokenManagerProvider);\n  return AuthNotifier(authService, tokenManager);\n});\n\nfinal authServiceProvider = Provider<AuthService>((ref) {\n  final apiClient = ref.watch(apiClientProvider);\n  return AuthService(apiClient);\n});\n\nfinal tokenManagerProvider = Provider<TokenManager>((ref) {\n  return TokenManager();\n});\n\nfinal apiClientProvider = Provider<ApiClient>((ref) {\n  final tokenManager = ref.watch(tokenManagerProvider);\n  return ApiClient(tokenManager);\n});\n```\n\n---\n\n## 5. 데이터 모델 (DTO)\n\n### 5.1 LoginRequest/Response\n**위치:** `lib/features/auth/models/login_request.dart`\n```dart\nclass LoginRequest {\n  final String email;\n  final String password;\n\n  LoginRequest({required this.email, required this.password});\n\n  Map<String, dynamic> toJson() => {\n    'email': email,\n    'password': password,\n  };\n}\n```\n\n**위치:** `lib/features/auth/models/login_response.dart`\n```dart\nimport 'user_info.dart';\n\nclass LoginResponse {\n  final String accessToken;\n  final String refreshToken;\n  final UserInfo userInfo;\n\n  LoginResponse({\n    required this.accessToken,\n    required this.refreshToken,\n    required this.userInfo,\n  });\n\n  factory LoginResponse.fromJson(Map<String, dynamic> json) {\n    return LoginResponse(\n      accessToken: json['accessToken'],\n      refreshToken: json['refreshToken'],\n      userInfo: UserInfo.fromJson(json['userInfo']),\n    );\n  }\n}\n```\n\n### 5.2 UserInfo\n**위치:** `lib/features/auth/models/user_info.dart`\n```dart\nclass UserInfo {\n  final String userId;\n  final String email;\n  final String role;\n  final bool isActive;\n\n  UserInfo({\n    required this.userId,\n    required this.email,\n    required this.role,\n    required this.isActive,\n  });\n\n  factory UserInfo.fromJson(Map<String, dynamic> json) {\n    return UserInfo(\n      userId: json['userId'],\n      email: json['email'],\n      role: json['role'],\n      isActive: json['isActive'],\n    );\n  }\n\n  bool get isSuperAdmin => role == 'SUPER_ADMIN';\n  bool get isManager => role == 'MANAGER';\n  bool get isEmployee => role == 'EMPLOYEE';\n}\n```\n\n---\n\n## 6. 환경 변수 설정\n\n**위치:** `.env` 파일\n```env\nAPI_BASE_URL=http://localhost:8080\nCONNECT_TIMEOUT=30000\nRECEIVE_TIMEOUT=30000\nENVIRONMENT=development\n```\n\n**위치:** `lib/core/config/env_config.dart`\n```dart\nimport 'package:flutter_dotenv/flutter_dotenv.dart';\n\nclass EnvConfig {\n  static String get apiBaseUrl => dotenv.env['API_BASE_URL'] ?? 'http://localhost:8080';\n  static int get connectTimeout => int.parse(dotenv.env['CONNECT_TIMEOUT'] ?? '30000');\n  static int get receiveTimeout => int.parse(dotenv.env['RECEIVE_TIMEOUT'] ?? '30000');\n  static bool get isDevelopment => dotenv.env['ENVIRONMENT'] == 'development';\n\n  static Future<void> load() async {\n    await dotenv.load(fileName: '.env');\n  }\n}\n```\n\n---\n\n## 7. 폴더 구조\n\n```\nlib/\n├── core/\n│   ├── network/\n│   │   ├── api_client.dart           # Dio 클라이언트\n│   │   └── jwt_interceptor.dart      # JWT 인터셉터\n│   ├── auth/\n│   │   └── token_manager.dart        # 토큰 관리\n│   ├── exception/\n│   │   ├── api_exception.dart        # 커스텀 예외\n│   │   └── error_handler.dart        # 에러 핸들러\n│   └── config/\n│       └── env_config.dart           # 환경 변수\n├── features/\n│   └── auth/\n│       ├── data/\n│       │   └── auth_service.dart     # Auth API 서비스\n│       ├── models/\n│       │   ├── login_request.dart\n│       │   ├── login_response.dart\n│       │   └── user_info.dart\n│       └── providers/\n│           └── auth_provider.dart    # Riverpod Provider\n└── main.dart\n```\n\n---\n\n## 8. 초기화 (main.dart)\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'core/config/env_config.dart';\n\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  \n  // 환경 변수 로드\n  await EnvConfig.load();\n\n  runApp(\n    const ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'LMS Mobile',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: const LoginScreen(), // 로그인 화면\n    );\n  }\n}\n```\n\n---\n\n## 9. 사용 예시 (Login Screen)\n\n```dart\nclass LoginScreen extends ConsumerWidget {\n  const LoginScreen({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final authState = ref.watch(authProvider);\n\n    if (authState.isAuthenticated) {\n      // 로그인 성공 시 홈 화면으로 이동\n      WidgetsBinding.instance.addPostFrameCallback((_) {\n        Navigator.pushReplacement(\n          context,\n          MaterialPageRoute(builder: (_) => const HomeScreen()),\n        );\n      });\n    }\n\n    return Scaffold(\n      body: Center(\n        child: authState.isLoading\n            ? const CircularProgressIndicator()\n            : ElevatedButton(\n                onPressed: () async {\n                  try {\n                    await ref.read(authProvider.notifier).login(\n                          'user@example.com',\n                          'password123',\n                        );\n                  } catch (e) {\n                    ScaffoldMessenger.of(context).showSnackBar(\n                      SnackBar(content: Text(e.toString())),\n                    );\n                  }\n                },\n                child: const Text('로그인'),\n              ),\n      ),\n    );\n  }\n}\n```",
        "testStrategy": "## 테스트 전략\n\n### 1. 토큰 관리 단위 테스트\n**위치:** `test/core/auth/token_manager_test.dart`\n```dart\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:lms_mobile/core/auth/token_manager.dart';\n\nvoid main() {\n  late TokenManager tokenManager;\n\n  setUp(() {\n    tokenManager = TokenManager();\n  });\n\n  group('TokenManager 테스트', () {\n    test('Access Token 저장 및 조회', () async {\n      // Given\n      const token = 'test_access_token';\n      \n      // When\n      await tokenManager.saveAccessToken(token);\n      final result = await tokenManager.getAccessToken();\n      \n      // Then\n      expect(result, equals(token));\n    });\n\n    test('Refresh Token 저장 및 조회', () async {\n      // Given\n      const token = 'test_refresh_token';\n      \n      // When\n      await tokenManager.saveRefreshToken(token);\n      final result = await tokenManager.getRefreshToken();\n      \n      // Then\n      expect(result, equals(token));\n    });\n\n    test('토큰 삭제 시 null 반환', () async {\n      // Given\n      await tokenManager.saveAccessToken('token');\n      \n      // When\n      await tokenManager.clearTokens();\n      final result = await tokenManager.getAccessToken();\n      \n      // Then\n      expect(result, isNull);\n    });\n\n    test('JWT 만료 시간 검증', () {\n      // Given - 만료된 토큰\n      const expiredToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2MDAwMDAwMDB9.xxx';\n      \n      // When & Then\n      expect(tokenManager.isTokenExpired(expiredToken), isTrue);\n    });\n  });\n}\n```\n\n---\n\n### 2. API 클라이언트 Mocking 테스트\n**위치:** `test/core/network/api_client_test.dart`\n```dart\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:mockito/mockito.dart';\nimport 'package:mockito/annotations.dart';\nimport 'package:dio/dio.dart';\n\n@GenerateMocks([Dio, TokenManager])\nvoid main() {\n  group('ApiClient 테스트', () {\n    test('GET 요청 시 Authorization 헤더 추가', () async {\n      // Given\n      final mockDio = MockDio();\n      final mockTokenManager = MockTokenManager();\n      \n      when(mockTokenManager.getAccessToken())\n          .thenAnswer((_) async => 'test_token');\n      \n      // When\n      final apiClient = ApiClient(mockTokenManager);\n      await apiClient.get('/api/test');\n      \n      // Then\n      verify(mockDio.get(any, options: argThat(\n        predicate((Options opts) => \n          opts.headers?['Authorization'] == 'Bearer test_token'),\n        named: 'options',\n      ))).called(1);\n    });\n  });\n}\n```\n\n---\n\n### 3. 인증 에러 처리 테스트\n**위치:** `test/features/auth/auth_service_test.dart`\n```dart\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:mockito/mockito.dart';\nimport 'package:dio/dio.dart';\n\nvoid main() {\n  group('AuthService 에러 처리 테스트', () {\n    test('401 Unauthorized 시 UnauthorizedException 발생', () async {\n      // Given\n      final mockApiClient = MockApiClient();\n      when(mockApiClient.post(any, data: anyNamed('data')))\n          .thenThrow(DioException(\n            requestOptions: RequestOptions(path: '/api/auth/login'),\n            response: Response(\n              statusCode: 401,\n              requestOptions: RequestOptions(path: '/api/auth/login'),\n              data: {'message': '인증 실패'},\n            ),\n          ));\n\n      final authService = AuthService(mockApiClient);\n\n      // When & Then\n      expect(\n        () => authService.login(LoginRequest(email: 'test@test.com', password: 'wrong')),\n        throwsA(isA<UnauthorizedException>()),\n      );\n    });\n\n    test('409 Conflict 시 ConflictException 발생', () async {\n      // Given - 이미 존재하는 이메일\n      final mockApiClient = MockApiClient();\n      when(mockApiClient.post(any, data: anyNamed('data')))\n          .thenThrow(DioException(\n            requestOptions: RequestOptions(path: '/api/auth/register'),\n            response: Response(\n              statusCode: 409,\n              requestOptions: RequestOptions(path: '/api/auth/register'),\n              data: {'code': 'REG001', 'message': '이미 등록된 이메일입니다'},\n            ),\n          ));\n\n      // When & Then\n      expect(\n        () => authService.register(...),\n        throwsA(isA<ConflictException>()),\n      );\n    });\n  });\n}\n```\n\n---\n\n### 4. JWT 인터셉터 토큰 갱신 테스트\n**위치:** `test/core/network/jwt_interceptor_test.dart`\n```dart\nimport 'package:flutter_test/flutter_test.dart';\n\nvoid main() {\n  group('JwtInterceptor 토큰 갱신 테스트', () {\n    test('401 응답 시 Refresh Token으로 갱신 후 재시도', () async {\n      // Given\n      final mockTokenManager = MockTokenManager();\n      final mockDio = MockDio();\n      final interceptor = JwtInterceptor(mockTokenManager, mockDio);\n\n      when(mockTokenManager.getRefreshToken())\n          .thenAnswer((_) async => 'valid_refresh_token');\n      \n      when(mockDio.post('/api/auth/refresh', data: anyNamed('data')))\n          .thenAnswer((_) async => Response(\n            data: {'accessToken': 'new_access_token'},\n            requestOptions: RequestOptions(path: '/api/auth/refresh'),\n          ));\n\n      // When - 401 에러 발생\n      final dioError = DioException(\n        requestOptions: RequestOptions(path: '/api/data'),\n        response: Response(\n          statusCode: 401,\n          requestOptions: RequestOptions(path: '/api/data'),\n        ),\n      );\n\n      // Then - 토큰 갱신 후 원래 요청 재시도\n      verify(mockTokenManager.saveAccessToken('new_access_token')).called(1);\n      verify(mockDio.fetch(any)).called(1);\n    });\n\n    test('Refresh Token 만료 시 로그아웃', () async {\n      // Given\n      final mockTokenManager = MockTokenManager();\n      when(mockTokenManager.getRefreshToken()).thenAnswer((_) async => null);\n\n      // When & Then\n      expect(\n        () => interceptor.onError(...),\n        throwsA(isA<UnauthorizedException>()),\n      );\n      verify(mockTokenManager.clearTokens()).called(1);\n    });\n  });\n}\n```\n\n---\n\n### 5. AuthProvider 상태 관리 테스트\n**위치:** `test/features/auth/auth_provider_test.dart`\n```dart\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nvoid main() {\n  group('AuthProvider 상태 관리 테스트', () {\n    test('로그인 성공 시 isAuthenticated = true', () async {\n      // Given\n      final container = ProviderContainer(\n        overrides: [\n          authServiceProvider.overrideWithValue(mockAuthService),\n        ],\n      );\n\n      final notifier = container.read(authProvider.notifier);\n\n      // When\n      await notifier.login('user@test.com', 'password123');\n\n      // Then\n      final state = container.read(authProvider);\n      expect(state.isAuthenticated, isTrue);\n      expect(state.user, isNotNull);\n      expect(state.error, isNull);\n    });\n\n    test('로그인 실패 시 error 메시지 설정', () async {\n      // Given\n      when(mockAuthService.login(any))\n          .thenThrow(UnauthorizedException('인증 실패'));\n\n      // When\n      await notifier.login('user@test.com', 'wrong_password');\n\n      // Then\n      final state = container.read(authProvider);\n      expect(state.isAuthenticated, isFalse);\n      expect(state.error, isNotNull);\n    });\n\n    test('로그아웃 시 토큰 삭제 및 상태 초기화', () async {\n      // Given\n      await notifier.login('user@test.com', 'password123');\n\n      // When\n      await notifier.logout();\n\n      // Then\n      final state = container.read(authProvider);\n      expect(state.isAuthenticated, isFalse);\n      expect(state.user, isNull);\n      verify(mockTokenManager.clearTokens()).called(1);\n    });\n  });\n}\n```\n\n---\n\n### 6. 통합 테스트 (Integration Test)\n\n**위치:** `integration_test/auth_flow_test.dart`\n```dart\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:integration_test/integration_test.dart';\n\nvoid main() {\n  IntegrationTestWidgetsFlutterBinding.ensureInitialized();\n\n  group('인증 플로우 통합 테스트', () {\n    testWidgets('로그인 → 홈 화면 → 로그아웃 플로우', (tester) async {\n      // Given\n      await tester.pumpWidget(const MyApp());\n      \n      // When - 로그인\n      await tester.enterText(find.byKey(const Key('email_field')), 'user@test.com');\n      await tester.enterText(find.byKey(const Key('password_field')), 'password123');\n      await tester.tap(find.byKey(const Key('login_button')));\n      await tester.pumpAndSettle();\n      \n      // Then - 홈 화면 표시\n      expect(find.text('홈 화면'), findsOneWidget);\n      \n      // When - 로그아웃\n      await tester.tap(find.byKey(const Key('logout_button')));\n      await tester.pumpAndSettle();\n      \n      // Then - 로그인 화면으로 복귀\n      expect(find.text('로그인'), findsOneWidget);\n    });\n\n    testWidgets('잘못된 비밀번호로 로그인 시 에러 메시지 표시', (tester) async {\n      // Given\n      await tester.pumpWidget(const MyApp());\n      \n      // When\n      await tester.enterText(find.byKey(const Key('email_field')), 'user@test.com');\n      await tester.enterText(find.byKey(const Key('password_field')), 'wrong_password');\n      await tester.tap(find.byKey(const Key('login_button')));\n      await tester.pumpAndSettle();\n      \n      // Then\n      expect(find.text('이메일 또는 비밀번호가 일치하지 않습니다.'), findsOneWidget);\n    });\n  });\n}\n```\n\n---\n\n### 7. 실제 API 연동 테스트 (수동)\n\n#### 7.1 백엔드 서버 실행\n```bash\n# Spring Boot 서버 실행\ncd lms-demo\n./gradlew bootRun\n```\n\n#### 7.2 Flutter 앱에서 실제 로그인 테스트\n- `.env` 파일의 `API_BASE_URL`을 실제 서버 주소로 설정\n- 앱 실행 후 실제 계정으로 로그인 시도\n- 네트워크 인스펙터(Charles, Proxyman)로 HTTP 요청/응답 확인\n\n#### 7.3 검증 체크리스트\n- ✅ POST `/api/auth/login` 요청 성공\n- ✅ Access Token과 Refresh Token이 Secure Storage에 저장됨\n- ✅ 이후 API 요청에 `Authorization: Bearer <token>` 헤더 자동 추가\n- ✅ Access Token 만료 시 자동으로 Refresh Token으로 갱신\n- ✅ Refresh Token 만료 시 로그아웃 처리\n- ✅ 401/403 에러 시 적절한 예외 발생\n- ✅ 네트워크 오류 시 NetworkException 발생\n- ✅ 로그아웃 시 토큰 삭제 및 로그인 화면 이동\n\n---\n\n### 8. 테스트 커버리지 목표\n- **Unit Test**: 80% 이상\n- **Widget Test**: 주요 UI 컴포넌트 100%\n- **Integration Test**: 핵심 플로우 100% (로그인, 로그아웃, 토큰 갱신)\n\n---\n\n### 9. 테스트 실행 명령어\n```bash\n# 단위 테스트 실행\nflutter test\n\n# 커버리지 포함 테스트\nflutter test --coverage\n\n# 통합 테스트 실행\nflutter test integration_test/auth_flow_test.dart\n\n# 특정 테스트 파일 실행\nflutter test test/core/auth/token_manager_test.dart\n```",
        "status": "pending",
        "dependencies": [
          "13"
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": "15",
        "title": "근로자용 Flutter 모바일 앱 구현",
        "description": "근로자가 사용하는 Flutter 모바일 앱을 구현하여 로그인, 출퇴근 체크, 근무 일정 조회, 휴가 신청, 출퇴근 기록 조회, 급여 내역 조회 등 모든 근로자 기능을 제공합니다.",
        "details": "## 1. 프로젝트 구조 설정\n\nFlutter 프로젝트 내에서 근로자용 앱 전용 디렉토리 구성:\n\n```\nlib/\n├── features/\n│   └── employee/                    # 근로자용 기능 모음\n│       ├── auth/                    # 로그인/로그아웃\n│       │   ├── presentation/\n│       │   │   ├── login_screen.dart\n│       │   │   └── login_provider.dart\n│       │   └── domain/\n│       │       └── models/\n│       │           └── login_state.dart\n│       ├── attendance/              # 출퇴근 관리\n│       │   ├── presentation/\n│       │   │   ├── check_in_out_screen.dart\n│       │   │   ├── attendance_records_screen.dart\n│       │   │   └── attendance_provider.dart\n│       │   ├── domain/\n│       │   │   └── models/\n│       │   │       ├── attendance_record.dart\n│       │   │       └── attendance_state.dart\n│       │   └── data/\n│       │       ├── attendance_repository.dart\n│       │       └── attendance_api.dart\n│       ├── schedule/                # 근무 일정 조회\n│       │   ├── presentation/\n│       │   │   ├── my_schedule_screen.dart\n│       │   │   ├── schedule_calendar_widget.dart\n│       │   │   └── schedule_provider.dart\n│       │   ├── domain/\n│       │   │   └── models/\n│       │   │       ├── work_schedule.dart\n│       │   │       └── schedule_state.dart\n│       │   └── data/\n│       │       ├── schedule_repository.dart\n│       │       └── schedule_api.dart\n│       ├── leave/                   # 휴가 신청/관리\n│       │   ├── presentation/\n│       │   │   ├── leave_request_screen.dart\n│       │   │   ├── leave_history_screen.dart\n│       │   │   └── leave_provider.dart\n│       │   ├── domain/\n│       │   │   └── models/\n│       │   │       ├── leave_request.dart\n│       │   │       └── leave_state.dart\n│       │   └── data/\n│       │       ├── leave_repository.dart\n│       │       └── leave_api.dart\n│       └── payroll/                 # 급여 조회\n│           ├── presentation/\n│           │   ├── payroll_screen.dart\n│           │   ├── payroll_detail_screen.dart\n│           │   └── payroll_provider.dart\n│           ├── domain/\n│           │   └── models/\n│           │       ├── payroll.dart\n│           │       └── payroll_state.dart\n│           └── data/\n│               ├── payroll_repository.dart\n│               └── payroll_api.dart\n```\n\n---\n\n## 2. 로그인 화면 구현\n\n### 2.1 로그인 상태 관리 (Riverpod)\n**위치:** `lib/features/employee/auth/presentation/login_provider.dart`\n```dart\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport '../../../../core/network/api_client.dart';\nimport '../../../../core/auth/token_manager.dart';\nimport '../domain/models/login_state.dart';\n\nfinal loginProvider = StateNotifierProvider<LoginNotifier, LoginState>((ref) {\n  return LoginNotifier(\n    apiClient: ref.read(apiClientProvider),\n    tokenManager: ref.read(tokenManagerProvider),\n  );\n});\n\nclass LoginNotifier extends StateNotifier<LoginState> {\n  final ApiClient apiClient;\n  final TokenManager tokenManager;\n\n  LoginNotifier({required this.apiClient, required this.tokenManager})\n      : super(LoginState.initial());\n\n  Future<void> login(String email, String password) async {\n    state = state.copyWith(isLoading: true, error: null);\n\n    try {\n      final response = await apiClient.post('/api/auth/login', data: {\n        'email': email,\n        'password': password,\n      });\n\n      await tokenManager.saveTokens(\n        accessToken: response.data['accessToken'],\n        refreshToken: response.data['refreshToken'],\n      );\n\n      state = state.copyWith(\n        isLoading: false,\n        isAuthenticated: true,\n        userId: response.data['userId'],\n        userName: response.data['name'],\n        role: response.data['role'],\n      );\n    } catch (e) {\n      state = state.copyWith(\n        isLoading: false,\n        error: e.toString(),\n      );\n    }\n  }\n\n  Future<void> logout() async {\n    await tokenManager.deleteTokens();\n    state = LoginState.initial();\n  }\n}\n```\n\n### 2.2 로그인 화면 UI\n**위치:** `lib/features/employee/auth/presentation/login_screen.dart`\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'login_provider.dart';\n\nclass LoginScreen extends ConsumerStatefulWidget {\n  const LoginScreen({Key? key}) : super(key: key);\n\n  @override\n  ConsumerState<LoginScreen> createState() => _LoginScreenState();\n}\n\nclass _LoginScreenState extends ConsumerState<LoginScreen> {\n  final _formKey = GlobalKey<FormState>();\n  final _emailController = TextEditingController();\n  final _passwordController = TextEditingController();\n\n  @override\n  void dispose() {\n    _emailController.dispose();\n    _passwordController.dispose();\n    super.dispose();\n  }\n\n  Future<void> _handleLogin() async {\n    if (!_formKey.currentState!.validate()) return;\n\n    await ref.read(loginProvider.notifier).login(\n      _emailController.text,\n      _passwordController.text,\n    );\n\n    final state = ref.read(loginProvider);\n    if (state.isAuthenticated) {\n      Navigator.of(context).pushReplacementNamed('/employee/home');\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final loginState = ref.watch(loginProvider);\n\n    return Scaffold(\n      body: SafeArea(\n        child: Padding(\n          padding: const EdgeInsets.all(24.0),\n          child: Form(\n            key: _formKey,\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              crossAxisAlignment: CrossAxisAlignment.stretch,\n              children: [\n                Text(\n                  '근로자 로그인',\n                  style: Theme.of(context).textTheme.headlineMedium,\n                  textAlign: TextAlign.center,\n                ),\n                const SizedBox(height: 48),\n                TextFormField(\n                  controller: _emailController,\n                  decoration: const InputDecoration(\n                    labelText: '이메일',\n                    prefixIcon: Icon(Icons.email),\n                    border: OutlineInputBorder(),\n                  ),\n                  keyboardType: TextInputType.emailAddress,\n                  validator: (value) {\n                    if (value == null || value.isEmpty) {\n                      return '이메일을 입력하세요';\n                    }\n                    if (!value.contains('@')) {\n                      return '올바른 이메일 형식이 아닙니다';\n                    }\n                    return null;\n                  },\n                ),\n                const SizedBox(height: 16),\n                TextFormField(\n                  controller: _passwordController,\n                  decoration: const InputDecoration(\n                    labelText: '비밀번호',\n                    prefixIcon: Icon(Icons.lock),\n                    border: OutlineInputBorder(),\n                  ),\n                  obscureText: true,\n                  validator: (value) {\n                    if (value == null || value.isEmpty) {\n                      return '비밀번호를 입력하세요';\n                    }\n                    if (value.length < 4) {\n                      return '비밀번호는 최소 4자 이상이어야 합니다';\n                    }\n                    return null;\n                  },\n                ),\n                if (loginState.error != null) ...[\n                  const SizedBox(height: 16),\n                  Text(\n                    loginState.error!,\n                    style: const TextStyle(color: Colors.red),\n                    textAlign: TextAlign.center,\n                  ),\n                ],\n                const SizedBox(height: 24),\n                ElevatedButton(\n                  onPressed: loginState.isLoading ? null : _handleLogin,\n                  style: ElevatedButton.styleFrom(\n                    padding: const EdgeInsets.symmetric(vertical: 16),\n                  ),\n                  child: loginState.isLoading\n                      ? const CircularProgressIndicator()\n                      : const Text('로그인', style: TextStyle(fontSize: 18)),\n                ),\n              ],\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n---\n\n## 3. 출퇴근 체크 화면 구현\n\n### 3.1 출퇴근 API 클라이언트\n**위치:** `lib/features/employee/attendance/data/attendance_api.dart`\n```dart\nimport 'package:dio/dio.dart';\nimport '../../../../core/network/api_client.dart';\n\nclass AttendanceApi {\n  final ApiClient apiClient;\n\n  AttendanceApi(this.apiClient);\n\n  // 출근 체크\n  Future<Map<String, dynamic>> checkIn(String workScheduleId) async {\n    final response = await apiClient.post(\n      '/api/attendance/check-in',\n      data: {'workScheduleId': workScheduleId},\n    );\n    return response.data;\n  }\n\n  // 퇴근 체크\n  Future<Map<String, dynamic>> checkOut() async {\n    final response = await apiClient.post('/api/attendance/check-out');\n    return response.data;\n  }\n\n  // 본인 출퇴근 기록 조회\n  Future<List<Map<String, dynamic>>> getMyRecords({\n    DateTime? startDate,\n    DateTime? endDate,\n  }) async {\n    final queryParams = <String, dynamic>{};\n    if (startDate != null) {\n      queryParams['startDate'] = startDate.toIso8601String().split('T')[0];\n    }\n    if (endDate != null) {\n      queryParams['endDate'] = endDate.toIso8601String().split('T')[0];\n    }\n\n    final response = await apiClient.get(\n      '/api/attendance/my-records',\n      queryParameters: queryParams,\n    );\n    return List<Map<String, dynamic>>.from(response.data['records']);\n  }\n}\n```\n\n### 3.2 출퇴근 화면 UI\n**위치:** `lib/features/employee/attendance/presentation/check_in_out_screen.dart`\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:intl/intl.dart';\nimport 'attendance_provider.dart';\n\nclass CheckInOutScreen extends ConsumerWidget {\n  const CheckInOutScreen({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final attendanceState = ref.watch(attendanceProvider);\n    final now = DateTime.now();\n    final timeFormat = DateFormat('HH:mm:ss');\n    final dateFormat = DateFormat('yyyy년 MM월 dd일 EEEE', 'ko_KR');\n\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('출퇴근 체크'),\n        actions: [\n          IconButton(\n            icon: const Icon(Icons.history),\n            onPressed: () {\n              Navigator.of(context).pushNamed('/employee/attendance/records');\n            },\n            tooltip: '출퇴근 기록',\n          ),\n        ],\n      ),\n      body: Padding(\n        padding: const EdgeInsets.all(24.0),\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          crossAxisAlignment: CrossAxisAlignment.stretch,\n          children: [\n            // 현재 시간 표시\n            Text(\n              dateFormat.format(now),\n              style: Theme.of(context).textTheme.titleLarge,\n              textAlign: TextAlign.center,\n            ),\n            const SizedBox(height: 16),\n            StreamBuilder(\n              stream: Stream.periodic(const Duration(seconds: 1)),\n              builder: (context, snapshot) {\n                return Text(\n                  timeFormat.format(DateTime.now()),\n                  style: Theme.of(context).textTheme.displayLarge?.copyWith(\n                    fontWeight: FontWeight.bold,\n                  ),\n                  textAlign: TextAlign.center,\n                );\n              },\n            ),\n            const SizedBox(height: 48),\n\n            // 출퇴근 상태 표시\n            if (attendanceState.todayRecord != null) ...[\n              Card(\n                child: Padding(\n                  padding: const EdgeInsets.all(16.0),\n                  child: Column(\n                    children: [\n                      if (attendanceState.todayRecord!.checkInTime != null) ...[\n                        Row(\n                          mainAxisAlignment: MainAxisAlignment.spaceBetween,\n                          children: [\n                            const Text('출근 시간:', style: TextStyle(fontSize: 16)),\n                            Text(\n                              timeFormat.format(attendanceState.todayRecord!.checkInTime!),\n                              style: const TextStyle(\n                                fontSize: 20,\n                                fontWeight: FontWeight.bold,\n                                color: Colors.green,\n                              ),\n                            ),\n                          ],\n                        ),\n                      ],\n                      if (attendanceState.todayRecord!.checkOutTime != null) ...[\n                        const SizedBox(height: 8),\n                        Row(\n                          mainAxisAlignment: MainAxisAlignment.spaceBetween,\n                          children: [\n                            const Text('퇴근 시간:', style: TextStyle(fontSize: 16)),\n                            Text(\n                              timeFormat.format(attendanceState.todayRecord!.checkOutTime!),\n                              style: const TextStyle(\n                                fontSize: 20,\n                                fontWeight: FontWeight.bold,\n                                color: Colors.red,\n                              ),\n                            ),\n                          ],\n                        ),\n                      ],\n                    ],\n                  ),\n                ),\n              ),\n              const SizedBox(height: 24),\n            ],\n\n            // 출근 버튼\n            if (attendanceState.todayRecord == null ||\n                attendanceState.todayRecord!.checkInTime == null)\n              ElevatedButton(\n                onPressed: attendanceState.isLoading\n                    ? null\n                    : () async {\n                  await ref.read(attendanceProvider.notifier).checkIn();\n                  if (attendanceState.error != null) {\n                    ScaffoldMessenger.of(context).showSnackBar(\n                      SnackBar(content: Text(attendanceState.error!)),\n                    );\n                  }\n                },\n                style: ElevatedButton.styleFrom(\n                  padding: const EdgeInsets.symmetric(vertical: 20),\n                  backgroundColor: Colors.green,\n                ),\n                child: attendanceState.isLoading\n                    ? const CircularProgressIndicator(color: Colors.white)\n                    : const Text('출근 체크', style: TextStyle(fontSize: 20)),\n              ),\n\n            // 퇴근 버튼\n            if (attendanceState.todayRecord?.checkInTime != null &&\n                attendanceState.todayRecord?.checkOutTime == null)\n              ElevatedButton(\n                onPressed: attendanceState.isLoading\n                    ? null\n                    : () async {\n                  await ref.read(attendanceProvider.notifier).checkOut();\n                  if (attendanceState.error != null) {\n                    ScaffoldMessenger.of(context).showSnackBar(\n                      SnackBar(content: Text(attendanceState.error!)),\n                    );\n                  }\n                },\n                style: ElevatedButton.styleFrom(\n                  padding: const EdgeInsets.symmetric(vertical: 20),\n                  backgroundColor: Colors.red,\n                ),\n                child: attendanceState.isLoading\n                    ? const CircularProgressIndicator(color: Colors.white)\n                    : const Text('퇴근 체크', style: TextStyle(fontSize: 20)),\n              ),\n\n            if (attendanceState.error != null) ...[\n              const SizedBox(height: 16),\n              Text(\n                attendanceState.error!,\n                style: const TextStyle(color: Colors.red),\n                textAlign: TextAlign.center,\n              ),\n            ],\n          ],\n        ),\n      ),\n    );\n  }\n}\n```\n\n---\n\n## 4. 근무 일정 조회 화면 구현\n\n### 4.1 일정 조회 API\n**위치:** `lib/features/employee/schedule/data/schedule_api.dart`\n```dart\nimport '../../../../core/network/api_client.dart';\n\nclass ScheduleApi {\n  final ApiClient apiClient;\n\n  ScheduleApi(this.apiClient);\n\n  // 본인 근무 일정 조회\n  Future<List<Map<String, dynamic>>> getMySchedule() async {\n    final response = await apiClient.get('/api/schedules/my-schedule');\n    return List<Map<String, dynamic>>.from(response.data['schedules']);\n  }\n}\n```\n\n### 4.2 일정 캘린더 화면\n**위치:** `lib/features/employee/schedule/presentation/my_schedule_screen.dart`\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:table_calendar/table_calendar.dart';\nimport 'package:intl/intl.dart';\nimport 'schedule_provider.dart';\n\nclass MyScheduleScreen extends ConsumerStatefulWidget {\n  const MyScheduleScreen({Key? key}) : super(key: key);\n\n  @override\n  ConsumerState<MyScheduleScreen> createState() => _MyScheduleScreenState();\n}\n\nclass _MyScheduleScreenState extends ConsumerState<MyScheduleScreen> {\n  DateTime _focusedDay = DateTime.now();\n  DateTime? _selectedDay;\n\n  @override\n  void initState() {\n    super.initState();\n    // 일정 로드\n    Future.microtask(() {\n      ref.read(scheduleProvider.notifier).loadSchedules();\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final scheduleState = ref.watch(scheduleProvider);\n    final timeFormat = DateFormat('HH:mm');\n\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('내 근무 일정'),\n      ),\n      body: Column(\n        children: [\n          TableCalendar(\n            firstDay: DateTime.utc(2020, 1, 1),\n            lastDay: DateTime.utc(2030, 12, 31),\n            focusedDay: _focusedDay,\n            selectedDayPredicate: (day) => isSameDay(_selectedDay, day),\n            onDaySelected: (selectedDay, focusedDay) {\n              setState(() {\n                _selectedDay = selectedDay;\n                _focusedDay = focusedDay;\n              });\n            },\n            calendarFormat: CalendarFormat.month,\n            locale: 'ko_KR',\n            // 일정이 있는 날짜 표시\n            eventLoader: (day) {\n              return scheduleState.schedules\n                  .where((schedule) => isSameDay(schedule.workDate, day))\n                  .toList();\n            },\n          ),\n          const Divider(),\n          Expanded(\n            child: _selectedDay == null\n                ? const Center(child: Text('날짜를 선택하세요'))\n                : scheduleState.isLoading\n                ? const Center(child: CircularProgressIndicator())\n                : ListView(\n              children: scheduleState.schedules\n                  .where((schedule) =>\n                  isSameDay(schedule.workDate, _selectedDay))\n                  .map((schedule) {\n                return Card(\n                  margin: const EdgeInsets.symmetric(\n                    horizontal: 16,\n                    vertical: 8,\n                  ),\n                  child: ListTile(\n                    leading: const Icon(Icons.schedule, size: 40),\n                    title: Text(\n                      '${timeFormat.format(schedule.startTime)} - ${timeFormat.format(schedule.endTime)}',\n                      style: const TextStyle(\n                        fontSize: 18,\n                        fontWeight: FontWeight.bold,\n                      ),\n                    ),\n                    subtitle: Text(\n                      '근무 시간: ${schedule.workHours}시간',\n                    ),\n                  ),\n                );\n              }).toList(),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n---\n\n## 5. 휴가 신청 화면 구현\n\n### 5.1 휴가 신청 API\n**위치:** `lib/features/employee/leave/data/leave_api.dart`\n```dart\nimport '../../../../core/network/api_client.dart';\n\nclass LeaveApi {\n  final ApiClient apiClient;\n\n  LeaveApi(this.apiClient);\n\n  // 휴가 신청\n  Future<Map<String, dynamic>> requestLeave({\n    required String leaveType,\n    required DateTime startDate,\n    required DateTime endDate,\n    String? reason,\n  }) async {\n    final response = await apiClient.post('/api/leaves', data: {\n      'leaveType': leaveType,\n      'startDate': startDate.toIso8601String().split('T')[0],\n      'endDate': endDate.toIso8601String().split('T')[0],\n      'reason': reason,\n    });\n    return response.data;\n  }\n\n  // 본인 휴가 신청 내역 조회\n  Future<List<Map<String, dynamic>>> getMyLeaves() async {\n    final response = await apiClient.get('/api/leaves/my-leaves');\n    return List<Map<String, dynamic>>.from(response.data['leaves']);\n  }\n\n  // 휴가 취소\n  Future<void> cancelLeave(String leaveId) async {\n    await apiClient.delete('/api/leaves/$leaveId');\n  }\n}\n```\n\n### 5.2 휴가 신청 화면\n**위치:** `lib/features/employee/leave/presentation/leave_request_screen.dart`\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:intl/intl.dart';\nimport 'leave_provider.dart';\n\nclass LeaveRequestScreen extends ConsumerStatefulWidget {\n  const LeaveRequestScreen({Key? key}) : super(key: key);\n\n  @override\n  ConsumerState<LeaveRequestScreen> createState() => _LeaveRequestScreenState();\n}\n\nclass _LeaveRequestScreenState extends ConsumerState<LeaveRequestScreen> {\n  final _formKey = GlobalKey<FormState>();\n  String _leaveType = 'ANNUAL';\n  DateTime _startDate = DateTime.now();\n  DateTime _endDate = DateTime.now();\n  final _reasonController = TextEditingController();\n\n  @override\n  void dispose() {\n    _reasonController.dispose();\n    super.dispose();\n  }\n\n  Future<void> _selectDate(BuildContext context, bool isStartDate) async {\n    final DateTime? picked = await showDatePicker(\n      context: context,\n      initialDate: isStartDate ? _startDate : _endDate,\n      firstDate: DateTime.now(),\n      lastDate: DateTime.now().add(const Duration(days: 365)),\n      locale: const Locale('ko', 'KR'),\n    );\n    if (picked != null) {\n      setState(() {\n        if (isStartDate) {\n          _startDate = picked;\n        } else {\n          _endDate = picked;\n        }\n      });\n    }\n  }\n\n  Future<void> _submitRequest() async {\n    if (!_formKey.currentState!.validate()) return;\n\n    await ref.read(leaveProvider.notifier).requestLeave(\n      leaveType: _leaveType,\n      startDate: _startDate,\n      endDate: _endDate,\n      reason: _reasonController.text,\n    );\n\n    final state = ref.read(leaveProvider);\n    if (state.error == null) {\n      ScaffoldMessenger.of(context).showSnackBar(\n        const SnackBar(content: Text('휴가 신청이 완료되었습니다')),\n      );\n      Navigator.of(context).pop();\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final leaveState = ref.watch(leaveProvider);\n    final dateFormat = DateFormat('yyyy-MM-dd');\n\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('휴가 신청'),\n      ),\n      body: Padding(\n        padding: const EdgeInsets.all(16.0),\n        child: Form(\n          key: _formKey,\n          child: ListView(\n            children: [\n              // 휴가 유형 선택\n              DropdownButtonFormField<String>(\n                value: _leaveType,\n                decoration: const InputDecoration(\n                  labelText: '휴가 유형',\n                  border: OutlineInputBorder(),\n                ),\n                items: const [\n                  DropdownMenuItem(value: 'ANNUAL', child: Text('연차')),\n                  DropdownMenuItem(value: 'HALF', child: Text('반차')),\n                  DropdownMenuItem(value: 'HOLIDAY', child: Text('휴일')),\n                ],\n                onChanged: (value) {\n                  setState(() {\n                    _leaveType = value!;\n                  });\n                },\n              ),\n              const SizedBox(height: 16),\n\n              // 시작일 선택\n              ListTile(\n                title: const Text('시작일'),\n                subtitle: Text(dateFormat.format(_startDate)),\n                trailing: const Icon(Icons.calendar_today),\n                onTap: () => _selectDate(context, true),\n                shape: RoundedRectangleBorder(\n                  side: const BorderSide(color: Colors.grey),\n                  borderRadius: BorderRadius.circular(4),\n                ),\n              ),\n              const SizedBox(height: 16),\n\n              // 종료일 선택\n              ListTile(\n                title: const Text('종료일'),\n                subtitle: Text(dateFormat.format(_endDate)),\n                trailing: const Icon(Icons.calendar_today),\n                onTap: () => _selectDate(context, false),\n                shape: RoundedRectangleBorder(\n                  side: const BorderSide(color: Colors.grey),\n                  borderRadius: BorderRadius.circular(4),\n                ),\n              ),\n              const SizedBox(height: 16),\n\n              // 사유 입력\n              TextFormField(\n                controller: _reasonController,\n                decoration: const InputDecoration(\n                  labelText: '사유 (선택)',\n                  border: OutlineInputBorder(),\n                ),\n                maxLines: 3,\n              ),\n              const SizedBox(height: 24),\n\n              // 신청 버튼\n              ElevatedButton(\n                onPressed: leaveState.isLoading ? null : _submitRequest,\n                style: ElevatedButton.styleFrom(\n                  padding: const EdgeInsets.symmetric(vertical: 16),\n                ),\n                child: leaveState.isLoading\n                    ? const CircularProgressIndicator()\n                    : const Text('휴가 신청', style: TextStyle(fontSize: 18)),\n              ),\n\n              if (leaveState.error != null) ...[\n                const SizedBox(height: 16),\n                Text(\n                  leaveState.error!,\n                  style: const TextStyle(color: Colors.red),\n                  textAlign: TextAlign.center,\n                ),\n              ],\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n---\n\n## 6. 급여 내역 조회 화면 구현\n\n### 6.1 급여 조회 API\n**위치:** `lib/features/employee/payroll/data/payroll_api.dart`\n```dart\nimport '../../../../core/network/api_client.dart';\n\nclass PayrollApi {\n  final ApiClient apiClient;\n\n  PayrollApi(this.apiClient);\n\n  // 본인 급여 내역 조회\n  Future<List<Map<String, dynamic>>> getMyPayrolls() async {\n    final response = await apiClient.get('/api/payrolls/my-payrolls');\n    return List<Map<String, dynamic>>.from(response.data['payrolls']);\n  }\n\n  // 급여 상세 조회\n  Future<Map<String, dynamic>> getPayrollDetail(String payrollId) async {\n    final response = await apiClient.get('/api/payrolls/$payrollId');\n    return response.data;\n  }\n}\n```\n\n### 6.2 급여 목록 화면\n**위치:** `lib/features/employee/payroll/presentation/payroll_screen.dart`\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:intl/intl.dart';\nimport 'payroll_provider.dart';\n\nclass PayrollScreen extends ConsumerStatefulWidget {\n  const PayrollScreen({Key? key}) : super(key: key);\n\n  @override\n  ConsumerState<PayrollScreen> createState() => _PayrollScreenState();\n}\n\nclass _PayrollScreenState extends ConsumerState<PayrollScreen> {\n  @override\n  void initState() {\n    super.initState();\n    Future.microtask(() {\n      ref.read(payrollProvider.notifier).loadPayrolls();\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final payrollState = ref.watch(payrollProvider);\n    final currencyFormat = NumberFormat.currency(locale: 'ko_KR', symbol: '₩');\n\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('급여 내역'),\n      ),\n      body: payrollState.isLoading\n          ? const Center(child: CircularProgressIndicator())\n          : payrollState.payrolls.isEmpty\n          ? const Center(child: Text('급여 내역이 없습니다'))\n          : ListView.builder(\n        padding: const EdgeInsets.all(16),\n        itemCount: payrollState.payrolls.length,\n        itemBuilder: (context, index) {\n          final payroll = payrollState.payrolls[index];\n          return Card(\n            margin: const EdgeInsets.only(bottom: 12),\n            child: ListTile(\n              leading: const Icon(Icons.attach_money, size: 40),\n              title: Text(\n                payroll.period,\n                style: const TextStyle(\n                  fontSize: 16,\n                  fontWeight: FontWeight.bold,\n                ),\n              ),\n              subtitle: Column(\n                crossAxisAlignment: CrossAxisAlignment.start,\n                children: [\n                  Text('총 급여: ${currencyFormat.format(payroll.totalAmount)}'),\n                  Text('근무 시간: ${payroll.totalWorkHours}시간'),\n                ],\n              ),\n              trailing: const Icon(Icons.chevron_right),\n              onTap: () {\n                Navigator.of(context).pushNamed(\n                  '/employee/payroll/detail',\n                  arguments: payroll.id,\n                );\n              },\n            ),\n          );\n        },\n      ),\n    );\n  }\n}\n```\n\n---\n\n## 7. 홈 화면 및 내비게이션 구현\n\n### 7.1 근로자 홈 화면\n**위치:** `lib/features/employee/home/employee_home_screen.dart`\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport '../auth/presentation/login_provider.dart';\n\nclass EmployeeHomeScreen extends ConsumerWidget {\n  const EmployeeHomeScreen({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final loginState = ref.watch(loginProvider);\n\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('근로자 메인'),\n        actions: [\n          IconButton(\n            icon: const Icon(Icons.logout),\n            onPressed: () async {\n              await ref.read(loginProvider.notifier).logout();\n              Navigator.of(context).pushReplacementNamed('/login');\n            },\n            tooltip: '로그아웃',\n          ),\n        ],\n      ),\n      body: Padding(\n        padding: const EdgeInsets.all(16.0),\n        child: GridView.count(\n          crossAxisCount: 2,\n          mainAxisSpacing: 16,\n          crossAxisSpacing: 16,\n          children: [\n            _MenuCard(\n              icon: Icons.access_time,\n              title: '출퇴근 체크',\n              color: Colors.blue,\n              onTap: () => Navigator.of(context).pushNamed('/employee/attendance'),\n            ),\n            _MenuCard(\n              icon: Icons.calendar_today,\n              title: '근무 일정',\n              color: Colors.green,\n              onTap: () => Navigator.of(context).pushNamed('/employee/schedule'),\n            ),\n            _MenuCard(\n              icon: Icons.beach_access,\n              title: '휴가 신청',\n              color: Colors.orange,\n              onTap: () => Navigator.of(context).pushNamed('/employee/leave'),\n            ),\n            _MenuCard(\n              icon: Icons.money,\n              title: '급여 조회',\n              color: Colors.purple,\n              onTap: () => Navigator.of(context).pushNamed('/employee/payroll'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass _MenuCard extends StatelessWidget {\n  final IconData icon;\n  final String title;\n  final Color color;\n  final VoidCallback onTap;\n\n  const _MenuCard({\n    required this.icon,\n    required this.title,\n    required this.color,\n    required this.onTap,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    return Card(\n      elevation: 4,\n      child: InkWell(\n        onTap: onTap,\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Icon(icon, size: 64, color: color),\n            const SizedBox(height: 8),\n            Text(\n              title,\n              style: const TextStyle(\n                fontSize: 16,\n                fontWeight: FontWeight.bold,\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n```\n\n---\n\n## 8. 라우팅 설정\n\n### 8.1 앱 라우트 설정\n**위치:** `lib/core/routes/app_routes.dart`\n```dart\nimport 'package:flutter/material.dart';\nimport '../../features/employee/auth/presentation/login_screen.dart';\nimport '../../features/employee/home/employee_home_screen.dart';\nimport '../../features/employee/attendance/presentation/check_in_out_screen.dart';\nimport '../../features/employee/attendance/presentation/attendance_records_screen.dart';\nimport '../../features/employee/schedule/presentation/my_schedule_screen.dart';\nimport '../../features/employee/leave/presentation/leave_request_screen.dart';\nimport '../../features/employee/leave/presentation/leave_history_screen.dart';\nimport '../../features/employee/payroll/presentation/payroll_screen.dart';\nimport '../../features/employee/payroll/presentation/payroll_detail_screen.dart';\n\nclass AppRoutes {\n  static const String login = '/login';\n  static const String employeeHome = '/employee/home';\n  static const String attendance = '/employee/attendance';\n  static const String attendanceRecords = '/employee/attendance/records';\n  static const String schedule = '/employee/schedule';\n  static const String leaveRequest = '/employee/leave';\n  static const String leaveHistory = '/employee/leave/history';\n  static const String payroll = '/employee/payroll';\n  static const String payrollDetail = '/employee/payroll/detail';\n\n  static Map<String, WidgetBuilder> getRoutes() {\n    return {\n      login: (context) => const LoginScreen(),\n      employeeHome: (context) => const EmployeeHomeScreen(),\n      attendance: (context) => const CheckInOutScreen(),\n      attendanceRecords: (context) => const AttendanceRecordsScreen(),\n      schedule: (context) => const MyScheduleScreen(),\n      leaveRequest: (context) => const LeaveRequestScreen(),\n      leaveHistory: (context) => const LeaveHistoryScreen(),\n      payroll: (context) => const PayrollScreen(),\n      payrollDetail: (context) => const PayrollDetailScreen(),\n    };\n  }\n}\n```\n\n---\n\n## 9. 필수 패키지 추가\n\n**pubspec.yaml에 추가:**\n```yaml\ndependencies:\n  # 기존 패키지 (Task 13, 14에서 추가)\n  flutter:\n    sdk: flutter\n  flutter_riverpod: ^2.5.1\n  dio: ^5.4.0\n  flutter_secure_storage: ^9.0.0\n  \n  # 추가 패키지\n  table_calendar: ^3.0.9        # 캘린더 위젯\n  intl: ^0.19.0                 # 날짜/숫자 포맷팅\n  \ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n  flutter_lints: ^3.0.0\n```\n\n---\n\n## 10. 최종 통합 및 검증\n\n### 10.1 main.dart 수정\n**위치:** `lib/main.dart`\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:intl/date_symbol_data_local.dart';\nimport 'core/routes/app_routes.dart';\nimport 'core/theme/app_theme.dart';\n\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  \n  // 한국어 날짜 포맷 초기화\n  await initializeDateFormatting('ko_KR', null);\n  \n  runApp(const ProviderScope(child: MyApp()));\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'LMS 근로자 앱',\n      theme: AppTheme.lightTheme,\n      initialRoute: AppRoutes.login,\n      routes: AppRoutes.getRoutes(),\n      locale: const Locale('ko', 'KR'),\n      supportedLocales: const [\n        Locale('ko', 'KR'),\n      ],\n    );\n  }\n}\n```",
        "testStrategy": "## 테스트 전략\n\n### 1. 로그인 기능 테스트\n- ✅ 올바른 이메일/비밀번호로 로그인 성공\n- ✅ 잘못된 자격 증명으로 로그인 실패 처리\n- ✅ 유효성 검사 (이메일 형식, 비밀번호 최소 길이)\n- ✅ 토큰 저장 확인 (flutter_secure_storage)\n- ✅ 로그인 후 홈 화면 이동 확인\n\n### 2. 출퇴근 기능 테스트\n- ✅ 출근 버튼 클릭 시 `/api/attendance/check-in` API 호출 확인\n- ✅ 출근 성공 시 출근 시간 표시 확인\n- ✅ 출근 후 퇴근 버튼 활성화 확인\n- ✅ 퇴근 버튼 클릭 시 `/api/attendance/check-out` API 호출 확인\n- ✅ 퇴근 완료 후 출퇴근 시간 모두 표시 확인\n- ✅ 동일 날짜 중복 출근 방지 처리\n- ✅ 에러 처리 (네트워크 오류, 서버 오류)\n\n### 3. 근무 일정 조회 테스트\n- ✅ `/api/schedules/my-schedule` API 호출하여 일정 목록 로드\n- ✅ 캘린더에 일정이 있는 날짜 마커 표시 확인\n- ✅ 날짜 선택 시 해당 날짜의 일정 상세 정보 표시\n- ✅ 시작 시간, 종료 시간, 근무 시간 정확히 표시\n- ✅ 빈 일정 처리 (일정이 없는 경우 메시지 표시)\n\n### 4. 휴가 신청 기능 테스트\n- ✅ 휴가 유형 선택 (연차/반차/휴일) 확인\n- ✅ 날짜 선택 (시작일/종료일) 기능 확인\n- ✅ 사유 입력 (선택 사항) 확인\n- ✅ 신청 버튼 클릭 시 `/api/leaves` POST 요청 확인\n- ✅ 신청 성공 시 성공 메시지 및 화면 이동\n- ✅ 본인 휴가 내역 조회 확인\n- ✅ 휴가 상태별 표시 (REQUESTED, APPROVED, REJECTED)\n- ✅ 에러 처리 (날짜 범위 검증, 잔여 연차 부족 등)\n\n### 5. 급여 내역 조회 테스트\n- ✅ `/api/payrolls/my-payrolls` API 호출하여 급여 목록 로드\n- ✅ 급여 기간(period) 정확히 표시\n- ✅ 총 급여 금액 원화 포맷으로 표시\n- ✅ 총 근무 시간 표시\n- ✅ 급여 항목 클릭 시 상세 화면 이동\n- ✅ 상세 화면에서 급여 구성 요소 (기본급, 연장근무, 야간수당 등) 표시\n- ✅ 빈 급여 내역 처리\n\n### 6. 네비게이션 및 라우팅 테스트\n- ✅ 로그인 후 홈 화면 이동\n- ✅ 홈 화면 메뉴 카드 클릭 시 각 기능 화면 이동\n- ✅ 뒤로 가기 버튼 동작 확인\n- ✅ 로그아웃 시 로그인 화면으로 이동 및 토큰 삭제 확인\n\n### 7. 토큰 관리 및 인증 테스트\n- ✅ Access Token 만료 시 자동 갱신 (Refresh Token 사용)\n- ✅ Refresh Token 만료 시 로그인 화면 이동\n- ✅ API 요청 시 Authorization 헤더 자동 추가 확인\n- ✅ 401 Unauthorized 응답 처리\n\n### 8. UI/UX 테스트\n- ✅ 로딩 상태 표시 (CircularProgressIndicator)\n- ✅ 에러 메시지 표시 (SnackBar, 화면 내 텍스트)\n- ✅ 한국어 날짜/시간 포맷 확인\n- ✅ 원화 포맷 확인\n- ✅ 반응형 레이아웃 (다양한 화면 크기 대응)\n- ✅ 접근성 (시각 장애인 지원 - Semantics)\n\n### 9. 통합 테스트\n- ✅ 전체 플로우 테스트:\n  1. 로그인\n  2. 출근 체크\n  3. 근무 일정 조회\n  4. 휴가 신청\n  5. 급여 조회\n  6. 로그아웃\n- ✅ 실제 백엔드 API 연동 테스트 (개발/스테이징 환경)\n\n### 10. 플랫폼별 빌드 테스트\n- ✅ Android APK 빌드 성공 확인\n- ✅ Android 실제 기기에서 실행 확인\n- ✅ iOS IPA 빌드 성공 확인 (macOS 환경)\n- ✅ iOS 시뮬레이터/실제 기기에서 실행 확인\n- ✅ 플랫폼별 권한 처리 (네트워크, 저장소 등)\n\n### 11. 단위 테스트 (Kotest 스타일)\n**위치:** `test/features/employee/auth/login_provider_test.dart`\n```dart\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:lms_mobile/features/employee/auth/presentation/login_provider.dart';\n\nvoid main() {\n  group('LoginNotifier 테스트', () {\n    test('초기 상태는 인증되지 않음', () {\n      final container = ProviderContainer();\n      final state = container.read(loginProvider);\n      \n      expect(state.isAuthenticated, false);\n      expect(state.isLoading, false);\n      expect(state.error, null);\n    });\n\n    test('로그인 성공 시 인증 상태로 변경', () async {\n      // Given\n      final container = ProviderContainer();\n      \n      // When\n      await container.read(loginProvider.notifier).login(\n        'test@example.com',\n        'password123',\n      );\n      \n      // Then\n      final state = container.read(loginProvider);\n      expect(state.isAuthenticated, true);\n      expect(state.error, null);\n    });\n\n    test('잘못된 자격 증명으로 로그인 실패', () async {\n      // Given\n      final container = ProviderContainer();\n      \n      // When\n      await container.read(loginProvider.notifier).login(\n        'wrong@example.com',\n        'wrongpassword',\n      );\n      \n      // Then\n      final state = container.read(loginProvider);\n      expect(state.isAuthenticated, false);\n      expect(state.error, isNotNull);\n    });\n  });\n}\n```\n\n### 12. 최종 검증 체크리스트\n- ✅ `flutter doctor` 실행하여 환경 설정 확인\n- ✅ `flutter pub get` 실행하여 모든 패키지 설치\n- ✅ `flutter analyze` 실행하여 코드 분석 통과\n- ✅ `flutter test` 실행하여 단위 테스트 통과\n- ✅ 실제 기기에서 E2E 테스트 수행\n- ✅ API 통신 로그 확인 (Dio Logger)\n- ✅ 메모리 누수 확인 (Flutter DevTools)\n- ✅ 성능 프로파일링 (Flutter DevTools Performance)",
        "status": "pending",
        "dependencies": [
          "14"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "로그인 및 인증 시스템 구현",
            "description": "근로자용 로그인 화면, JWT 인증 상태 관리(Riverpod), 토큰 저장/갱신 로직을 구현하고 /api/auth/login API와 연동합니다.",
            "dependencies": [],
            "details": "## 구현 범위\n\n### 1. 로그인 상태 모델 정의\n- `lib/features/employee/auth/domain/models/login_state.dart` 생성\n- LoginState 클래스: isLoading, isAuthenticated, userId, userName, role, error 필드 포함\n- copyWith 메서드 구현\n\n### 2. 로그인 Provider 구현\n- `lib/features/employee/auth/presentation/login_provider.dart` 생성\n- LoginNotifier 클래스 (StateNotifier<LoginState>)\n- login() 메서드: POST /api/auth/login 호출, 토큰 저장\n- logout() 메서드: 토큰 삭제, 상태 초기화\n- ApiClient 및 TokenManager 의존성 주입\n\n### 3. 로그인 화면 UI 구현\n- `lib/features/employee/auth/presentation/login_screen.dart` 생성\n- 이메일/비밀번호 입력 필드 (TextFormField)\n- 유효성 검사: 이메일 형식, 비밀번호 최소 4자\n- 로그인 버튼: isLoading 상태에서 CircularProgressIndicator 표시\n- 에러 메시지 표시\n- 로그인 성공 시 /employee/home으로 네비게이션\n\n### 4. API 연동\n- Task 14에서 구현된 ApiClient 사용\n- POST /api/auth/login 엔드포인트 호출\n- Request: {email: string, password: string}\n- Response: {accessToken: string, refreshToken: string, userId: string, name: string, role: string}\n- 토큰은 TokenManager를 통해 flutter_secure_storage에 저장\n\n### 5. 라우팅 설정\n- `lib/core/routes/app_routes.dart`에 login 라우트 추가\n- 초기 라우트를 /login으로 설정\n- 인증 성공 후 /employee/home으로 이동",
            "status": "pending",
            "testStrategy": "## 테스트 항목\n\n### 단위 테스트\n- LoginNotifier 테스트:\n  - 올바른 자격 증명으로 로그인 성공 시 isAuthenticated=true 확인\n  - 잘못된 자격 증명으로 로그인 실패 시 error 메시지 설정 확인\n  - logout() 호출 시 상태 초기화 확인\n\n### 위젯 테스트\n- LoginScreen 테스트:\n  - 이메일 형식 유효성 검사 동작 확인\n  - 비밀번호 최소 길이 검사 확인\n  - 로그인 버튼 클릭 시 login() 메서드 호출 확인\n\n### 통합 테스트\n- 로그인 플로우 E2E 테스트:\n  - 로그인 화면에서 자격 증명 입력\n  - 로그인 성공 후 홈 화면 이동 확인\n  - 토큰 저장 확인 (flutter_secure_storage mock)",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "출퇴근 체크 화면 구현",
            "description": "출근/퇴근 버튼, 실시간 시간 표시, 오늘의 출퇴근 기록 표시 화면을 구현하고 /api/attendance/check-in, /api/attendance/check-out API와 연동합니다.",
            "dependencies": [
              1
            ],
            "details": "## 구현 범위\n\n### 1. 출퇴근 도메인 모델 정의\n- `lib/features/employee/attendance/domain/models/attendance_record.dart`\n- AttendanceRecord 클래스: id, employeeId, workScheduleId, attendanceDate, checkInTime, checkOutTime, actualWorkHours, status, note, createdAt\n- `lib/features/employee/attendance/domain/models/attendance_state.dart`\n- AttendanceState 클래스: isLoading, todayRecord, error\n\n### 2. 출퇴근 API 클라이언트\n- `lib/features/employee/attendance/data/attendance_api.dart`\n- checkIn(workScheduleId): POST /api/attendance/check-in\n- checkOut(): POST /api/attendance/check-out\n- getMyRecords(startDate, endDate): GET /api/attendance/my-records\n\n### 3. 출퇴근 Provider 구현\n- `lib/features/employee/attendance/presentation/attendance_provider.dart`\n- AttendanceNotifier (StateNotifier<AttendanceState>)\n- checkIn() 메서드: 출근 API 호출, todayRecord 업데이트\n- checkOut() 메서드: 퇴근 API 호출, todayRecord 업데이트\n- loadTodayRecord() 메서드: 오늘 날짜 기록 조회\n\n### 4. 출퇴근 체크 화면 UI\n- `lib/features/employee/attendance/presentation/check_in_out_screen.dart`\n- 상단: 현재 날짜 및 시간 표시 (StreamBuilder로 1초마다 갱신)\n- 중앙: 오늘의 출근/퇴근 시간 표시 (Card 위젯)\n- 하단: 출근/퇴근 버튼\n  - 출근 전: 출근 체크 버튼 표시 (녹색)\n  - 출근 후: 퇴근 체크 버튼 표시 (빨간색)\n  - 퇴근 후: 버튼 비활성화\n- AppBar에 출퇴근 기록 조회 버튼 추가\n\n### 5. 시간 포맷팅\n- intl 패키지 사용\n- DateFormat('HH:mm:ss') - 시간 표시\n- DateFormat('yyyy년 MM월 dd일 EEEE', 'ko_KR') - 날짜 표시\n\n### 6. 라우팅 추가\n- /employee/attendance 라우트 추가",
            "status": "pending",
            "testStrategy": "## 테스트 항목\n\n### 단위 테스트\n- AttendanceApi 테스트:\n  - checkIn() 호출 시 올바른 엔드포인트 및 파라미터 전송 확인\n  - checkOut() 호출 시 올바른 엔드포인트 호출 확인\n\n### 위젯 테스트\n- CheckInOutScreen 테스트:\n  - 출근 전 상태에서 출근 버튼 표시 확인\n  - 출근 후 상태에서 퇴근 버튼 표시 확인\n  - 출퇴근 시간 표시 포맷 확인\n\n### 통합 테스트\n- 출퇴근 플로우 E2E 테스트:\n  - 출근 버튼 클릭 → API 호출 확인\n  - 출근 시간 화면 표시 확인\n  - 퇴근 버튼 클릭 → API 호출 확인\n  - 퇴근 시간 화면 표시 확인",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "근무 일정 조회 화면 구현",
            "description": "캘린더 형식으로 본인의 근무 일정을 조회하는 화면을 구현하고 /api/schedules/my-schedule API와 연동합니다.",
            "dependencies": [
              1
            ],
            "details": "## 구현 범위\n\n### 1. 일정 도메인 모델 정의\n- `lib/features/employee/schedule/domain/models/work_schedule.dart`\n- WorkSchedule 클래스: id, employeeId, storeId, workDate, startTime, endTime, workHours\n- `lib/features/employee/schedule/domain/models/schedule_state.dart`\n- ScheduleState 클래스: isLoading, schedules (List<WorkSchedule>), error\n\n### 2. 일정 API 클라이언트\n- `lib/features/employee/schedule/data/schedule_api.dart`\n- getMySchedule(): GET /api/schedules/my-schedule\n- Response: {schedules: [...], totalCount: number}\n\n### 3. 일정 Provider 구현\n- `lib/features/employee/schedule/presentation/schedule_provider.dart`\n- ScheduleNotifier (StateNotifier<ScheduleState>)\n- loadSchedules() 메서드: API 호출, schedules 상태 업데이트\n\n### 4. 일정 캘린더 화면 UI\n- `lib/features/employee/schedule/presentation/my_schedule_screen.dart`\n- table_calendar 패키지 사용\n- 상단: TableCalendar 위젯\n  - focusedDay, selectedDay 상태 관리\n  - eventLoader: 일정이 있는 날짜에 마커 표시\n  - locale: 'ko_KR'\n- 하단: 선택된 날짜의 일정 목록 (ListView)\n  - 각 일정 카드: 근무 시간(HH:mm - HH:mm), 근무 시간 표시\n  - 일정 없으면 \"일정이 없습니다\" 메시지 표시\n\n### 5. 패키지 추가\n- pubspec.yaml에 table_calendar: ^3.0.9 추가\n- intl 패키지로 날짜/시간 포맷팅\n\n### 6. 라우팅 추가\n- /employee/schedule 라우트 추가",
            "status": "pending",
            "testStrategy": "## 테스트 항목\n\n### 단위 테스트\n- ScheduleApi 테스트:\n  - getMySchedule() 호출 시 올바른 엔드포인트 호출 확인\n  - 응답 데이터 파싱 확인\n\n### 위젯 테스트\n- MyScheduleScreen 테스트:\n  - 캘린더 렌더링 확인\n  - 날짜 선택 시 해당 날짜 일정 표시 확인\n  - 일정 없는 날짜 선택 시 \"일정이 없습니다\" 메시지 확인\n\n### 통합 테스트\n- 일정 조회 플로우 E2E 테스트:\n  - 일정 화면 진입 → API 호출 확인\n  - 일정 데이터 캘린더 표시 확인\n  - 날짜 선택 시 상세 일정 표시 확인",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "휴가 신청 및 내역 조회 화면 구현",
            "description": "휴가 유형 선택, 기간 설정, 사유 입력 화면과 본인의 휴가 신청 내역 조회 화면을 구현하고 /api/leaves API와 연동합니다.",
            "dependencies": [
              1
            ],
            "details": "## 구현 범위\n\n### 1. 휴가 도메인 모델 정의\n- `lib/features/employee/leave/domain/models/leave_request.dart`\n- LeaveRequest 클래스: id, employeeId, leaveType, startDate, endDate, status, reason, rejectionReason, createdAt, approvedAt\n- `lib/features/employee/leave/domain/models/leave_state.dart`\n- LeaveState 클래스: isLoading, leaves (List<LeaveRequest>), error\n\n### 2. 휴가 API 클라이언트\n- `lib/features/employee/leave/data/leave_api.dart`\n- requestLeave(leaveType, startDate, endDate, reason): POST /api/leaves\n- getMyLeaves(): GET /api/leaves/my-leaves\n- cancelLeave(leaveId): DELETE /api/leaves/{leaveId}\n\n### 3. 휴가 Provider 구현\n- `lib/features/employee/leave/presentation/leave_provider.dart`\n- LeaveNotifier (StateNotifier<LeaveState>)\n- requestLeave() 메서드: 휴가 신청 API 호출\n- loadMyLeaves() 메서드: 본인 휴가 내역 조회\n- cancelLeave(leaveId) 메서드: 휴가 취소\n\n### 4. 휴가 신청 화면 UI\n- `lib/features/employee/leave/presentation/leave_request_screen.dart`\n- DropdownButtonFormField: 휴가 유형 선택 (ANNUAL, HALF, HOLIDAY)\n- ListTile + DatePicker: 시작일/종료일 선택\n- TextFormField: 사유 입력 (선택 사항, 최대 3줄)\n- 휴가 신청 버튼\n- 입력 유효성 검사: 시작일 ≤ 종료일\n\n### 5. 휴가 내역 조회 화면 UI\n- `lib/features/employee/leave/presentation/leave_history_screen.dart`\n- ListView: 휴가 신청 목록 (Card 형식)\n- 각 카드: 휴가 유형, 기간, 상태 (PENDING/APPROVED/REJECTED/CANCELLED)\n- 상태별 색상 구분 (대기: 주황, 승인: 녹색, 반려: 빨강, 취소: 회색)\n- PENDING 상태일 때 취소 버튼 표시\n- 반려된 경우 rejectionReason 표시\n\n### 6. 라우팅 추가\n- /employee/leave (휴가 신청)\n- /employee/leave/history (휴가 내역)",
            "status": "pending",
            "testStrategy": "## 테스트 항목\n\n### 단위 테스트\n- LeaveApi 테스트:\n  - requestLeave() 호출 시 올바른 요청 데이터 전송 확인\n  - getMyLeaves() 호출 시 응답 파싱 확인\n  - cancelLeave() 호출 시 올바른 엔드포인트 호출 확인\n\n### 위젯 테스트\n- LeaveRequestScreen 테스트:\n  - 휴가 유형 선택 확인\n  - 날짜 선택 UI 동작 확인\n  - 시작일 > 종료일 유효성 검사 확인\n\n### 통합 테스트\n- 휴가 신청 플로우 E2E 테스트:\n  - 휴가 유형 선택 → 날짜 선택 → 사유 입력 → 신청\n  - API 호출 확인\n  - 휴가 내역 화면에서 신청한 휴가 표시 확인\n  - PENDING 상태 휴가 취소 확인",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "급여 내역 조회 및 홈 화면 통합",
            "description": "본인의 급여 내역 조회 화면, 급여 상세 화면을 구현하고, 근로자 홈 화면에 모든 기능 메뉴를 통합하여 /api/payroll/my-payroll API와 연동합니다.",
            "dependencies": [
              1
            ],
            "details": "## 구현 범위\n\n### 1. 급여 도메인 모델 정의\n- `lib/features/employee/payroll/domain/models/payroll.dart`\n- Payroll 클래스: id, employeeId, period, totalAmount, totalWorkHours, calculatedAt\n- `lib/features/employee/payroll/domain/models/payroll_state.dart`\n- PayrollState 클래스: isLoading, payrolls (List<Payroll>), error\n\n### 2. 급여 API 클라이언트\n- `lib/features/employee/payroll/data/payroll_api.dart`\n- getMyPayrolls(): GET /api/payroll/my-payroll\n- getPayrollDetail(payrollId): GET /api/payroll/{payrollId}\n\n### 3. 급여 Provider 구현\n- `lib/features/employee/payroll/presentation/payroll_provider.dart`\n- PayrollNotifier (StateNotifier<PayrollState>)\n- loadPayrolls() 메서드: 본인 급여 목록 조회\n\n### 4. 급여 목록 화면 UI\n- `lib/features/employee/payroll/presentation/payroll_screen.dart`\n- ListView: 급여 내역 목록 (Card 형식)\n- 각 카드: 기간(YYYY-MM), 총 급여(₩ 포맷), 총 근무 시간\n- 카드 클릭 시 급여 상세 화면으로 이동\n- NumberFormat.currency(locale: 'ko_KR', symbol: '₩') 사용\n\n### 5. 급여 상세 화면 UI\n- `lib/features/employee/payroll/presentation/payroll_detail_screen.dart`\n- 기본 정보: 기간, 총 급여, 총 근무 시간\n- 계산일시 표시\n- (선택적) 급여 항목별 세부 내역 표시\n\n### 6. 근로자 홈 화면 구현\n- `lib/features/employee/home/employee_home_screen.dart`\n- AppBar: 타이틀 \"근로자 메인\", 로그아웃 버튼\n- GridView (2x2): 4개 메뉴 카드\n  1. 출퇴근 체크 (파란색, Icons.access_time)\n  2. 근무 일정 (녹색, Icons.calendar_today)\n  3. 휴가 신청 (주황색, Icons.beach_access)\n  4. 급여 조회 (보라색, Icons.money)\n- 각 카드 클릭 시 해당 화면으로 네비게이션\n\n### 7. 최종 라우팅 설정\n- `lib/core/routes/app_routes.dart`에 모든 라우트 통합\n- /login (초기 라우트)\n- /employee/home\n- /employee/attendance\n- /employee/attendance/records\n- /employee/schedule\n- /employee/leave\n- /employee/leave/history\n- /employee/payroll\n- /employee/payroll/detail\n\n### 8. main.dart 설정\n- ProviderScope로 앱 래핑\n- MaterialApp 설정: 한국어 로케일, 라우트 설정\n- initializeDateFormatting('ko_KR') 초기화",
            "status": "pending",
            "testStrategy": "## 테스트 항목\n\n### 단위 테스트\n- PayrollApi 테스트:\n  - getMyPayrolls() 호출 시 응답 파싱 확인\n  - getPayrollDetail() 호출 시 올바른 엔드포인트 호출 확인\n\n### 위젯 테스트\n- PayrollScreen 테스트:\n  - 급여 목록 렌더링 확인\n  - 통화 포맷(₩) 표시 확인\n  - 카드 클릭 시 상세 화면 이동 확인\n- EmployeeHomeScreen 테스트:\n  - 4개 메뉴 카드 렌더링 확인\n  - 각 메뉴 클릭 시 올바른 라우트 이동 확인\n  - 로그아웃 버튼 동작 확인\n\n### 통합 테스트\n- 전체 앱 플로우 E2E 테스트:\n  1. 로그인\n  2. 홈 화면에서 출퇴근 체크 메뉴 접근\n  3. 출근 체크 수행\n  4. 홈으로 돌아가서 근무 일정 확인\n  5. 휴가 신청 수행\n  6. 급여 내역 조회\n  7. 로그아웃\n\n### 성능 테스트\n- 큰 데이터 세트(100+ 급여 내역) 렌더링 성능 확인\n- 네트워크 오류 시 에러 핸들링 확인",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "16",
        "title": "Flutter 앱 통합 테스트 및 배포 파이프라인 구축",
        "description": "Flutter 모바일 앱과 웹 어드민의 E2E 테스트, 보안 검증, 성능 최적화를 수행하고, iOS/Android/Web 플랫폼별 빌드 설정 및 배포 파이프라인을 구축하여 프로덕션 환경에 배포 가능한 상태로 완성합니다.",
        "details": "## 1. E2E 통합 테스트 구축\n\n### 1.1 테스트 패키지 설치 (pubspec.yaml)\n```yaml\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n  integration_test:\n    sdk: flutter\n  patrol: ^3.0.0                    # 고급 E2E 테스트 프레임워크\n  mocktail: ^1.0.0                  # Mock 테스트\n  flutter_driver:                   # Integration 테스트\n    sdk: flutter\n```\n\n### 1.2 근로자용 모바일 앱 E2E 테스트\n**위치:** `integration_test/employee_app_test.dart`\n```dart\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:integration_test/integration_test.dart';\nimport 'package:lms_mobile/main.dart' as app;\n\nvoid main() {\n  IntegrationTestWidgetsFlutterBinding.ensureInitialized();\n\n  group('근로자 앱 E2E 테스트', () {\n    testWidgets('로그인 → 출근 → 근무 일정 조회 → 퇴근 플로우', (tester) async {\n      app.main();\n      await tester.pumpAndSettle();\n\n      // 1. 로그인\n      await tester.enterText(find.byKey(Key('email_field')), 'employee@test.com');\n      await tester.enterText(find.byKey(Key('password_field')), 'password123');\n      await tester.tap(find.byKey(Key('login_button')));\n      await tester.pumpAndSettle();\n\n      // 2. 출근 체크\n      expect(find.text('출근하기'), findsOneWidget);\n      await tester.tap(find.byKey(Key('check_in_button')));\n      await tester.pumpAndSettle();\n      \n      expect(find.text('출근 완료'), findsOneWidget);\n\n      // 3. 근무 일정 조회\n      await tester.tap(find.byIcon(Icons.calendar_today));\n      await tester.pumpAndSettle();\n      expect(find.text('근무 일정'), findsOneWidget);\n\n      // 4. 퇴근 체크\n      await tester.tap(find.byKey(Key('check_out_button')));\n      await tester.pumpAndSettle();\n      expect(find.text('퇴근 완료'), findsOneWidget);\n    });\n\n    testWidgets('휴가 신청 → 승인 대기 플로우', (tester) async {\n      app.main();\n      await tester.pumpAndSettle();\n\n      // 로그인 후 휴가 신청 화면 이동\n      // ... (로그인 로직 생략)\n\n      await tester.tap(find.text('휴가 신청'));\n      await tester.pumpAndSettle();\n\n      // 휴가 유형 선택\n      await tester.tap(find.text('연차'));\n      await tester.pumpAndSettle();\n\n      // 날짜 선택\n      await tester.tap(find.byKey(Key('start_date_picker')));\n      // ... 날짜 선택 로직\n\n      await tester.tap(find.byKey(Key('submit_leave_request')));\n      await tester.pumpAndSettle();\n\n      expect(find.text('휴가 신청이 완료되었습니다'), findsOneWidget);\n    });\n  });\n}\n```\n\n### 1.3 관리자용 웹 어드민 E2E 테스트\n**위치:** `integration_test/admin_web_test.dart`\n```dart\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:integration_test/integration_test.dart';\nimport 'package:lms_mobile/main.dart' as app;\n\nvoid main() {\n  IntegrationTestWidgetsFlutterBinding.ensureInitialized();\n\n  group('관리자 웹 E2E 테스트', () {\n    testWidgets('매니저 로그인 → 근로자 등록 → 근무 일정 생성 플로우', (tester) async {\n      app.main();\n      await tester.pumpAndSettle();\n\n      // 1. 매니저 로그인\n      await tester.enterText(find.byKey(Key('email_field')), 'manager@test.com');\n      await tester.enterText(find.byKey(Key('password_field')), 'password123');\n      await tester.tap(find.byKey(Key('login_button')));\n      await tester.pumpAndSettle();\n\n      // 2. 근로자 관리 메뉴 클릭\n      await tester.tap(find.text('근로자 관리'));\n      await tester.pumpAndSettle();\n\n      // 3. 근로자 등록\n      await tester.tap(find.byKey(Key('add_employee_button')));\n      await tester.pumpAndSettle();\n\n      await tester.enterText(find.byKey(Key('employee_name')), '홍길동');\n      await tester.enterText(find.byKey(Key('employee_email')), 'hong@test.com');\n      await tester.tap(find.byKey(Key('submit_employee')));\n      await tester.pumpAndSettle();\n\n      expect(find.text('근로자가 등록되었습니다'), findsOneWidget);\n\n      // 4. 근무 일정 생성\n      await tester.tap(find.text('근무 일정 관리'));\n      await tester.pumpAndSettle();\n\n      await tester.tap(find.byKey(Key('create_schedule_button')));\n      // ... 일정 생성 로직\n    });\n\n    testWidgets('출퇴근 기록 수정 플로우', (tester) async {\n      // ... 출퇴근 기록 조회 및 수정 테스트\n    });\n\n    testWidgets('휴가 승인/거부 플로우', (tester) async {\n      // ... 휴가 승인/거부 테스트\n    });\n  });\n}\n```\n\n### 1.4 API 통신 통합 테스트\n**위치:** `integration_test/api_integration_test.dart`\n```dart\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:lms_mobile/core/network/api_client.dart';\n\nvoid main() {\n  group('API 통합 테스트', () {\n    late ApiClient apiClient;\n\n    setUp(() {\n      apiClient = ApiClient(baseUrl: 'http://localhost:8080');\n    });\n\n    test('로그인 API 호출 성공', () async {\n      final response = await apiClient.post('/api/auth/login', data: {\n        'email': 'test@example.com',\n        'password': 'password123'\n      });\n\n      expect(response.statusCode, 200);\n      expect(response.data['accessToken'], isNotNull);\n    });\n\n    test('JWT 토큰 갱신 성공', () async {\n      // ... 토큰 갱신 테스트\n    });\n\n    test('출근 체크 API 호출 성공', () async {\n      // ... 출근 테스트\n    });\n  });\n}\n```\n\n---\n\n## 2. 보안 검증\n\n### 2.1 JWT 토큰 보안 검증\n**위치:** `test/security/jwt_security_test.dart`\n```dart\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:lms_mobile/core/auth/token_manager.dart';\n\nvoid main() {\n  group('JWT 보안 검증', () {\n    late TokenManager tokenManager;\n\n    setUp(() {\n      tokenManager = TokenManager();\n    });\n\n    test('만료된 토큰 자동 갱신', () async {\n      // Given: 만료된 토큰\n      await tokenManager.saveAccessToken('expired.jwt.token');\n\n      // When: API 호출 시 자동 갱신\n      final isValid = await tokenManager.isTokenValid();\n\n      // Then: 새로운 토큰 발급\n      expect(isValid, false);\n      // 토큰 갱신 로직 검증\n    });\n\n    test('안전한 토큰 저장 (flutter_secure_storage)', () async {\n      // Given\n      const testToken = 'test.jwt.token';\n\n      // When\n      await tokenManager.saveAccessToken(testToken);\n      final retrievedToken = await tokenManager.getAccessToken();\n\n      // Then\n      expect(retrievedToken, testToken);\n    });\n\n    test('로그아웃 시 토큰 완전 삭제', () async {\n      // Given\n      await tokenManager.saveAccessToken('test.token');\n      await tokenManager.saveRefreshToken('refresh.token');\n\n      // When\n      await tokenManager.clearTokens();\n\n      // Then\n      final accessToken = await tokenManager.getAccessToken();\n      final refreshToken = await tokenManager.getRefreshToken();\n      expect(accessToken, isNull);\n      expect(refreshToken, isNull);\n    });\n  });\n}\n```\n\n### 2.2 입력 검증 및 XSS 방지\n**위치:** `test/security/input_validation_test.dart`\n```dart\nimport 'package:flutter_test/flutter_test.dart';\n\nvoid main() {\n  group('입력 검증 테스트', () {\n    test('이메일 형식 검증', () {\n      expect(isValidEmail('test@example.com'), true);\n      expect(isValidEmail('invalid-email'), false);\n      expect(isValidEmail('<script>alert(\"XSS\")</script>@test.com'), false);\n    });\n\n    test('SQL Injection 방지 (파라미터 바인딩 확인)', () {\n      // Flutter에서는 서버로 보내는 데이터만 검증\n      final maliciousInput = \"'; DROP TABLE users; --\";\n      expect(sanitizeInput(maliciousInput), isNot(contains('DROP TABLE')));\n    });\n\n    test('비밀번호 강도 검증', () {\n      expect(isStrongPassword('12345678'), false);\n      expect(isStrongPassword('Password123!'), true);\n    });\n  });\n}\n```\n\n### 2.3 권한 검증 테스트\n```dart\ntest('SUPER_ADMIN만 매장 관리 화면 접근 가능', () async {\n  // Given: MANAGER 권한으로 로그인\n  final authProvider = AuthProvider();\n  await authProvider.login('manager@test.com', 'password');\n\n  // When: 매장 관리 화면 접근 시도\n  final canAccess = authProvider.hasRole('SUPER_ADMIN');\n\n  // Then: 접근 거부\n  expect(canAccess, false);\n});\n```\n\n---\n\n## 3. 성능 최적화\n\n### 3.1 번들 크기 최적화\n```bash\n# Flutter 웹 빌드 최적화 (tree-shaking, code splitting)\nflutter build web --release --tree-shake-icons --split-debug-info=build/debug-info\n\n# APK 크기 분석\nflutter build apk --analyze-size\n\n# iOS IPA 크기 분석\nflutter build ios --release --analyze-size\n```\n\n### 3.2 이미지 최적화\n**위치:** `pubspec.yaml`\n```yaml\nflutter:\n  assets:\n    - assets/images/         # 이미지 최적화 (WebP 포맷 권장)\n    - assets/icons/\n\n# 이미지 캐싱 패키지\ndependencies:\n  cached_network_image: ^3.3.0\n```\n\n**사용 예시:**\n```dart\nCachedNetworkImage(\n  imageUrl: 'https://example.com/image.png',\n  placeholder: (context, url) => CircularProgressIndicator(),\n  errorWidget: (context, url, error) => Icon(Icons.error),\n  cacheKey: 'unique_image_key',\n  maxWidthDiskCache: 800,\n  maxHeightDiskCache: 800,\n)\n```\n\n### 3.3 레이지 로딩 및 페이지네이션\n```dart\n// 근무 일정 무한 스크롤 구현\nclass WorkScheduleListView extends StatefulWidget {\n  @override\n  _WorkScheduleListViewState createState() => _WorkScheduleListViewState();\n}\n\nclass _WorkScheduleListViewState extends State<WorkScheduleListView> {\n  final ScrollController _scrollController = ScrollController();\n  List<WorkSchedule> schedules = [];\n  int currentPage = 0;\n  bool isLoading = false;\n\n  @override\n  void initState() {\n    super.initState();\n    _scrollController.addListener(_onScroll);\n    _loadSchedules();\n  }\n\n  void _onScroll() {\n    if (_scrollController.position.pixels == _scrollController.position.maxScrollExtent) {\n      _loadSchedules();\n    }\n  }\n\n  Future<void> _loadSchedules() async {\n    if (isLoading) return;\n    setState(() => isLoading = true);\n\n    final newSchedules = await fetchSchedules(page: currentPage);\n    setState(() {\n      schedules.addAll(newSchedules);\n      currentPage++;\n      isLoading = false;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return ListView.builder(\n      controller: _scrollController,\n      itemCount: schedules.length + (isLoading ? 1 : 0),\n      itemBuilder: (context, index) {\n        if (index == schedules.length) {\n          return Center(child: CircularProgressIndicator());\n        }\n        return WorkScheduleTile(schedule: schedules[index]);\n      },\n    );\n  }\n}\n```\n\n### 3.4 빌드 성능 측정 및 프로파일링\n```bash\n# Flutter 성능 프로파일링\nflutter run --profile\n\n# DevTools 실행하여 성능 분석\nflutter pub global activate devtools\nflutter pub global run devtools\n```\n\n---\n\n## 4. iOS 빌드 설정 및 배포\n\n### 4.1 iOS 프로젝트 설정\n**위치:** `ios/Runner/Info.plist`\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n    <key>CFBundleDisplayName</key>\n    <string>LMS 근태 관리</string>\n    \n    <key>CFBundleIdentifier</key>\n    <string>com.lms.mobile</string>\n    \n    <key>CFBundleVersion</key>\n    <string>1</string>\n    \n    <key>CFBundleShortVersionString</key>\n    <string>1.0.0</string>\n    \n    <!-- 권한 설정 -->\n    <key>NSLocationWhenInUseUsageDescription</key>\n    <string>출퇴근 기록 시 위치 정보가 필요합니다.</string>\n    \n    <key>NSCameraUsageDescription</key>\n    <string>프로필 사진 업로드를 위해 카메라 권한이 필요합니다.</string>\n</dict>\n</plist>\n```\n\n### 4.2 iOS 빌드 및 TestFlight 배포\n```bash\n# iOS 프로덕션 빌드\nflutter build ios --release\n\n# Archive 생성 (Xcode에서 수동 또는 fastlane 사용)\ncd ios\nfastlane init\n\n# Fastfile 설정 (ios/fastlane/Fastfile)\ndefault_platform(:ios)\n\nplatform :ios do\n  desc \"Push to TestFlight\"\n  lane :beta do\n    build_app(scheme: \"Runner\")\n    upload_to_testflight\n  end\n\n  desc \"Release to App Store\"\n  lane :release do\n    build_app(scheme: \"Runner\")\n    upload_to_app_store\n  end\nend\n\n# TestFlight 배포\nfastlane beta\n```\n\n### 4.3 iOS 서명 및 프로비저닝 프로파일\n```bash\n# match를 사용한 코드 서명 관리\nfastlane match init\nfastlane match appstore\nfastlane match development\n```\n\n---\n\n## 5. Android 빌드 설정 및 배포\n\n### 5.1 Android 프로젝트 설정\n**위치:** `android/app/build.gradle`\n```gradle\nandroid {\n    namespace \"com.lms.mobile\"\n    compileSdkVersion 34\n\n    defaultConfig {\n        applicationId \"com.lms.mobile\"\n        minSdkVersion 21\n        targetSdkVersion 34\n        versionCode 1\n        versionName \"1.0.0\"\n    }\n\n    signingConfigs {\n        release {\n            keyAlias keystoreProperties['keyAlias']\n            keyPassword keystoreProperties['keyPassword']\n            storeFile keystoreProperties['storeFile'] ? file(keystoreProperties['storeFile']) : null\n            storePassword keystoreProperties['storePassword']\n        }\n    }\n\n    buildTypes {\n        release {\n            signingConfig signingConfigs.release\n            minifyEnabled true\n            shrinkResources true\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n```\n\n### 5.2 Keystore 생성 및 서명 설정\n```bash\n# Keystore 생성\nkeytool -genkey -v -keystore ~/lms-release-key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias lms\n\n# android/key.properties 파일 생성\nstorePassword=your-store-password\nkeyPassword=your-key-password\nkeyAlias=lms\nstoreFile=/path/to/lms-release-key.jks\n```\n\n**위치:** `android/app/build.gradle` (key.properties 로드)\n```gradle\ndef keystoreProperties = new Properties()\ndef keystorePropertiesFile = rootProject.file('key.properties')\nif (keystorePropertiesFile.exists()) {\n    keystoreProperties.load(new FileInputStream(keystorePropertiesFile))\n}\n```\n\n### 5.3 Android 프로덕션 빌드 및 배포\n```bash\n# APK 빌드\nflutter build apk --release\n\n# App Bundle 빌드 (Google Play 권장)\nflutter build appbundle --release\n\n# 빌드 파일 위치\n# APK: build/app/outputs/flutter-apk/app-release.apk\n# AAB: build/app/outputs/bundle/release/app-release.aab\n```\n\n### 5.4 Google Play Console 배포\n```bash\n# Fastlane을 사용한 자동 배포\ncd android\nfastlane init\n\n# Fastfile 설정 (android/fastlane/Fastfile)\ndefault_platform(:android)\n\nplatform :android do\n  desc \"Deploy to Google Play Internal Track\"\n  lane :internal do\n    gradle(task: \"bundle\", build_type: 'Release')\n    upload_to_play_store(track: 'internal')\n  end\n\n  desc \"Deploy to Google Play Production\"\n  lane :production do\n    gradle(task: \"bundle\", build_type: 'Release')\n    upload_to_play_store(track: 'production')\n  end\nend\n\n# Internal Track 배포\nfastlane internal\n```\n\n---\n\n## 6. Web 빌드 설정 및 배포\n\n### 6.1 Flutter Web 프로덕션 빌드\n```bash\n# Web 빌드 (관리자 어드민용)\nflutter build web --release --web-renderer canvaskit\n\n# 빌드 결과물: build/web/\n```\n\n### 6.2 Web 최적화 설정\n**위치:** `web/index.html`\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>LMS 관리자 어드민</title>\n  \n  <!-- PWA 설정 -->\n  <link rel=\"manifest\" href=\"manifest.json\">\n  <meta name=\"apple-mobile-web-app-capable\" content=\"yes\">\n  <meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\">\n  <meta name=\"apple-mobile-web-app-title\" content=\"LMS Admin\">\n  \n  <!-- 파비콘 -->\n  <link rel=\"icon\" type=\"image/png\" href=\"favicon.png\"/>\n  \n  <!-- 로딩 스피너 -->\n  <style>\n    .loading {\n      display: flex;\n      justify-content: center;\n      align-items: center;\n      height: 100vh;\n    }\n  </style>\n</head>\n<body>\n  <div class=\"loading\">\n    <p>로딩 중...</p>\n  </div>\n  <script src=\"main.dart.js\" type=\"application/javascript\"></script>\n</body>\n</html>\n```\n\n### 6.3 Nginx 배포 설정\n**위치:** `nginx.conf`\n```nginx\nserver {\n    listen 80;\n    server_name lms-admin.example.com;\n\n    root /var/www/lms-admin/build/web;\n    index index.html;\n\n    # Gzip 압축\n    gzip on;\n    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;\n\n    # 캐싱 설정\n    location / {\n        try_files $uri $uri/ /index.html;\n        add_header Cache-Control \"no-cache\";\n    }\n\n    location ~* \\.(js|css|png|jpg|jpeg|gif|ico|woff|woff2|ttf|svg)$ {\n        expires 1y;\n        add_header Cache-Control \"public, immutable\";\n    }\n\n    # HTTPS 리다이렉트 (프로덕션)\n    # return 301 https://$server_name$request_uri;\n}\n\n# HTTPS 설정 (SSL 인증서 적용)\nserver {\n    listen 443 ssl http2;\n    server_name lms-admin.example.com;\n\n    ssl_certificate /etc/ssl/certs/lms-admin.crt;\n    ssl_certificate_key /etc/ssl/private/lms-admin.key;\n\n    root /var/www/lms-admin/build/web;\n    index index.html;\n\n    location / {\n        try_files $uri $uri/ /index.html;\n    }\n}\n```\n\n### 6.4 Docker를 사용한 Web 배포\n**위치:** `Dockerfile.web`\n```dockerfile\n# Stage 1: Flutter 빌드\nFROM ghcr.io/cirruslabs/flutter:3.19.0 AS build\n\nWORKDIR /app\nCOPY pubspec.* ./\nRUN flutter pub get\n\nCOPY . .\nRUN flutter build web --release --web-renderer canvaskit\n\n# Stage 2: Nginx 서빙\nFROM nginx:alpine\n\nCOPY --from=build /app/build/web /usr/share/nginx/html\nCOPY nginx.conf /etc/nginx/conf.d/default.conf\n\nEXPOSE 80\nCMD [\"nginx\", \"-g\", \"daemon off;\"]\n```\n\n**빌드 및 배포:**\n```bash\n# Docker 이미지 빌드\ndocker build -f Dockerfile.web -t lms-admin-web:latest .\n\n# Docker 컨테이너 실행\ndocker run -d -p 80:80 --name lms-admin lms-admin-web:latest\n```\n\n---\n\n## 7. CI/CD 파이프라인 구축 (GitHub Actions)\n\n### 7.1 iOS CI/CD\n**위치:** `.github/workflows/ios.yml`\n```yaml\nname: iOS Build and Deploy\n\non:\n  push:\n    branches: [ main, develop ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  build-ios:\n    runs-on: macos-latest\n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Setup Flutter\n        uses: subosito/flutter-action@v2\n        with:\n          flutter-version: '3.19.0'\n          channel: 'stable'\n      \n      - name: Install dependencies\n        run: flutter pub get\n      \n      - name: Run tests\n        run: flutter test\n      \n      - name: Run integration tests\n        run: flutter test integration_test\n      \n      - name: Build iOS\n        run: flutter build ios --release --no-codesign\n      \n      - name: Deploy to TestFlight\n        if: github.ref == 'refs/heads/main'\n        env:\n          FASTLANE_APPLE_ID: ${{ secrets.APPLE_ID }}\n          FASTLANE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}\n        run: |\n          cd ios\n          fastlane beta\n```\n\n### 7.2 Android CI/CD\n**위치:** `.github/workflows/android.yml`\n```yaml\nname: Android Build and Deploy\n\non:\n  push:\n    branches: [ main, develop ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  build-android:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Setup Java\n        uses: actions/setup-java@v3\n        with:\n          distribution: 'zulu'\n          java-version: '17'\n      \n      - name: Setup Flutter\n        uses: subosito/flutter-action@v2\n        with:\n          flutter-version: '3.19.0'\n          channel: 'stable'\n      \n      - name: Install dependencies\n        run: flutter pub get\n      \n      - name: Run tests\n        run: flutter test\n      \n      - name: Run integration tests\n        run: flutter test integration_test\n      \n      - name: Decode Keystore\n        run: |\n          echo \"${{ secrets.KEYSTORE_BASE64 }}\" | base64 --decode > android/app/release.jks\n      \n      - name: Create key.properties\n        run: |\n          echo \"storePassword=${{ secrets.KEYSTORE_PASSWORD }}\" > android/key.properties\n          echo \"keyPassword=${{ secrets.KEY_PASSWORD }}\" >> android/key.properties\n          echo \"keyAlias=${{ secrets.KEY_ALIAS }}\" >> android/key.properties\n          echo \"storeFile=release.jks\" >> android/key.properties\n      \n      - name: Build App Bundle\n        run: flutter build appbundle --release\n      \n      - name: Deploy to Google Play Internal Track\n        if: github.ref == 'refs/heads/main'\n        uses: r0adkll/upload-google-play@v1\n        with:\n          serviceAccountJsonPlainText: ${{ secrets.PLAY_STORE_SERVICE_ACCOUNT }}\n          packageName: com.lms.mobile\n          releaseFiles: build/app/outputs/bundle/release/app-release.aab\n          track: internal\n```\n\n### 7.3 Web CI/CD\n**위치:** `.github/workflows/web.yml`\n```yaml\nname: Web Build and Deploy\n\non:\n  push:\n    branches: [ main, develop ]\n\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Setup Flutter\n        uses: subosito/flutter-action@v2\n        with:\n          flutter-version: '3.19.0'\n          channel: 'stable'\n      \n      - name: Install dependencies\n        run: flutter pub get\n      \n      - name: Run tests\n        run: flutter test\n      \n      - name: Build Web\n        run: flutter build web --release --web-renderer canvaskit\n      \n      - name: Deploy to Firebase Hosting (또는 Vercel, Netlify)\n        uses: FirebaseExtended/action-hosting-deploy@v0\n        with:\n          repoToken: '${{ secrets.GITHUB_TOKEN }}'\n          firebaseServiceAccount: '${{ secrets.FIREBASE_SERVICE_ACCOUNT }}'\n          channelId: live\n          projectId: lms-admin\n```\n\n---\n\n## 8. 환경별 빌드 설정 (Dev/Staging/Production)\n\n### 8.1 환경별 .env 파일 관리\n```\n.env.development\n.env.staging\n.env.production\n```\n\n### 8.2 빌드 스크립트\n**위치:** `scripts/build.sh`\n```bash\n#!/bin/bash\n\nENV=$1\n\nif [ \"$ENV\" == \"dev\" ]; then\n  cp .env.development .env\nelif [ \"$ENV\" == \"staging\" ]; then\n  cp .env.staging .env\nelif [ \"$ENV\" == \"production\" ]; then\n  cp .env.production .env\nelse\n  echo \"Usage: ./build.sh [dev|staging|production]\"\n  exit 1\nfi\n\nflutter pub get\nflutter build apk --release\nflutter build appbundle --release\nflutter build ios --release\nflutter build web --release\n```\n\n**사용 예시:**\n```bash\nchmod +x scripts/build.sh\n./scripts/build.sh production\n```\n\n---\n\n## 9. 모니터링 및 에러 추적\n\n### 9.1 Sentry 통합 (에러 추적)\n**위치:** `pubspec.yaml`\n```yaml\ndependencies:\n  sentry_flutter: ^7.0.0\n```\n\n**위치:** `lib/main.dart`\n```dart\nimport 'package:sentry_flutter/sentry_flutter.dart';\n\nFuture<void> main() async {\n  await SentryFlutter.init(\n    (options) {\n      options.dsn = 'https://your-sentry-dsn@sentry.io/project-id';\n      options.tracesSampleRate = 1.0;\n      options.environment = const String.fromEnvironment('ENV', defaultValue: 'production');\n    },\n    appRunner: () => runApp(MyApp()),\n  );\n}\n```\n\n### 9.2 Firebase Analytics (사용자 행동 분석)\n```yaml\ndependencies:\n  firebase_analytics: ^10.0.0\n```\n\n```dart\nfinal FirebaseAnalytics analytics = FirebaseAnalytics.instance;\n\n// 이벤트 로깅\nanalytics.logEvent(\n  name: 'check_in',\n  parameters: {'employee_id': 'emp-001'},\n);\n```\n\n---\n\n## 10. 프로덕션 체크리스트\n\n### 배포 전 최종 검증 항목\n- [ ] E2E 테스트 모두 통과\n- [ ] 보안 검증 완료 (JWT, 입력 검증, 권한 체크)\n- [ ] 성능 테스트 완료 (번들 크기, 로딩 속도, 메모리 사용량)\n- [ ] iOS TestFlight 베타 테스트 완료\n- [ ] Android Internal Track 테스트 완료\n- [ ] Web 프로덕션 환경 배포 및 테스트 완료\n- [ ] 에러 추적 시스템 (Sentry) 설정 완료\n- [ ] CI/CD 파이프라인 정상 작동 확인\n- [ ] 환경 변수 (Production) 설정 검증\n- [ ] SSL 인증서 적용 (Web)\n- [ ] 앱 스토어 메타데이터 (스크린샷, 설명) 준비 완료",
        "testStrategy": "## 테스트 전략\n\n### 1. E2E 통합 테스트 실행 및 검증\n```bash\n# 모든 통합 테스트 실행\nflutter test integration_test\n\n# 특정 플랫폼 테스트\nflutter test integration_test/employee_app_test.dart\nflutter test integration_test/admin_web_test.dart\nflutter test integration_test/api_integration_test.dart\n```\n\n**검증 항목:**\n- ✅ 근로자 앱: 로그인 → 출퇴근 → 근무 일정 조회 → 휴가 신청 플로우 정상 작동\n- ✅ 관리자 웹: 로그인 → 근로자 관리 → 근무 일정 생성 → 출퇴근 기록 수정 플로우 정상 작동\n- ✅ API 통신: 모든 REST API 엔드포인트 정상 응답 및 에러 처리 확인\n- ✅ 토큰 갱신: JWT 토큰 만료 시 자동 갱신 동작 확인\n\n---\n\n### 2. 보안 검증 테스트\n```bash\n# 보안 테스트 실행\nflutter test test/security/\n```\n\n**검증 항목:**\n- ✅ JWT 토큰 안전 저장: `flutter_secure_storage` 사용 확인\n- ✅ 토큰 만료 시 자동 로그아웃 및 재로그인 유도\n- ✅ 입력 검증: 이메일, 비밀번호, SQL Injection 방지 확인\n- ✅ 권한 체크: SUPER_ADMIN, MANAGER, EMPLOYEE 권한별 화면 접근 제어 확인\n- ✅ HTTPS 통신: 프로덕션 환경에서 모든 API 호출이 HTTPS로 이루어지는지 확인\n\n---\n\n### 3. 성능 최적화 검증\n```bash\n# 성능 프로파일링\nflutter run --profile\nflutter pub global run devtools\n\n# 번들 크기 분석\nflutter build apk --analyze-size\nflutter build ios --analyze-size\nflutter build web --release\n```\n\n**검증 항목:**\n- ✅ **앱 크기**: Android APK < 20MB, iOS IPA < 30MB, Web 번들 < 5MB\n- ✅ **초기 로딩 시간**: 모바일 앱 < 3초, 웹 어드민 < 5초\n- ✅ **메모리 사용량**: 앱 실행 중 메모리 < 150MB\n- ✅ **네트워크 요청**: API 응답 시간 < 500ms (평균)\n- ✅ **이미지 최적화**: 모든 이미지 WebP 포맷 또는 캐싱 적용 확인\n- ✅ **무한 스크롤**: 근무 일정, 출퇴근 기록 리스트에서 페이지네이션 정상 작동\n\n---\n\n### 4. iOS 빌드 및 배포 검증\n```bash\n# iOS 빌드 테스트\nflutter build ios --release\n\n# Fastlane을 통한 TestFlight 배포\ncd ios\nfastlane beta\n```\n\n**검증 항목:**\n- ✅ Xcode에서 빌드 오류 없음\n- ✅ Info.plist 설정 완료 (권한, Bundle ID, Version)\n- ✅ 코드 서명 및 프로비저닝 프로파일 정상 적용\n- ✅ TestFlight 업로드 성공\n- ✅ TestFlight 베타 테스터가 앱 다운로드 및 실행 가능\n- ✅ iOS 실제 기기에서 로그인, 출퇴근 기능 정상 작동\n\n---\n\n### 5. Android 빌드 및 배포 검증\n```bash\n# Android 빌드 테스트\nflutter build apk --release\nflutter build appbundle --release\n\n# Fastlane을 통한 Google Play Internal Track 배포\ncd android\nfastlane internal\n```\n\n**검증 항목:**\n- ✅ Gradle 빌드 오류 없음\n- ✅ Keystore 서명 정상 적용\n- ✅ ProGuard 최적화 적용 확인\n- ✅ Google Play Console Internal Track 업로드 성공\n- ✅ Internal Track 테스터가 앱 다운로드 및 설치 가능\n- ✅ Android 실제 기기에서 로그인, 출퇴근 기능 정상 작동\n\n---\n\n### 6. Web 빌드 및 배포 검증\n```bash\n# Web 빌드 테스트\nflutter build web --release --web-renderer canvaskit\n\n# Docker 빌드 및 로컬 테스트\ndocker build -f Dockerfile.web -t lms-admin-web:latest .\ndocker run -d -p 8080:80 lms-admin-web:latest\n```\n\n**검증 항목:**\n- ✅ Web 빌드 완료 (build/web/ 디렉토리 생성)\n- ✅ Nginx 또는 Docker 컨테이너로 로컬 서빙 성공\n- ✅ 브라우저에서 http://localhost:8080 접속 시 관리자 로그인 화면 표시\n- ✅ PWA 기능 작동 (오프라인 캐싱, 홈 화면 추가)\n- ✅ 반응형 레이아웃: 데스크톱/태블릿/모바일 화면 모두 정상 표시\n- ✅ HTTPS 적용 (프로덕션 환경)\n- ✅ Firebase Hosting 또는 Vercel 배포 성공\n\n---\n\n### 7. CI/CD 파이프라인 검증\n```bash\n# GitHub Actions 워크플로우 트리거\ngit push origin main\n```\n\n**검증 항목:**\n- ✅ GitHub Actions 워크플로우 정상 실행 (iOS, Android, Web)\n- ✅ 모든 단위 테스트 및 통합 테스트 통과\n- ✅ iOS TestFlight 자동 배포 성공\n- ✅ Android Google Play Internal Track 자동 배포 성공\n- ✅ Web Firebase Hosting 또는 Vercel 자동 배포 성공\n- ✅ 빌드 실패 시 Slack 또는 이메일 알림 전송\n\n---\n\n### 8. 환경별 빌드 검증 (Dev/Staging/Production)\n```bash\n# Dev 환경 빌드\n./scripts/build.sh dev\n\n# Staging 환경 빌드\n./scripts/build.sh staging\n\n# Production 환경 빌드\n./scripts/build.sh production\n```\n\n**검증 항목:**\n- ✅ Dev 환경: 개발 서버 API (http://localhost:8080) 호출 확인\n- ✅ Staging 환경: 스테이징 서버 API 호출 확인\n- ✅ Production 환경: 프로덕션 서버 API (https://api.lms.com) 호출 확인\n- ✅ 환경별 .env 파일 정상 로드 및 API Base URL 변경 확인\n\n---\n\n### 9. 에러 추적 및 모니터링 검증\n```bash\n# 에러 발생 시뮬레이션\nthrow Exception('Test error for Sentry');\n```\n\n**검증 항목:**\n- ✅ Sentry 대시보드에서 에러 로그 확인\n- ✅ Firebase Analytics에서 사용자 이벤트 (로그인, 출근, 퇴근) 확인\n- ✅ Crashlytics에서 앱 크래시 리포트 확인\n- ✅ 에러 발생 시 사용자에게 친화적인 메시지 표시\n\n---\n\n### 10. 프로덕션 체크리스트 최종 검증\n\n**배포 전 최종 점검:**\n- [ ] ✅ E2E 테스트 100% 통과\n- [ ] ✅ 보안 검증 완료 (JWT, 권한, 입력 검증)\n- [ ] ✅ 성능 테스트 통과 (앱 크기, 로딩 속도, 메모리)\n- [ ] ✅ iOS TestFlight 베타 테스트 완료 (최소 10명 이상)\n- [ ] ✅ Android Internal Track 테스트 완료 (최소 10명 이상)\n- [ ] ✅ Web 프로덕션 배포 완료 및 HTTPS 적용\n- [ ] ✅ CI/CD 파이프라인 정상 작동 (3회 이상 배포 성공)\n- [ ] ✅ Sentry/Firebase Analytics 모니터링 시스템 가동\n- [ ] ✅ 앱 스토어 메타데이터 준비 (스크린샷, 설명, 키워드)\n- [ ] ✅ 배포 롤백 계획 수립\n\n**최종 승인:**\n- [ ] QA 팀 승인\n- [ ] 제품 책임자(PO) 승인\n- [ ] 개발팀 리드 승인\n\n**배포 후 모니터링 (첫 24시간):**\n- [ ] Sentry에서 새로운 에러 발생 여부 모니터링\n- [ ] Firebase Analytics에서 사용자 활동 추적\n- [ ] 앱 스토어 리뷰 및 사용자 피드백 수집\n- [ ] 서버 부하 및 응답 시간 모니터링",
        "status": "pending",
        "dependencies": [
          "14",
          "15"
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": "17",
        "title": "관리자용 웹 어드민 구현",
        "description": "Flutter Web을 활용하여 관리자가 사용할 웹 기반 어드민 대시보드를 구현합니다. 매장 관리, 근로자 관리, 근무 일정, 출퇴근 기록, 휴가 승인, 급여 조회 등 모든 관리 기능을 제공합니다.",
        "details": "## 1. 프로젝트 구조 설정\n\nFlutter 프로젝트 내에서 관리자용 웹 어드민 전용 디렉토리 구성:\n\n```\nlib/\n├── features/\n│   └── admin/                       # 관리자용 기능 모음\n│       ├── auth/                    # 관리자 로그인\n│       │   ├── presentation/\n│       │   │   ├── admin_login_screen.dart\n│       │   │   └── admin_login_provider.dart\n│       │   └── domain/\n│       │       └── models/\n│       │           └── admin_user.dart\n│       ├── dashboard/               # 대시보드\n│       │   ├── presentation/\n│       │   │   ├── dashboard_screen.dart\n│       │   │   ├── widgets/\n│       │   │   │   ├── store_stats_card.dart\n│       │   │   │   ├── attendance_summary_widget.dart\n│       │   │   │   └── recent_activities_widget.dart\n│       │   │   └── dashboard_provider.dart\n│       │   └── domain/\n│       │       └── models/\n│       │           ├── dashboard_stats.dart\n│       │           └── store_summary.dart\n│       ├── store/                   # 매장 관리\n│       │   ├── presentation/\n│       │   │   ├── store_list_screen.dart\n│       │   │   ├── store_form_screen.dart\n│       │   │   ├── store_detail_screen.dart\n│       │   │   └── store_provider.dart\n│       │   └── domain/\n│       │       └── models/\n│       │           └── store.dart\n│       ├── employee/                # 근로자 관리\n│       │   ├── presentation/\n│       │   │   ├── employee_list_screen.dart\n│       │   │   ├── employee_form_screen.dart\n│       │   │   ├── employee_detail_screen.dart\n│       │   │   └── employee_provider.dart\n│       │   └── domain/\n│       │       └── models/\n│       │           └── employee.dart\n│       ├── work_schedule/           # 근무 일정 관리\n│       │   ├── presentation/\n│       │   │   ├── schedule_calendar_screen.dart\n│       │   │   ├── schedule_form_screen.dart\n│       │   │   ├── widgets/\n│       │   │   │   ├── calendar_view.dart\n│       │   │   │   └── schedule_item.dart\n│       │   │   └── schedule_provider.dart\n│       │   └── domain/\n│       │       └── models/\n│       │           └── work_schedule.dart\n│       ├── attendance/              # 출퇴근 기록 관리\n│       │   ├── presentation/\n│       │   │   ├── attendance_list_screen.dart\n│       │   │   ├── attendance_edit_dialog.dart\n│       │   │   └── attendance_provider.dart\n│       │   └── domain/\n│       │       └── models/\n│       │           └── attendance_record.dart\n│       ├── leave/                   # 휴가 관리\n│       │   ├── presentation/\n│       │   │   ├── leave_request_list_screen.dart\n│       │   │   ├── leave_approval_dialog.dart\n│       │   │   └── leave_provider.dart\n│       │   └── domain/\n│       │       └── models/\n│       │           └── leave_request.dart\n│       └── payroll/                 # 급여 관리\n│           ├── presentation/\n│           │   ├── payroll_list_screen.dart\n│           │   ├── payroll_detail_screen.dart\n│           │   └── payroll_provider.dart\n│           └── domain/\n│               └── models/\n│                   └── payroll.dart\n├── shared/\n│   └── widgets/\n│       ├── admin_layout.dart        # 웹 어드민 레이아웃\n│       ├── admin_sidebar.dart       # 사이드바 네비게이션\n│       ├── admin_app_bar.dart       # 상단 앱바\n│       ├── data_table_widget.dart   # 공통 테이블\n│       └── filter_widget.dart       # 검색/필터\n└── main_web_admin.dart              # 웹 어드민 진입점\n```\n\n---\n\n## 2. 관리자 로그인 구현\n\n### 2.1 로그인 화면\n**위치:** `lib/features/admin/auth/presentation/admin_login_screen.dart`\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'admin_login_provider.dart';\n\nclass AdminLoginScreen extends ConsumerStatefulWidget {\n  const AdminLoginScreen({super.key});\n\n  @override\n  ConsumerState<AdminLoginScreen> createState() => _AdminLoginScreenState();\n}\n\nclass _AdminLoginScreenState extends ConsumerState<AdminLoginScreen> {\n  final _formKey = GlobalKey<FormState>();\n  final _emailController = TextEditingController();\n  final _passwordController = TextEditingController();\n\n  @override\n  void dispose() {\n    _emailController.dispose();\n    _passwordController.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final loginState = ref.watch(adminLoginProvider);\n\n    return Scaffold(\n      body: Center(\n        child: Container(\n          constraints: const BoxConstraints(maxWidth: 400),\n          padding: const EdgeInsets.all(32),\n          child: Card(\n            elevation: 4,\n            child: Padding(\n              padding: const EdgeInsets.all(32),\n              child: Form(\n                key: _formKey,\n                child: Column(\n                  mainAxisSize: MainAxisSize.min,\n                  children: [\n                    Text(\n                      'LMS 관리자 로그인',\n                      style: Theme.of(context).textTheme.headlineMedium,\n                    ),\n                    const SizedBox(height: 32),\n                    TextFormField(\n                      controller: _emailController,\n                      decoration: const InputDecoration(\n                        labelText: '이메일',\n                        prefixIcon: Icon(Icons.email),\n                      ),\n                      validator: (value) {\n                        if (value == null || value.isEmpty) {\n                          return '이메일을 입력하세요';\n                        }\n                        if (!value.contains('@')) {\n                          return '올바른 이메일 형식이 아닙니다';\n                        }\n                        return null;\n                      },\n                    ),\n                    const SizedBox(height: 16),\n                    TextFormField(\n                      controller: _passwordController,\n                      obscureText: true,\n                      decoration: const InputDecoration(\n                        labelText: '비밀번호',\n                        prefixIcon: Icon(Icons.lock),\n                      ),\n                      validator: (value) {\n                        if (value == null || value.isEmpty) {\n                          return '비밀번호를 입력하세요';\n                        }\n                        return null;\n                      },\n                    ),\n                    const SizedBox(height: 24),\n                    if (loginState.isLoading)\n                      const CircularProgressIndicator()\n                    else\n                      SizedBox(\n                        width: double.infinity,\n                        child: ElevatedButton(\n                          onPressed: _handleLogin,\n                          child: const Text('로그인'),\n                        ),\n                      ),\n                    if (loginState.error != null)\n                      Padding(\n                        padding: const EdgeInsets.only(top: 16),\n                        child: Text(\n                          loginState.error!,\n                          style: const TextStyle(color: Colors.red),\n                        ),\n                      ),\n                  ],\n                ),\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n\n  void _handleLogin() async {\n    if (_formKey.currentState!.validate()) {\n      final success = await ref.read(adminLoginProvider.notifier).login(\n            _emailController.text,\n            _passwordController.text,\n          );\n\n      if (success && mounted) {\n        Navigator.of(context).pushReplacementNamed('/admin/dashboard');\n      }\n    }\n  }\n}\n```\n\n### 2.2 로그인 Provider\n**위치:** `lib/features/admin/auth/presentation/admin_login_provider.dart`\n```dart\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport '../../../../core/network/api_client.dart';\nimport '../../../../core/auth/token_manager.dart';\n\nclass AdminLoginState {\n  final bool isLoading;\n  final String? error;\n  final bool isLoggedIn;\n\n  AdminLoginState({\n    this.isLoading = false,\n    this.error,\n    this.isLoggedIn = false,\n  });\n\n  AdminLoginState copyWith({\n    bool? isLoading,\n    String? error,\n    bool? isLoggedIn,\n  }) {\n    return AdminLoginState(\n      isLoading: isLoading ?? this.isLoading,\n      error: error,\n      isLoggedIn: isLoggedIn ?? this.isLoggedIn,\n    );\n  }\n}\n\nclass AdminLoginNotifier extends StateNotifier<AdminLoginState> {\n  final ApiClient _apiClient;\n  final TokenManager _tokenManager;\n\n  AdminLoginNotifier(this._apiClient, this._tokenManager)\n      : super(AdminLoginState());\n\n  Future<bool> login(String email, String password) async {\n    state = state.copyWith(isLoading: true, error: null);\n\n    try {\n      final response = await _apiClient.post(\n        '/api/auth/login',\n        data: {\n          'email': email,\n          'password': password,\n        },\n      );\n\n      final accessToken = response.data['accessToken'];\n      final refreshToken = response.data['refreshToken'];\n      final role = response.data['user']['role'];\n\n      // 관리자 권한 확인\n      if (role != 'STORE_ADMIN' && role != 'SUPER_ADMIN') {\n        state = state.copyWith(\n          isLoading: false,\n          error: '관리자 권한이 필요합니다',\n        );\n        return false;\n      }\n\n      await _tokenManager.saveTokens(accessToken, refreshToken);\n      state = state.copyWith(isLoading: false, isLoggedIn: true);\n      return true;\n    } catch (e) {\n      state = state.copyWith(\n        isLoading: false,\n        error: '로그인 실패: ${e.toString()}',\n      );\n      return false;\n    }\n  }\n\n  Future<void> logout() async {\n    await _tokenManager.clearTokens();\n    state = AdminLoginState();\n  }\n}\n\nfinal adminLoginProvider =\n    StateNotifierProvider<AdminLoginNotifier, AdminLoginState>((ref) {\n  return AdminLoginNotifier(\n    ref.watch(apiClientProvider),\n    ref.watch(tokenManagerProvider),\n  );\n});\n```\n\n---\n\n## 3. 웹 어드민 레이아웃 구현\n\n### 3.1 어드민 레이아웃\n**위치:** `lib/shared/widgets/admin_layout.dart`\n```dart\nimport 'package:flutter/material.dart';\nimport 'admin_sidebar.dart';\nimport 'admin_app_bar.dart';\n\nclass AdminLayout extends StatelessWidget {\n  final Widget child;\n  final String title;\n\n  const AdminLayout({\n    super.key,\n    required this.child,\n    required this.title,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AdminAppBar(title: title),\n      body: Row(\n        children: [\n          const AdminSidebar(),\n          Expanded(\n            child: Padding(\n              padding: const EdgeInsets.all(24),\n              child: child,\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n### 3.2 사이드바 네비게이션\n**위치:** `lib/shared/widgets/admin_sidebar.dart`\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nclass AdminSidebar extends ConsumerWidget {\n  const AdminSidebar({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    return Container(\n      width: 250,\n      color: Theme.of(context).colorScheme.surfaceVariant,\n      child: ListView(\n        children: [\n          const DrawerHeader(\n            decoration: BoxDecoration(\n              color: Colors.blue,\n            ),\n            child: Column(\n              crossAxisAlignment: CrossAxisAlignment.start,\n              children: [\n                Text(\n                  'LMS 관리자',\n                  style: TextStyle(\n                    color: Colors.white,\n                    fontSize: 24,\n                  ),\n                ),\n                SizedBox(height: 8),\n                Text(\n                  'Admin Dashboard',\n                  style: TextStyle(\n                    color: Colors.white70,\n                    fontSize: 14,\n                  ),\n                ),\n              ],\n            ),\n          ),\n          _buildMenuItem(\n            context,\n            icon: Icons.dashboard,\n            label: '대시보드',\n            route: '/admin/dashboard',\n          ),\n          _buildMenuItem(\n            context,\n            icon: Icons.store,\n            label: '매장 관리',\n            route: '/admin/stores',\n          ),\n          _buildMenuItem(\n            context,\n            icon: Icons.people,\n            label: '근로자 관리',\n            route: '/admin/employees',\n          ),\n          _buildMenuItem(\n            context,\n            icon: Icons.calendar_month,\n            label: '근무 일정',\n            route: '/admin/schedules',\n          ),\n          _buildMenuItem(\n            context,\n            icon: Icons.access_time,\n            label: '출퇴근 기록',\n            route: '/admin/attendance',\n          ),\n          _buildMenuItem(\n            context,\n            icon: Icons.beach_access,\n            label: '휴가 관리',\n            route: '/admin/leaves',\n          ),\n          _buildMenuItem(\n            context,\n            icon: Icons.attach_money,\n            label: '급여 관리',\n            route: '/admin/payroll',\n          ),\n          const Divider(),\n          _buildMenuItem(\n            context,\n            icon: Icons.logout,\n            label: '로그아웃',\n            route: '/logout',\n          ),\n        ],\n      ),\n    );\n  }\n\n  Widget _buildMenuItem(\n    BuildContext context, {\n    required IconData icon,\n    required String label,\n    required String route,\n  }) {\n    final currentRoute = ModalRoute.of(context)?.settings.name;\n    final isSelected = currentRoute == route;\n\n    return ListTile(\n      leading: Icon(icon),\n      title: Text(label),\n      selected: isSelected,\n      onTap: () {\n        if (route == '/logout') {\n          // 로그아웃 처리\n          Navigator.of(context).pushReplacementNamed('/admin/login');\n        } else {\n          Navigator.of(context).pushNamed(route);\n        }\n      },\n    );\n  }\n}\n```\n\n---\n\n## 4. 대시보드 구현\n\n### 4.1 대시보드 화면\n**위치:** `lib/features/admin/dashboard/presentation/dashboard_screen.dart`\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport '../../../../shared/widgets/admin_layout.dart';\nimport 'widgets/store_stats_card.dart';\nimport 'widgets/attendance_summary_widget.dart';\nimport 'widgets/recent_activities_widget.dart';\nimport 'dashboard_provider.dart';\n\nclass DashboardScreen extends ConsumerWidget {\n  const DashboardScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final dashboardState = ref.watch(dashboardProvider);\n\n    return AdminLayout(\n      title: '대시보드',\n      child: dashboardState.when(\n        loading: () => const Center(child: CircularProgressIndicator()),\n        error: (error, stack) => Center(child: Text('오류: $error')),\n        data: (stats) => SingleChildScrollView(\n          child: Column(\n            crossAxisAlignment: CrossAxisAlignment.start,\n            children: [\n              // 매장 통계 카드\n              GridView.count(\n                crossAxisCount: 4,\n                shrinkWrap: true,\n                physics: const NeverScrollableScrollPhysics(),\n                mainAxisSpacing: 16,\n                crossAxisSpacing: 16,\n                childAspectRatio: 2,\n                children: [\n                  StoreStatsCard(\n                    title: '전체 매장',\n                    value: stats.totalStores.toString(),\n                    icon: Icons.store,\n                    color: Colors.blue,\n                  ),\n                  StoreStatsCard(\n                    title: '전체 근로자',\n                    value: stats.totalEmployees.toString(),\n                    icon: Icons.people,\n                    color: Colors.green,\n                  ),\n                  StoreStatsCard(\n                    title: '금일 출근',\n                    value: stats.todayAttendance.toString(),\n                    icon: Icons.check_circle,\n                    color: Colors.orange,\n                  ),\n                  StoreStatsCard(\n                    title: '휴가 중',\n                    value: stats.onLeave.toString(),\n                    icon: Icons.beach_access,\n                    color: Colors.purple,\n                  ),\n                ],\n              ),\n              const SizedBox(height: 24),\n              // 출근 현황 요약\n              AttendanceSummaryWidget(summary: stats.attendanceSummary),\n              const SizedBox(height: 24),\n              // 최근 활동\n              RecentActivitiesWidget(activities: stats.recentActivities),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n### 4.2 대시보드 Provider\n**위치:** `lib/features/admin/dashboard/presentation/dashboard_provider.dart`\n```dart\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport '../../../../core/network/api_client.dart';\nimport '../domain/models/dashboard_stats.dart';\n\nfinal dashboardProvider = FutureProvider<DashboardStats>((ref) async {\n  final apiClient = ref.watch(apiClientProvider);\n  final response = await apiClient.get('/api/admin/dashboard/stats');\n  return DashboardStats.fromJson(response.data);\n});\n```\n\n---\n\n## 5. 매장 관리 구현\n\n### 5.1 매장 목록 화면\n**위치:** `lib/features/admin/store/presentation/store_list_screen.dart`\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport '../../../../shared/widgets/admin_layout.dart';\nimport '../../../../shared/widgets/data_table_widget.dart';\nimport 'store_provider.dart';\n\nclass StoreListScreen extends ConsumerWidget {\n  const StoreListScreen({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final storesState = ref.watch(storesProvider);\n\n    return AdminLayout(\n      title: '매장 관리',\n      child: Column(\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n          Row(\n            mainAxisAlignment: MainAxisAlignment.spaceBetween,\n            children: [\n              Text(\n                '매장 목록',\n                style: Theme.of(context).textTheme.headlineSmall,\n              ),\n              ElevatedButton.icon(\n                onPressed: () {\n                  Navigator.of(context).pushNamed('/admin/stores/new');\n                },\n                icon: const Icon(Icons.add),\n                label: const Text('매장 추가'),\n              ),\n            ],\n          ),\n          const SizedBox(height: 16),\n          Expanded(\n            child: storesState.when(\n              loading: () => const Center(child: CircularProgressIndicator()),\n              error: (error, stack) => Center(child: Text('오류: $error')),\n              data: (stores) => DataTableWidget(\n                columns: const [\n                  DataColumn(label: Text('ID')),\n                  DataColumn(label: Text('매장명')),\n                  DataColumn(label: Text('주소')),\n                  DataColumn(label: Text('전화번호')),\n                  DataColumn(label: Text('활성 상태')),\n                  DataColumn(label: Text('작업')),\n                ],\n                rows: stores\n                    .map(\n                      (store) => DataRow(\n                        cells: [\n                          DataCell(Text(store.id)),\n                          DataCell(Text(store.name)),\n                          DataCell(Text(store.address)),\n                          DataCell(Text(store.phone)),\n                          DataCell(\n                            Chip(\n                              label: Text(store.isActive ? '활성' : '비활성'),\n                              backgroundColor: store.isActive\n                                  ? Colors.green.shade100\n                                  : Colors.red.shade100,\n                            ),\n                          ),\n                          DataCell(\n                            Row(\n                              children: [\n                                IconButton(\n                                  icon: const Icon(Icons.edit),\n                                  onPressed: () {\n                                    Navigator.of(context).pushNamed(\n                                      '/admin/stores/${store.id}/edit',\n                                    );\n                                  },\n                                ),\n                                IconButton(\n                                  icon: const Icon(Icons.delete),\n                                  onPressed: () => _confirmDelete(\n                                    context,\n                                    ref,\n                                    store.id,\n                                  ),\n                                ),\n                              ],\n                            ),\n                          ),\n                        ],\n                      ),\n                    )\n                    .toList(),\n              ),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n\n  void _confirmDelete(BuildContext context, WidgetRef ref, String storeId) {\n    showDialog(\n      context: context,\n      builder: (context) => AlertDialog(\n        title: const Text('매장 삭제'),\n        content: const Text('정말 이 매장을 삭제하시겠습니까?'),\n        actions: [\n          TextButton(\n            onPressed: () => Navigator.of(context).pop(),\n            child: const Text('취소'),\n          ),\n          ElevatedButton(\n            onPressed: () {\n              ref.read(storesProvider.notifier).deleteStore(storeId);\n              Navigator.of(context).pop();\n            },\n            style: ElevatedButton.styleFrom(backgroundColor: Colors.red),\n            child: const Text('삭제'),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n---\n\n## 6. 근로자 관리 구현\n\n**위치:** `lib/features/admin/employee/presentation/employee_list_screen.dart`\n- 근로자 목록 조회 (`GET /api/employees`)\n- 근로자 등록 폼 (`POST /api/employees`)\n- 근로자 수정 (`PUT /api/employees/{id}`)\n- 근로자 비활성화 (`DELETE /api/employees/{id}`)\n\n---\n\n## 7. 근무 일정 관리 구현\n\n### 7.1 캘린더 뷰\n**위치:** `lib/features/admin/work_schedule/presentation/schedule_calendar_screen.dart`\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:table_calendar/table_calendar.dart';\nimport '../../../../shared/widgets/admin_layout.dart';\nimport 'schedule_provider.dart';\n\nclass ScheduleCalendarScreen extends ConsumerStatefulWidget {\n  const ScheduleCalendarScreen({super.key});\n\n  @override\n  ConsumerState<ScheduleCalendarScreen> createState() =>\n      _ScheduleCalendarScreenState();\n}\n\nclass _ScheduleCalendarScreenState\n    extends ConsumerState<ScheduleCalendarScreen> {\n  DateTime _selectedDay = DateTime.now();\n  DateTime _focusedDay = DateTime.now();\n\n  @override\n  Widget build(BuildContext context) {\n    final schedulesState = ref.watch(schedulesProvider(_selectedDay));\n\n    return AdminLayout(\n      title: '근무 일정 관리',\n      child: Row(\n        children: [\n          // 캘린더\n          Expanded(\n            flex: 2,\n            child: TableCalendar(\n              firstDay: DateTime.utc(2020, 1, 1),\n              lastDay: DateTime.utc(2030, 12, 31),\n              focusedDay: _focusedDay,\n              selectedDayPredicate: (day) => isSameDay(_selectedDay, day),\n              onDaySelected: (selectedDay, focusedDay) {\n                setState(() {\n                  _selectedDay = selectedDay;\n                  _focusedDay = focusedDay;\n                });\n              },\n              calendarFormat: CalendarFormat.month,\n            ),\n          ),\n          const SizedBox(width: 16),\n          // 선택된 날짜의 일정 목록\n          Expanded(\n            flex: 1,\n            child: Column(\n              crossAxisAlignment: CrossAxisAlignment.start,\n              children: [\n                Text(\n                  '${_selectedDay.year}년 ${_selectedDay.month}월 ${_selectedDay.day}일',\n                  style: Theme.of(context).textTheme.titleLarge,\n                ),\n                const SizedBox(height: 16),\n                ElevatedButton.icon(\n                  onPressed: () => _showAddScheduleDialog(context),\n                  icon: const Icon(Icons.add),\n                  label: const Text('일정 추가'),\n                ),\n                const SizedBox(height: 16),\n                Expanded(\n                  child: schedulesState.when(\n                    loading: () =>\n                        const Center(child: CircularProgressIndicator()),\n                    error: (error, stack) => Center(child: Text('오류: $error')),\n                    data: (schedules) => ListView.builder(\n                      itemCount: schedules.length,\n                      itemBuilder: (context, index) {\n                        final schedule = schedules[index];\n                        return Card(\n                          child: ListTile(\n                            title: Text(schedule.employeeName),\n                            subtitle: Text(\n                              '${schedule.startTime} - ${schedule.endTime}',\n                            ),\n                            trailing: Row(\n                              mainAxisSize: MainAxisSize.min,\n                              children: [\n                                IconButton(\n                                  icon: const Icon(Icons.edit),\n                                  onPressed: () =>\n                                      _showEditScheduleDialog(context, schedule),\n                                ),\n                                IconButton(\n                                  icon: const Icon(Icons.delete),\n                                  onPressed: () =>\n                                      _deleteSchedule(ref, schedule.id),\n                                ),\n                              ],\n                            ),\n                          ),\n                        );\n                      },\n                    ),\n                  ),\n                ),\n              ],\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n\n  void _showAddScheduleDialog(BuildContext context) {\n    // 일정 추가 다이얼로그\n  }\n\n  void _showEditScheduleDialog(BuildContext context, schedule) {\n    // 일정 수정 다이얼로그\n  }\n\n  void _deleteSchedule(WidgetRef ref, String scheduleId) {\n    ref.read(schedulesProvider(_selectedDay).notifier).deleteSchedule(scheduleId);\n  }\n}\n```\n\n---\n\n## 8. 출퇴근 기록 관리 구현\n\n**위치:** `lib/features/admin/attendance/presentation/attendance_list_screen.dart`\n- 출퇴근 기록 조회 (필터: 날짜, 매장, 근로자)\n- 출퇴근 시간 수정 기능\n- 수정 이력 확인\n\n---\n\n## 9. 휴가 관리 구현\n\n**위치:** `lib/features/admin/leave/presentation/leave_request_list_screen.dart`\n- 휴가 신청 목록 조회\n- 승인/거부 처리 (`PUT /api/leave-requests/{id}/approve`, `PUT /api/leave-requests/{id}/reject`)\n- 승인/거부 사유 입력\n\n---\n\n## 10. 급여 관리 구현\n\n**위치:** `lib/features/admin/payroll/presentation/payroll_list_screen.dart`\n- 급여 목록 조회 (`GET /api/payroll?storeId=&employeeId=&year=&month=`)\n- 급여 상세 조회 (`GET /api/payroll/{id}`)\n- 급여 확정 (`PUT /api/payroll/{id}/confirm`)\n\n---\n\n## 11. 반응형 디자인 구현\n\n### 11.1 반응형 레이아웃\n```dart\nclass ResponsiveLayout extends StatelessWidget {\n  final Widget mobile;\n  final Widget tablet;\n  final Widget desktop;\n\n  const ResponsiveLayout({\n    super.key,\n    required this.mobile,\n    required this.tablet,\n    required this.desktop,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    return LayoutBuilder(\n      builder: (context, constraints) {\n        if (constraints.maxWidth < 600) {\n          return mobile;\n        } else if (constraints.maxWidth < 1200) {\n          return tablet;\n        } else {\n          return desktop;\n        }\n      },\n    );\n  }\n}\n```\n\n---\n\n## 12. 라우팅 설정\n\n**위치:** `lib/main_web_admin.dart`\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'features/admin/auth/presentation/admin_login_screen.dart';\nimport 'features/admin/dashboard/presentation/dashboard_screen.dart';\nimport 'features/admin/store/presentation/store_list_screen.dart';\n// ... 기타 import\n\nvoid main() {\n  runApp(\n    const ProviderScope(\n      child: AdminWebApp(),\n    ),\n  );\n}\n\nclass AdminWebApp extends StatelessWidget {\n  const AdminWebApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'LMS 관리자',\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),\n        useMaterial3: true,\n      ),\n      initialRoute: '/admin/login',\n      routes: {\n        '/admin/login': (context) => const AdminLoginScreen(),\n        '/admin/dashboard': (context) => const DashboardScreen(),\n        '/admin/stores': (context) => const StoreListScreen(),\n        '/admin/employees': (context) => const EmployeeListScreen(),\n        '/admin/schedules': (context) => const ScheduleCalendarScreen(),\n        '/admin/attendance': (context) => const AttendanceListScreen(),\n        '/admin/leaves': (context) => const LeaveRequestListScreen(),\n        '/admin/payroll': (context) => const PayrollListScreen(),\n      },\n    );\n  }\n}\n```\n\n---\n\n## 13. 권한 관리\n\n### 13.1 권한 체크 Provider\n**위치:** `lib/core/auth/permission_provider.dart`\n```dart\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'token_manager.dart';\n\nenum Permission {\n  manageStores,      // SUPER_ADMIN만\n  manageEmployees,   // STORE_ADMIN, SUPER_ADMIN\n  manageSchedules,   // STORE_ADMIN, SUPER_ADMIN\n  viewPayroll,       // STORE_ADMIN, SUPER_ADMIN\n}\n\nfinal permissionProvider = Provider<PermissionChecker>((ref) {\n  final tokenManager = ref.watch(tokenManagerProvider);\n  return PermissionChecker(tokenManager);\n});\n\nclass PermissionChecker {\n  final TokenManager _tokenManager;\n\n  PermissionChecker(this._tokenManager);\n\n  Future<bool> hasPermission(Permission permission) async {\n    final role = await _tokenManager.getRole();\n    \n    switch (permission) {\n      case Permission.manageStores:\n        return role == 'SUPER_ADMIN';\n      case Permission.manageEmployees:\n      case Permission.manageSchedules:\n      case Permission.viewPayroll:\n        return role == 'STORE_ADMIN' || role == 'SUPER_ADMIN';\n    }\n  }\n}\n```",
        "testStrategy": "## 테스트 전략\n\n### 1. 관리자 로그인 기능 테스트\n- ✅ STORE_ADMIN 계정으로 로그인 성공\n- ✅ SUPER_ADMIN 계정으로 로그인 성공\n- ✅ EMPLOYEE 계정으로 로그인 시 \"관리자 권한이 필요합니다\" 오류 표시\n- ✅ 잘못된 자격 증명으로 로그인 실패 처리\n- ✅ 토큰 저장 확인 (flutter_secure_storage)\n- ✅ 로그인 후 대시보드로 이동 확인\n\n### 2. 대시보드 기능 테스트\n- ✅ 전체 매장, 근로자, 금일 출근, 휴가 중 통계 표시 확인\n- ✅ 출근 현황 요약 위젯 렌더링 확인\n- ✅ 최근 활동 목록 표시 확인\n- ✅ API 오류 시 에러 메시지 표시 확인\n\n### 3. 매장 관리 기능 테스트\n- ✅ 매장 목록 조회 (`GET /api/stores`)\n- ✅ 매장 추가 폼 유효성 검사 (매장명, 주소, 전화번호)\n- ✅ 매장 등록 성공 (`POST /api/stores`)\n- ✅ 매장 수정 성공 (`PUT /api/stores/{id}`)\n- ✅ 매장 삭제 확인 다이얼로그 표시\n- ✅ 매장 삭제 성공 (`DELETE /api/stores/{id}`)\n- ✅ SUPER_ADMIN만 매장 관리 접근 가능 확인\n\n### 4. 근로자 관리 기능 테스트\n- ✅ 근로자 목록 조회 (`GET /api/employees`)\n- ✅ 근로자 등록 폼 유효성 검사 (이름, 이메일, 전화번호, 매장, 역할)\n- ✅ 근로자 등록 성공 (`POST /api/employees`)\n- ✅ 근로자 정보 수정 성공 (`PUT /api/employees/{id}`)\n- ✅ 근로자 비활성화 성공 (`DELETE /api/employees/{id}`)\n- ✅ 매장별 필터링 기능 동작 확인\n\n### 5. 근무 일정 관리 기능 테스트\n- ✅ 캘린더 렌더링 확인 (TableCalendar)\n- ✅ 날짜 선택 시 해당 날짜의 일정 목록 조회 (`GET /api/work-schedules?date=`)\n- ✅ 일정 추가 다이얼로그 표시 및 유효성 검사\n- ✅ 일정 등록 성공 (`POST /api/work-schedules`)\n- ✅ 일정 수정 성공 (`PUT /api/work-schedules/{id}`)\n- ✅ 일정 삭제 성공 (`DELETE /api/work-schedules/{id}`)\n- ✅ 일정 확정 기능 (`PUT /api/work-schedules/{id}/confirm`)\n\n### 6. 출퇴근 기록 관리 기능 테스트\n- ✅ 출퇴근 기록 목록 조회 (`GET /api/attendance`)\n- ✅ 날짜, 매장, 근로자별 필터링 동작 확인\n- ✅ 출퇴근 시간 수정 다이얼로그 표시\n- ✅ 출퇴근 시간 수정 성공 (`PUT /api/attendance/{id}`)\n- ✅ 수정 이력 조회 확인\n- ✅ 수정 사유 필수 입력 확인\n\n### 7. 휴가 관리 기능 테스트\n- ✅ 휴가 신청 목록 조회 (`GET /api/leave-requests`)\n- ✅ 상태별 필터링 (대기, 승인, 거부) 동작 확인\n- ✅ 휴가 승인 다이얼로그 표시 및 사유 입력\n- ✅ 휴가 승인 성공 (`PUT /api/leave-requests/{id}/approve`)\n- ✅ 휴가 거부 성공 (`PUT /api/leave-requests/{id}/reject`)\n- ✅ 승인/거부 후 목록 새로고침 확인\n\n### 8. 급여 관리 기능 테스트\n- ✅ 급여 목록 조회 (`GET /api/payroll`)\n- ✅ 매장, 근로자, 년/월별 필터링 동작 확인\n- ✅ 급여 상세 조회 (`GET /api/payroll/{id}`)\n- ✅ 급여 상세 정보 표시 (기본급, 수당, 공제액, 실수령액)\n- ✅ 급여 확정 기능 (`PUT /api/payroll/{id}/confirm`)\n- ✅ 확정된 급여는 수정 불가 확인\n\n### 9. 권한 관리 테스트\n- ✅ SUPER_ADMIN: 모든 기능 접근 가능\n- ✅ STORE_ADMIN: 매장 관리 제외 모든 기능 접근 가능\n- ✅ 권한 없는 페이지 접근 시 에러 메시지 표시\n- ✅ 권한에 따라 메뉴 항목 표시/숨김 처리\n\n### 10. 반응형 디자인 테스트\n- ✅ 데스크톱 (1200px 이상): 사이드바 + 메인 콘텐츠 레이아웃\n- ✅ 태블릿 (600-1200px): 축소된 레이아웃\n- ✅ 모바일 (600px 미만): 햄버거 메뉴 + 전체 화면 콘텐츠\n- ✅ 테이블 반응형 스크롤 동작 확인\n\n### 11. API 에러 처리 테스트\n- ✅ 401 Unauthorized 시 로그인 페이지로 리다이렉트\n- ✅ 403 Forbidden 시 권한 없음 메시지 표시\n- ✅ 500 Internal Server Error 시 에러 메시지 표시\n- ✅ 네트워크 오류 시 재시도 안내 표시\n\n### 12. 웹 빌드 및 실행 테스트\n```bash\n# 웹 빌드\nflutter build web --release\n\n# 로컬 실행\nflutter run -d chrome\n\n# 빌드 파일 확인\nls -la build/web/\n```\n\n**검증 항목:**\n- ✅ 빌드 성공 확인\n- ✅ Chrome에서 정상 실행 확인\n- ✅ 모든 라우트 정상 동작 확인\n- ✅ API 통신 정상 동작 확인\n- ✅ 로그아웃 후 재로그인 플로우 확인",
        "status": "pending",
        "dependencies": [
          "14"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "관리자 인증 시스템 구현 (로그인/로그아웃)",
            "description": "Flutter Web에서 Spring Boot 백엔드(/api/auth/login)와 연동하여 관리자 로그인 기능을 구현합니다. STORE_ADMIN/SUPER_ADMIN 권한 검증, JWT 토큰 저장(flutter_secure_storage), 로그인 화면 UI 및 Provider 상태 관리를 포함합니다.",
            "dependencies": [],
            "details": "## 구현 범위\n\n### 1. 로그인 화면 UI\n- **위치**: `lib/features/admin/auth/presentation/admin_login_screen.dart`\n- 이메일/비밀번호 입력 폼\n- Form Validation (이메일 형식, 필수 입력)\n- 로딩 인디케이터 및 에러 메시지 표시\n- 반응형 레이아웃 (중앙 정렬 Card, maxWidth: 400)\n\n### 2. 로그인 Provider\n- **위치**: `lib/features/admin/auth/presentation/admin_login_provider.dart`\n- Riverpod StateNotifier 사용\n- API 호출: `POST /api/auth/login { email, password }`\n- 응답 데이터: `{ accessToken, refreshToken, user: { role } }`\n- 권한 검증: role이 STORE_ADMIN 또는 SUPER_ADMIN인 경우만 허용\n- EMPLOYEE 계정 로그인 시 \"관리자 권한이 필요합니다\" 에러 표시\n- 토큰 저장: flutter_secure_storage 사용\n- 로그인 성공 시 `/admin/dashboard`로 라우팅\n\n### 3. 로그아웃 기능\n- 로컬 토큰 삭제 (flutter_secure_storage.deleteAll())\n- `/admin/login`으로 리다이렉트\n\n### 4. 도메인 모델\n- **위치**: `lib/features/admin/auth/domain/models/admin_user.dart`\n- AdminUser 모델: userId, email, role 포함\n\n## 기술 스택\n- Riverpod for state management\n- Dio for HTTP client\n- flutter_secure_storage for token storage\n\n## 테스트 시나리오\n- ✅ STORE_ADMIN 계정으로 로그인 성공\n- ✅ SUPER_ADMIN 계정으로 로그인 성공\n- ✅ EMPLOYEE 계정으로 로그인 시 \"관리자 권한이 필요합니다\" 오류 표시\n- ✅ 잘못된 자격 증명으로 로그인 실패 처리\n- ✅ 토큰 저장 확인 (flutter_secure_storage)\n- ✅ 로그인 후 대시보드로 이동 확인",
            "status": "pending",
            "testStrategy": "Kotest를 사용한 단위 테스트:\n- AdminLoginProvider 로직 테스트 (성공/실패 케이스)\n- 권한 검증 테스트 (EMPLOYEE 거부, ADMIN 허용)\n- 토큰 저장/삭제 테스트\n\nIntegration 테스트:\n- 로그인 플로우 E2E 테스트\n- API 통신 테스트 (Mock Backend)",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "웹 어드민 레이아웃 및 네비게이션 시스템 구축",
            "description": "관리자 웹 어드민의 공통 레이아웃(AdminLayout), 사이드바 네비게이션(AdminSidebar), 상단 앱바(AdminAppBar)를 구현하여 모든 관리 화면에서 재사용 가능한 UI 프레임워크를 구축합니다.",
            "dependencies": [
              1
            ],
            "details": "## 구현 범위\n\n### 1. AdminLayout\n- **위치**: `lib/shared/widgets/admin_layout.dart`\n- Row 레이아웃: [AdminSidebar | Expanded(child)]\n- child에 24px 패딩 적용\n- AppBar 포함 (AdminAppBar)\n\n### 2. AdminSidebar\n- **위치**: `lib/shared/widgets/admin_sidebar.dart`\n- 고정 너비: 250px\n- DrawerHeader: \"LMS 관리자\" 타이틀 표시\n- 메뉴 항목:\n  - 대시보드 (/admin/dashboard)\n  - 매장 관리 (/admin/stores)\n  - 근로자 관리 (/admin/employees)\n  - 근무 일정 (/admin/schedules)\n  - 출퇴근 기록 (/admin/attendance)\n  - 휴가 관리 (/admin/leaves)\n  - 급여 관리 (/admin/payroll)\n  - 로그아웃 (/logout)\n- 현재 선택된 라우트 하이라이트\n- ListTile 위젯 사용, leading에 아이콘 표시\n\n### 3. AdminAppBar\n- **위치**: `lib/shared/widgets/admin_app_bar.dart`\n- 타이틀 표시 (각 화면별 동적 타이틀)\n- 우측에 사용자 정보 표시 (선택사항)\n\n### 4. 반응형 대응\n- 768px 이하: 사이드바 숨김, Drawer로 변환\n- 768px 이상: 사이드바 항상 표시\n\n## 라우팅 설정\n- **위치**: `lib/main_web_admin.dart`\n- MaterialApp routes 설정\n- initialRoute: '/admin/login'\n- 모든 관리 화면 라우트 등록\n\n## 테스트 시나리오\n- ✅ 사이드바 메뉴 클릭 시 라우팅 동작\n- ✅ 현재 선택된 메뉴 하이라이트\n- ✅ 로그아웃 클릭 시 토큰 삭제 및 로그인 화면 이동\n- ✅ 반응형 레이아웃 동작 (모바일/태블릿/데스크톱)",
            "status": "pending",
            "testStrategy": "Widget 테스트:\n- AdminLayout 렌더링 테스트\n- AdminSidebar 메뉴 항목 클릭 테스트\n- 라우팅 네비게이션 테스트\n\nGolden 테스트:\n- 사이드바 UI 스냅샷 테스트",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "대시보드 화면 구현 (통계 카드 및 요약 위젯)",
            "description": "관리자 대시보드 메인 화면을 구현하여 전체 매장, 근로자, 금일 출근, 휴가 중 통계를 카드 형태로 표시하고, 출근 현황 요약 및 최근 활동 위젯을 제공합니다.",
            "dependencies": [
              2
            ],
            "details": "## 구현 범위\n\n### 1. DashboardScreen\n- **위치**: `lib/features/admin/dashboard/presentation/dashboard_screen.dart`\n- AdminLayout으로 래핑\n- SingleChildScrollView 내부 Column 레이아웃\n- GridView.count (4열) 통계 카드 배치\n- 출근 현황 요약 위젯\n- 최근 활동 위젯\n\n### 2. StoreStatsCard\n- **위치**: `lib/features/admin/dashboard/presentation/widgets/store_stats_card.dart`\n- 타이틀, 값, 아이콘, 색상 props\n- Card elevation: 2\n- childAspectRatio: 2\n- 통계 카드 4개:\n  - 전체 매장 (Icons.store, Colors.blue)\n  - 전체 근로자 (Icons.people, Colors.green)\n  - 금일 출근 (Icons.check_circle, Colors.orange)\n  - 휴가 중 (Icons.beach_access, Colors.purple)\n\n### 3. AttendanceSummaryWidget\n- **위치**: `lib/features/admin/dashboard/presentation/widgets/attendance_summary_widget.dart`\n- 오늘 날짜 기준 출근 현황 표시\n- 정상 출근, 지각, 조퇴, 결근 수 표시\n- 가로 바 차트 또는 리스트 형태\n\n### 4. RecentActivitiesWidget\n- **위치**: `lib/features/admin/dashboard/presentation/widgets/recent_activities_widget.dart`\n- 최근 활동 목록 (휴가 신청, 출퇴근 기록 수정 등)\n- ListView.builder 사용\n- 각 활동: ListTile (타이틀, 서브타이틀, 시간)\n\n### 5. DashboardProvider\n- **위치**: `lib/features/admin/dashboard/presentation/dashboard_provider.dart`\n- FutureProvider 사용\n- API 호출: `GET /api/admin/dashboard/stats`\n- 응답 데이터: DashboardStats 모델로 파싱\n\n### 6. 도메인 모델\n- **위치**: `lib/features/admin/dashboard/domain/models/dashboard_stats.dart`\n- DashboardStats: totalStores, totalEmployees, todayAttendance, onLeave, attendanceSummary, recentActivities\n\n## API 엔드포인트 (백엔드 구현 필요)\n- `GET /api/admin/dashboard/stats`\n- 응답 예시:\n```json\n{\n  \"totalStores\": 5,\n  \"totalEmployees\": 120,\n  \"todayAttendance\": 95,\n  \"onLeave\": 8,\n  \"attendanceSummary\": {\n    \"normal\": 85,\n    \"late\": 7,\n    \"earlyLeave\": 3,\n    \"absent\": 0\n  },\n  \"recentActivities\": [\n    { \"type\": \"leave_request\", \"employeeName\": \"홍길동\", \"action\": \"휴가 신청\", \"timestamp\": \"2026-01-17T10:30:00Z\" }\n  ]\n}\n```\n\n## 테스트 시나리오\n- ✅ 대시보드 통계 카드 4개 렌더링\n- ✅ API 호출 후 데이터 표시\n- ✅ 로딩 상태 표시\n- ✅ 에러 상태 표시",
            "status": "pending",
            "testStrategy": "Widget 테스트:\n- StoreStatsCard 렌더링 및 props 테스트\n- AttendanceSummaryWidget 데이터 바인딩 테스트\n\nIntegration 테스트:\n- DashboardProvider API 호출 테스트\n- Mock 데이터로 대시보드 화면 렌더링 테스트",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "매장 관리 및 근로자 관리 화면 구현 (CRUD)",
            "description": "매장 목록/등록/수정/삭제 화면과 근로자 목록/등록/수정/비활성화 화면을 구현하여 관리자가 매장 및 근로자 정보를 관리할 수 있도록 합니다. DataTable 위젯을 사용하여 목록을 표시하고, Form 화면을 통해 등록/수정 기능을 제공합니다.",
            "dependencies": [
              2
            ],
            "details": "## 구현 범위\n\n### 1. 매장 관리\n\n#### StoreListScreen\n- **위치**: `lib/features/admin/store/presentation/store_list_screen.dart`\n- AdminLayout으로 래핑\n- DataTableWidget 사용하여 매장 목록 표시\n- 컬럼: ID, 매장명, 주소, 전화번호, 활성 상태, 작업\n- \"매장 추가\" 버튼 → `/admin/stores/new` 라우팅\n- 수정 아이콘 클릭 → `/admin/stores/{id}/edit` 라우팅\n- 삭제 아이콘 클릭 → 확인 다이얼로그 → API 호출 후 목록 갱신\n\n#### StoreFormScreen\n- **위치**: `lib/features/admin/store/presentation/store_form_screen.dart`\n- 매장 등록/수정 폼\n- 필드: 매장명, 주소, 전화번호, 활성 여부\n- Validation: 필수 입력, 전화번호 형식\n- API 호출:\n  - 등록: `POST /api/stores`\n  - 수정: `PUT /api/stores/{id}`\n- 완료 후 `/admin/stores`로 이동\n\n#### StoreProvider\n- **위치**: `lib/features/admin/store/presentation/store_provider.dart`\n- FutureProvider: 매장 목록 조회 (`GET /api/stores`)\n- StateNotifier: 매장 CRUD 작업 관리\n- deleteStore(), createStore(), updateStore() 메서드\n\n### 2. 근로자 관리\n\n#### EmployeeListScreen\n- **위치**: `lib/features/admin/employee/presentation/employee_list_screen.dart`\n- AdminLayout으로 래핑\n- DataTableWidget 사용하여 근로자 목록 표시\n- 컬럼: ID, 이름, 이메일, 매장, 근로자 타입, 활성 상태, 작업\n- \"근로자 추가\" 버튼 → `/admin/employees/new` 라우팅\n- 수정 아이콘 클릭 → `/admin/employees/{id}/edit` 라우팅\n- 비활성화 버튼 클릭 → 확인 다이얼로그 → API 호출\n\n#### EmployeeFormScreen\n- **위치**: `lib/features/admin/employee/presentation/employee_form_screen.dart`\n- 근로자 등록/수정 폼\n- 필드: 이름, 이메일, 비밀번호(등록 시만), 매장 선택, 근로자 타입, 시급, 연차 일수\n- Validation: 필수 입력, 이메일 형식, 시급 > 0\n- API 호출:\n  - 등록: `POST /api/employees`\n  - 수정: `PUT /api/employees/{id}`\n- 완료 후 `/admin/employees`로 이동\n\n#### EmployeeProvider\n- **위치**: `lib/features/admin/employee/presentation/employee_provider.dart`\n- FutureProvider: 근로자 목록 조회 (`GET /api/employees`)\n- StateNotifier: 근로자 CRUD 작업 관리\n\n### 3. 공통 위젯\n\n#### DataTableWidget\n- **위치**: `lib/shared/widgets/data_table_widget.dart`\n- DataTable 래퍼 위젯\n- columns, rows props\n- 페이지네이션 지원 (PaginatedDataTable)\n- 정렬 기능\n\n### 4. 도메인 모델\n- **위치**: `lib/features/admin/store/domain/models/store.dart`\n- Store: id, name, address, phone, isActive\n- **위치**: `lib/features/admin/employee/domain/models/employee.dart`\n- Employee: id, name, email, storeId, storeName, employeeType, hourlyWage, isActive\n\n## 테스트 시나리오\n- ✅ 매장 목록 조회 및 표시\n- ✅ 매장 등록 폼 Validation\n- ✅ 매장 수정 및 삭제\n- ✅ 근로자 목록 조회 및 표시\n- ✅ 근로자 등록 폼 Validation\n- ✅ 근로자 비활성화",
            "status": "pending",
            "testStrategy": "Widget 테스트:\n- DataTableWidget 렌더링 테스트\n- Form Validation 테스트\n\nIntegration 테스트:\n- 매장 CRUD 플로우 E2E 테스트\n- 근로자 CRUD 플로우 E2E 테스트\n- API 통신 에러 처리 테스트",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "근무 일정, 출퇴근 기록, 휴가, 급여 관리 화면 구현",
            "description": "근무 일정 캘린더 뷰, 출퇴근 기록 관리(수정 기능 포함), 휴가 승인/거부 시스템, 급여 목록 및 상세 조회 화면을 구현하여 관리자의 모든 관리 기능을 완성합니다.",
            "dependencies": [
              2
            ],
            "details": "## 구현 범위\n\n### 1. 근무 일정 관리\n\n#### ScheduleCalendarScreen\n- **위치**: `lib/features/admin/work_schedule/presentation/schedule_calendar_screen.dart`\n- AdminLayout으로 래핑\n- table_calendar 패키지 사용\n- 좌측: TableCalendar 위젯 (월별 뷰)\n- 우측: 선택된 날짜의 일정 목록\n- \"일정 추가\" 버튼 → 다이얼로그 표시\n- 일정 항목: 근로자명, 시작시간-종료시간 표시\n- 수정/삭제 아이콘 버튼\n\n#### ScheduleFormDialog\n- **위치**: `lib/features/admin/work_schedule/presentation/schedule_form_screen.dart`\n- 일정 등록/수정 다이얼로그\n- 필드: 근로자 선택, 날짜, 시작시간, 종료시간\n- Validation: 시작시간 < 종료시간\n- API 호출:\n  - 등록: `POST /api/work-schedules`\n  - 수정: `PUT /api/work-schedules/{id}`\n  - 삭제: `DELETE /api/work-schedules/{id}`\n\n#### ScheduleProvider\n- **위치**: `lib/features/admin/work_schedule/presentation/schedule_provider.dart`\n- FutureProvider: 특정 날짜 일정 조회 (`GET /api/work-schedules?date={date}`)\n- StateNotifier: 일정 CRUD 작업 관리\n\n### 2. 출퇴근 기록 관리\n\n#### AttendanceListScreen\n- **위치**: `lib/features/admin/attendance/presentation/attendance_list_screen.dart`\n- AdminLayout으로 래핑\n- 필터 위젯: 날짜 범위, 매장, 근로자 선택\n- DataTable: 날짜, 근로자명, 출근시간, 퇴근시간, 상태, 작업\n- 수정 아이콘 클릭 → AttendanceEditDialog 표시\n\n#### AttendanceEditDialog\n- **위치**: `lib/features/admin/attendance/presentation/attendance_edit_dialog.dart`\n- 출퇴근 시간 수정 다이얼로그\n- 필드: 출근시간, 퇴근시간\n- API 호출: `PUT /api/attendance-records/{id}`\n\n#### AttendanceProvider\n- **위치**: `lib/features/admin/attendance/presentation/attendance_provider.dart`\n- FutureProvider: 출퇴근 기록 조회 (필터 적용)\n- StateNotifier: 출퇴근 기록 수정 관리\n\n### 3. 휴가 관리\n\n#### LeaveRequestListScreen\n- **위치**: `lib/features/admin/leave/presentation/leave_request_list_screen.dart`\n- AdminLayout으로 래핑\n- 탭 위젯: 대기 중 / 승인됨 / 거부됨\n- DataTable: 근로자명, 휴가 타입, 시작일, 종료일, 상태, 작업\n- 승인/거부 버튼 → LeaveApprovalDialog 표시\n\n#### LeaveApprovalDialog\n- **위치**: `lib/features/admin/leave/presentation/leave_approval_dialog.dart`\n- 휴가 승인/거부 다이얼로그\n- 필드: 승인/거부 선택, 사유 입력 (선택사항)\n- API 호출:\n  - 승인: `PUT /api/leave-requests/{id}/approve`\n  - 거부: `PUT /api/leave-requests/{id}/reject`\n\n#### LeaveProvider\n- **위치**: `lib/features/admin/leave/presentation/leave_provider.dart`\n- FutureProvider: 휴가 신청 목록 조회\n- StateNotifier: 승인/거부 처리 관리\n\n### 4. 급여 관리\n\n#### PayrollListScreen\n- **위치**: `lib/features/admin/payroll/presentation/payroll_list_screen.dart`\n- AdminLayout으로 래핑\n- 필터 위젯: 매장, 근로자, 연도, 월 선택\n- DataTable: 근로자명, 연도, 월, 총 금액, 상태, 작업\n- 상세 보기 버튼 → PayrollDetailScreen 이동\n\n#### PayrollDetailScreen\n- **위치**: `lib/features/admin/payroll/presentation/payroll_detail_screen.dart`\n- 급여 상세 정보 표시\n- 기본급, 초과근무, 야간근무, 휴일근무 수당 분해 표시\n- 급여 확정 버튼 (PENDING → CONFIRMED)\n- API 호출: `PUT /api/payroll/{id}/confirm`\n\n#### PayrollProvider\n- **위치**: `lib/features/admin/payroll/presentation/payroll_provider.dart`\n- FutureProvider: 급여 목록 조회 (필터 적용)\n- FutureProvider: 급여 상세 조회\n- StateNotifier: 급여 확정 관리\n\n### 5. 공통 위젯\n\n#### FilterWidget\n- **위치**: `lib/shared/widgets/filter_widget.dart`\n- 날짜 범위, 드롭다운 선택 등 공통 필터 위젯\n\n## 필수 패키지\n- table_calendar: ^3.0.0 (근무 일정 캘린더)\n- intl: ^0.18.0 (날짜/시간 포맷팅)\n\n## 테스트 시나리오\n- ✅ 근무 일정 캘린더 렌더링 및 일정 CRUD\n- ✅ 출퇴근 기록 조회 및 수정\n- ✅ 휴가 승인/거부 플로우\n- ✅ 급여 목록 조회 및 확정",
            "status": "pending",
            "testStrategy": "Widget 테스트:\n- TableCalendar 렌더링 및 날짜 선택 테스트\n- 필터 위젯 동작 테스트\n\nIntegration 테스트:\n- 근무 일정 CRUD 플로우 E2E 테스트\n- 휴가 승인/거부 플로우 E2E 테스트\n- 급여 확정 플로우 E2E 테스트\n\nAPI Mock 테스트:\n- 모든 API 엔드포인트 통신 테스트",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "18",
        "title": "백엔드 API 통합 테스트 및 Swagger 문서화",
        "description": "Springdoc OpenAPI 3.0을 설정하고 8개 컨트롤러에 Swagger 어노테이션을 추가하여 API 문서를 자동 생성합니다. Kotest 기반 통합 테스트 인프라를 구축하고 110개의 통합 테스트를 작성하여 모든 API 엔드포인트의 동작을 검증합니다.",
        "details": "## 1. Springdoc OpenAPI 3.0 설정\n\n### 1.1 의존성 추가 (build.gradle.kts)\n```kotlin\ndependencies {\n    // Springdoc OpenAPI 3.0\n    implementation(\"org.springdoc:springdoc-openapi-starter-webmvc-ui:2.3.0\")\n    \n    // Kotest 통합 테스트\n    testImplementation(\"io.kotest:kotest-runner-junit5:5.8.0\")\n    testImplementation(\"io.kotest:kotest-assertions-core:5.8.0\")\n    testImplementation(\"io.kotest:kotest-extensions-spring:1.1.3\")\n    testImplementation(\"io.mockk:mockk:1.13.8\")\n    testImplementation(\"com.ninja-squad:springmockk:4.0.2\")\n}\n```\n\n### 1.2 OpenAPI 설정 클래스\n**위치:** `src/main/kotlin/com/lms/config/OpenApiConfig.kt`\n```kotlin\npackage com.lms.config\n\nimport io.swagger.v3.oas.models.OpenAPI\nimport io.swagger.v3.oas.models.info.Info\nimport io.swagger.v3.oas.models.info.Contact\nimport io.swagger.v3.oas.models.info.License\nimport io.swagger.v3.oas.models.security.SecurityScheme\nimport io.swagger.v3.oas.models.security.SecurityRequirement\nimport io.swagger.v3.oas.models.Components\nimport io.swagger.v3.oas.models.servers.Server\nimport org.springframework.context.annotation.Bean\nimport org.springframework.context.annotation.Configuration\n\n@Configuration\nclass OpenApiConfig {\n    \n    @Bean\n    fun customOpenAPI(): OpenAPI {\n        return OpenAPI()\n            .info(\n                Info()\n                    .title(\"LMS 근태 관리 시스템 API\")\n                    .version(\"1.0.0\")\n                    .description(\"\"\"\n                        근로자 출퇴근 관리, 휴가 신청, 급여 조회 등을 제공하는 근태 관리 시스템 API\n                        \n                        ## 주요 기능\n                        - 인증 및 권한 관리 (JWT)\n                        - 매장 관리\n                        - 근로자 관리\n                        - 출퇴근 기록\n                        - 근무 일정 관리\n                        - 휴가 신청 및 승인\n                        - 급여 조회\n                        - 알림 관리\n                    \"\"\".trimIndent())\n                    .contact(\n                        Contact()\n                            .name(\"LMS 개발팀\")\n                            .email(\"dev@lms.com\")\n                    )\n                    .license(\n                        License()\n                            .name(\"Apache 2.0\")\n                            .url(\"https://www.apache.org/licenses/LICENSE-2.0.html\")\n                    )\n            )\n            .servers(\n                listOf(\n                    Server().url(\"http://localhost:8080\").description(\"로컬 개발 서버\"),\n                    Server().url(\"https://api.lms.com\").description(\"프로덕션 서버\")\n                )\n            )\n            .components(\n                Components()\n                    .addSecuritySchemes(\n                        \"bearerAuth\",\n                        SecurityScheme()\n                            .type(SecurityScheme.Type.HTTP)\n                            .scheme(\"bearer\")\n                            .bearerFormat(\"JWT\")\n                            .description(\"JWT 토큰을 입력하세요 (Bearer 접두사 불필요)\")\n                    )\n            )\n            .addSecurityItem(SecurityRequirement().addList(\"bearerAuth\"))\n    }\n}\n```\n\n### 1.3 application.yml Swagger 설정\n```yaml\nspringdoc:\n  api-docs:\n    path: /api-docs\n    enabled: true\n  swagger-ui:\n    path: /swagger-ui.html\n    enabled: true\n    operations-sorter: method\n    tags-sorter: alpha\n    display-request-duration: true\n    doc-expansion: none\n  show-actuator: false\n  default-consumes-media-type: application/json\n  default-produces-media-type: application/json\n```\n\n---\n\n## 2. 컨트롤러별 Swagger 어노테이션 추가 (492 lines)\n\n### 2.1 AuthController\n**위치:** `src/main/kotlin/com/lms/controller/AuthController.kt`\n```kotlin\npackage com.lms.controller\n\nimport com.lms.dto.*\nimport com.lms.service.AuthService\nimport io.swagger.v3.oas.annotations.Operation\nimport io.swagger.v3.oas.annotations.tags.Tag\nimport io.swagger.v3.oas.annotations.responses.ApiResponse\nimport io.swagger.v3.oas.annotations.responses.ApiResponses\nimport io.swagger.v3.oas.annotations.media.Content\nimport io.swagger.v3.oas.annotations.media.Schema\nimport io.swagger.v3.oas.annotations.security.SecurityRequirement\nimport org.springframework.http.ResponseEntity\nimport org.springframework.web.bind.annotation.*\nimport jakarta.validation.Valid\n\n@Tag(name = \"인증\", description = \"로그인, 회원가입, 토큰 갱신 등 인증 관련 API\")\n@RestController\n@RequestMapping(\"/api/auth\")\nclass AuthController(\n    private val authService: AuthService\n) {\n    \n    @Operation(\n        summary = \"로그인\",\n        description = \"이메일과 비밀번호로 로그인하여 JWT 토큰을 발급받습니다.\"\n    )\n    @ApiResponses(\n        value = [\n            ApiResponse(\n                responseCode = \"200\",\n                description = \"로그인 성공\",\n                content = [Content(schema = Schema(implementation = LoginResponse::class))]\n            ),\n            ApiResponse(\n                responseCode = \"401\",\n                description = \"인증 실패 (잘못된 이메일 또는 비밀번호)\",\n                content = [Content(schema = Schema(implementation = ErrorResponse::class))]\n            )\n        ]\n    )\n    @PostMapping(\"/login\")\n    fun login(@Valid @RequestBody request: LoginRequest): ResponseEntity<LoginResponse> {\n        return ResponseEntity.ok(authService.login(request))\n    }\n    \n    @Operation(\n        summary = \"회원가입\",\n        description = \"새로운 사용자를 등록합니다. (관리자 권한 필요)\"\n    )\n    @ApiResponses(\n        value = [\n            ApiResponse(\n                responseCode = \"200\",\n                description = \"회원가입 성공\",\n                content = [Content(schema = Schema(implementation = UserResponse::class))]\n            ),\n            ApiResponse(\n                responseCode = \"400\",\n                description = \"잘못된 요청 (이메일 중복, 유효성 검사 실패 등)\",\n                content = [Content(schema = Schema(implementation = ErrorResponse::class))]\n            )\n        ]\n    )\n    @SecurityRequirement(name = \"bearerAuth\")\n    @PostMapping(\"/register\")\n    fun register(@Valid @RequestBody request: RegisterRequest): ResponseEntity<UserResponse> {\n        return ResponseEntity.ok(authService.register(request))\n    }\n    \n    @Operation(\n        summary = \"토큰 갱신\",\n        description = \"Refresh Token을 사용하여 새로운 Access Token을 발급받습니다.\"\n    )\n    @ApiResponses(\n        value = [\n            ApiResponse(\n                responseCode = \"200\",\n                description = \"토큰 갱신 성공\",\n                content = [Content(schema = Schema(implementation = TokenResponse::class))]\n            ),\n            ApiResponse(\n                responseCode = \"401\",\n                description = \"유효하지 않은 Refresh Token\",\n                content = [Content(schema = Schema(implementation = ErrorResponse::class))]\n            )\n        ]\n    )\n    @PostMapping(\"/refresh\")\n    fun refreshToken(@Valid @RequestBody request: RefreshTokenRequest): ResponseEntity<TokenResponse> {\n        return ResponseEntity.ok(authService.refreshToken(request))\n    }\n}\n```\n\n### 2.2 StoreController\n**위치:** `src/main/kotlin/com/lms/controller/StoreController.kt`\n```kotlin\n@Tag(name = \"매장 관리\", description = \"매장 생성, 조회, 수정, 삭제 API\")\n@RestController\n@RequestMapping(\"/api/stores\")\n@SecurityRequirement(name = \"bearerAuth\")\nclass StoreController(\n    private val storeService: StoreService\n) {\n    \n    @Operation(\n        summary = \"매장 목록 조회\",\n        description = \"모든 매장 목록을 조회합니다. (관리자 권한 필요)\"\n    )\n    @ApiResponses(\n        value = [\n            ApiResponse(\n                responseCode = \"200\",\n                description = \"조회 성공\",\n                content = [Content(schema = Schema(implementation = StoreListResponse::class))]\n            )\n        ]\n    )\n    @GetMapping\n    fun getAllStores(): ResponseEntity<List<StoreResponse>> {\n        return ResponseEntity.ok(storeService.getAllStores())\n    }\n    \n    @Operation(\n        summary = \"매장 상세 조회\",\n        description = \"특정 매장의 상세 정보를 조회합니다.\"\n    )\n    @ApiResponses(\n        value = [\n            ApiResponse(\n                responseCode = \"200\",\n                description = \"조회 성공\",\n                content = [Content(schema = Schema(implementation = StoreResponse::class))]\n            ),\n            ApiResponse(\n                responseCode = \"404\",\n                description = \"매장을 찾을 수 없음\",\n                content = [Content(schema = Schema(implementation = ErrorResponse::class))]\n            )\n        ]\n    )\n    @GetMapping(\"/{id}\")\n    fun getStoreById(@PathVariable id: Long): ResponseEntity<StoreResponse> {\n        return ResponseEntity.ok(storeService.getStoreById(id))\n    }\n    \n    @Operation(\n        summary = \"매장 생성\",\n        description = \"새로운 매장을 생성합니다. (SUPER_ADMIN 권한 필요)\"\n    )\n    @ApiResponses(\n        value = [\n            ApiResponse(\n                responseCode = \"200\",\n                description = \"생성 성공\",\n                content = [Content(schema = Schema(implementation = StoreResponse::class))]\n            ),\n            ApiResponse(\n                responseCode = \"400\",\n                description = \"잘못된 요청\",\n                content = [Content(schema = Schema(implementation = ErrorResponse::class))]\n            )\n        ]\n    )\n    @PostMapping\n    fun createStore(@Valid @RequestBody request: CreateStoreRequest): ResponseEntity<StoreResponse> {\n        return ResponseEntity.ok(storeService.createStore(request))\n    }\n    \n    @Operation(\n        summary = \"매장 수정\",\n        description = \"기존 매장 정보를 수정합니다.\"\n    )\n    @PutMapping(\"/{id}\")\n    fun updateStore(\n        @PathVariable id: Long,\n        @Valid @RequestBody request: UpdateStoreRequest\n    ): ResponseEntity<StoreResponse> {\n        return ResponseEntity.ok(storeService.updateStore(id, request))\n    }\n    \n    @Operation(\n        summary = \"매장 삭제\",\n        description = \"매장을 삭제합니다. (SUPER_ADMIN 권한 필요)\"\n    )\n    @DeleteMapping(\"/{id}\")\n    fun deleteStore(@PathVariable id: Long): ResponseEntity<Void> {\n        storeService.deleteStore(id)\n        return ResponseEntity.noContent().build()\n    }\n}\n```\n\n### 2.3 EmployeeController\n```kotlin\n@Tag(name = \"근로자 관리\", description = \"근로자 생성, 조회, 수정, 삭제 API\")\n@RestController\n@RequestMapping(\"/api/employees\")\n@SecurityRequirement(name = \"bearerAuth\")\nclass EmployeeController(\n    private val employeeService: EmployeeService\n) {\n    \n    @Operation(summary = \"근로자 목록 조회\", description = \"매장별 근로자 목록을 조회합니다.\")\n    @GetMapping\n    fun getAllEmployees(\n        @RequestParam(required = false) storeId: Long?\n    ): ResponseEntity<List<EmployeeResponse>> {\n        return ResponseEntity.ok(employeeService.getAllEmployees(storeId))\n    }\n    \n    @Operation(summary = \"근로자 상세 조회\")\n    @GetMapping(\"/{id}\")\n    fun getEmployeeById(@PathVariable id: Long): ResponseEntity<EmployeeResponse> {\n        return ResponseEntity.ok(employeeService.getEmployeeById(id))\n    }\n    \n    @Operation(summary = \"근로자 생성\")\n    @PostMapping\n    fun createEmployee(@Valid @RequestBody request: CreateEmployeeRequest): ResponseEntity<EmployeeResponse> {\n        return ResponseEntity.ok(employeeService.createEmployee(request))\n    }\n    \n    @Operation(summary = \"근로자 수정\")\n    @PutMapping(\"/{id}\")\n    fun updateEmployee(\n        @PathVariable id: Long,\n        @Valid @RequestBody request: UpdateEmployeeRequest\n    ): ResponseEntity<EmployeeResponse> {\n        return ResponseEntity.ok(employeeService.updateEmployee(id, request))\n    }\n    \n    @Operation(summary = \"근로자 삭제\")\n    @DeleteMapping(\"/{id}\")\n    fun deleteEmployee(@PathVariable id: Long): ResponseEntity<Void> {\n        employeeService.deleteEmployee(id)\n        return ResponseEntity.noContent().build()\n    }\n}\n```\n\n### 2.4 AttendanceController\n```kotlin\n@Tag(name = \"출퇴근 관리\", description = \"출근, 퇴근, 출퇴근 기록 조회 API\")\n@RestController\n@RequestMapping(\"/api/attendance\")\n@SecurityRequirement(name = \"bearerAuth\")\nclass AttendanceController(\n    private val attendanceService: AttendanceService\n) {\n    \n    @Operation(\n        summary = \"출근 체크\",\n        description = \"현재 시간으로 출근을 기록합니다.\"\n    )\n    @PostMapping(\"/check-in\")\n    fun checkIn(@Valid @RequestBody request: CheckInRequest): ResponseEntity<AttendanceResponse> {\n        return ResponseEntity.ok(attendanceService.checkIn(request))\n    }\n    \n    @Operation(\n        summary = \"퇴근 체크\",\n        description = \"현재 시간으로 퇴근을 기록합니다.\"\n    )\n    @PostMapping(\"/check-out\")\n    fun checkOut(@Valid @RequestBody request: CheckOutRequest): ResponseEntity<AttendanceResponse> {\n        return ResponseEntity.ok(attendanceService.checkOut(request))\n    }\n    \n    @Operation(\n        summary = \"출퇴근 기록 조회\",\n        description = \"특정 기간의 출퇴근 기록을 조회합니다.\"\n    )\n    @GetMapping\n    fun getAttendanceRecords(\n        @RequestParam employeeId: Long,\n        @RequestParam startDate: String,\n        @RequestParam endDate: String\n    ): ResponseEntity<List<AttendanceResponse>> {\n        return ResponseEntity.ok(attendanceService.getAttendanceRecords(employeeId, startDate, endDate))\n    }\n    \n    @Operation(summary = \"오늘 출퇴근 상태 조회\")\n    @GetMapping(\"/today\")\n    fun getTodayAttendance(@RequestParam employeeId: Long): ResponseEntity<AttendanceResponse?> {\n        return ResponseEntity.ok(attendanceService.getTodayAttendance(employeeId))\n    }\n}\n```\n\n### 2.5 ScheduleController\n```kotlin\n@Tag(name = \"근무 일정 관리\", description = \"근무 일정 생성, 조회, 수정, 삭제 API\")\n@RestController\n@RequestMapping(\"/api/schedules\")\n@SecurityRequirement(name = \"bearerAuth\")\nclass ScheduleController(\n    private val scheduleService: ScheduleService\n) {\n    \n    @Operation(summary = \"근무 일정 목록 조회\")\n    @GetMapping\n    fun getSchedules(\n        @RequestParam storeId: Long,\n        @RequestParam startDate: String,\n        @RequestParam endDate: String\n    ): ResponseEntity<List<ScheduleResponse>> {\n        return ResponseEntity.ok(scheduleService.getSchedules(storeId, startDate, endDate))\n    }\n    \n    @Operation(summary = \"근무 일정 생성\")\n    @PostMapping\n    fun createSchedule(@Valid @RequestBody request: CreateScheduleRequest): ResponseEntity<ScheduleResponse> {\n        return ResponseEntity.ok(scheduleService.createSchedule(request))\n    }\n    \n    @Operation(summary = \"근무 일정 수정\")\n    @PutMapping(\"/{id}\")\n    fun updateSchedule(\n        @PathVariable id: Long,\n        @Valid @RequestBody request: UpdateScheduleRequest\n    ): ResponseEntity<ScheduleResponse> {\n        return ResponseEntity.ok(scheduleService.updateSchedule(id, request))\n    }\n    \n    @Operation(summary = \"근무 일정 삭제\")\n    @DeleteMapping(\"/{id}\")\n    fun deleteSchedule(@PathVariable id: Long): ResponseEntity<Void> {\n        scheduleService.deleteSchedule(id)\n        return ResponseEntity.noContent().build()\n    }\n}\n```\n\n### 2.6 LeaveController\n```kotlin\n@Tag(name = \"휴가 관리\", description = \"휴가 신청, 승인, 조회 API\")\n@RestController\n@RequestMapping(\"/api/leaves\")\n@SecurityRequirement(name = \"bearerAuth\")\nclass LeaveController(\n    private val leaveService: LeaveService\n) {\n    \n    @Operation(summary = \"휴가 신청\")\n    @PostMapping\n    fun applyLeave(@Valid @RequestBody request: LeaveRequest): ResponseEntity<LeaveResponse> {\n        return ResponseEntity.ok(leaveService.applyLeave(request))\n    }\n    \n    @Operation(summary = \"휴가 목록 조회\")\n    @GetMapping\n    fun getLeaves(\n        @RequestParam(required = false) employeeId: Long?,\n        @RequestParam(required = false) status: String?\n    ): ResponseEntity<List<LeaveResponse>> {\n        return ResponseEntity.ok(leaveService.getLeaves(employeeId, status))\n    }\n    \n    @Operation(summary = \"휴가 승인\")\n    @PutMapping(\"/{id}/approve\")\n    fun approveLeave(@PathVariable id: Long): ResponseEntity<LeaveResponse> {\n        return ResponseEntity.ok(leaveService.approveLeave(id))\n    }\n    \n    @Operation(summary = \"휴가 거절\")\n    @PutMapping(\"/{id}/reject\")\n    fun rejectLeave(\n        @PathVariable id: Long,\n        @RequestBody reason: String\n    ): ResponseEntity<LeaveResponse> {\n        return ResponseEntity.ok(leaveService.rejectLeave(id, reason))\n    }\n}\n```\n\n### 2.7 PayrollController\n```kotlin\n@Tag(name = \"급여 관리\", description = \"급여 조회 및 계산 API\")\n@RestController\n@RequestMapping(\"/api/payroll\")\n@SecurityRequirement(name = \"bearerAuth\")\nclass PayrollController(\n    private val payrollService: PayrollService\n) {\n    \n    @Operation(summary = \"급여 내역 조회\")\n    @GetMapping\n    fun getPayrolls(\n        @RequestParam employeeId: Long,\n        @RequestParam year: Int,\n        @RequestParam month: Int\n    ): ResponseEntity<PayrollResponse> {\n        return ResponseEntity.ok(payrollService.getPayroll(employeeId, year, month))\n    }\n    \n    @Operation(summary = \"급여 계산 및 생성\")\n    @PostMapping(\"/calculate\")\n    fun calculatePayroll(@Valid @RequestBody request: CalculatePayrollRequest): ResponseEntity<PayrollResponse> {\n        return ResponseEntity.ok(payrollService.calculatePayroll(request))\n    }\n}\n```\n\n### 2.8 NotificationController\n```kotlin\n@Tag(name = \"알림 관리\", description = \"알림 조회 및 읽음 처리 API\")\n@RestController\n@RequestMapping(\"/api/notifications\")\n@SecurityRequirement(name = \"bearerAuth\")\nclass NotificationController(\n    private val notificationService: NotificationService\n) {\n    \n    @Operation(summary = \"알림 목록 조회\")\n    @GetMapping\n    fun getNotifications(@RequestParam userId: Long): ResponseEntity<List<NotificationResponse>> {\n        return ResponseEntity.ok(notificationService.getNotifications(userId))\n    }\n    \n    @Operation(summary = \"알림 읽음 처리\")\n    @PutMapping(\"/{id}/read\")\n    fun markAsRead(@PathVariable id: Long): ResponseEntity<Void> {\n        notificationService.markAsRead(id)\n        return ResponseEntity.noContent().build()\n    }\n    \n    @Operation(summary = \"모든 알림 읽음 처리\")\n    @PutMapping(\"/read-all\")\n    fun markAllAsRead(@RequestParam userId: Long): ResponseEntity<Void> {\n        notificationService.markAllAsRead(userId)\n        return ResponseEntity.noContent().build()\n    }\n}\n```\n\n---\n\n## 3. Kotest 기반 통합 테스트 인프라 구축\n\n### 3.1 Kotest 설정 클래스\n**위치:** `src/test/kotlin/com/lms/config/KotestConfig.kt`\n```kotlin\npackage com.lms.config\n\nimport io.kotest.core.config.AbstractProjectConfig\nimport io.kotest.core.spec.IsolationMode\nimport io.kotest.extensions.spring.SpringExtension\n\nclass KotestConfig : AbstractProjectConfig() {\n    override val isolationMode = IsolationMode.InstancePerLeaf\n    override fun extensions() = listOf(SpringExtension)\n}\n```\n\n### 3.2 통합 테스트 Base 클래스\n**위치:** `src/test/kotlin/com/lms/IntegrationTestBase.kt`\n```kotlin\npackage com.lms\n\nimport com.fasterxml.jackson.databind.ObjectMapper\nimport com.lms.entity.User\nimport com.lms.entity.UserRole\nimport com.lms.security.JwtTokenProvider\nimport io.kotest.core.spec.style.DescribeSpec\nimport org.springframework.beans.factory.annotation.Autowired\nimport org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc\nimport org.springframework.boot.test.context.SpringBootTest\nimport org.springframework.test.context.ActiveProfiles\nimport org.springframework.test.web.servlet.MockMvc\nimport org.springframework.transaction.annotation.Transactional\n\n@SpringBootTest\n@AutoConfigureMockMvc\n@ActiveProfiles(\"test\")\n@Transactional\nabstract class IntegrationTestBase : DescribeSpec() {\n    \n    @Autowired\n    protected lateinit var mockMvc: MockMvc\n    \n    @Autowired\n    protected lateinit var objectMapper: ObjectMapper\n    \n    @Autowired\n    protected lateinit var jwtTokenProvider: JwtTokenProvider\n    \n    protected fun generateToken(userId: Long, email: String, role: UserRole): String {\n        return jwtTokenProvider.generateToken(userId, email, role)\n    }\n    \n    protected fun generateAdminToken(): String {\n        return generateToken(1L, \"admin@test.com\", UserRole.SUPER_ADMIN)\n    }\n    \n    protected fun generateEmployeeToken(): String {\n        return generateToken(2L, \"employee@test.com\", UserRole.EMPLOYEE)\n    }\n}\n```\n\n---\n\n## 4. 110개 통합 테스트 작성 (1,646 lines)\n\n### 4.1 AuthController 통합 테스트 (15개 테스트)\n**위치:** `src/test/kotlin/com/lms/controller/AuthControllerTest.kt`\n```kotlin\npackage com.lms.controller\n\nimport com.lms.IntegrationTestBase\nimport com.lms.dto.LoginRequest\nimport com.lms.dto.RegisterRequest\nimport com.lms.entity.UserRole\nimport io.kotest.matchers.shouldBe\nimport io.kotest.matchers.shouldNotBe\nimport org.springframework.http.MediaType\nimport org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*\nimport org.springframework.test.web.servlet.result.MockMvcResultMatchers.*\n\nclass AuthControllerTest : IntegrationTestBase() {\n    \n    init {\n        describe(\"POST /api/auth/login\") {\n            context(\"올바른 이메일과 비밀번호로 로그인할 때\") {\n                it(\"200 OK와 JWT 토큰을 반환한다\") {\n                    val request = LoginRequest(\n                        email = \"test@example.com\",\n                        password = \"password123\"\n                    )\n                    \n                    val result = mockMvc.perform(\n                        post(\"/api/auth/login\")\n                            .contentType(MediaType.APPLICATION_JSON)\n                            .content(objectMapper.writeValueAsString(request))\n                    )\n                        .andExpect(status().isOk)\n                        .andExpect(jsonPath(\"$.accessToken\").exists())\n                        .andExpect(jsonPath(\"$.refreshToken\").exists())\n                        .andReturn()\n                    \n                    val response = objectMapper.readTree(result.response.contentAsString)\n                    response.get(\"accessToken\").asText() shouldNotBe null\n                }\n            }\n            \n            context(\"잘못된 비밀번호로 로그인할 때\") {\n                it(\"401 Unauthorized를 반환한다\") {\n                    val request = LoginRequest(\n                        email = \"test@example.com\",\n                        password = \"wrongpassword\"\n                    )\n                    \n                    mockMvc.perform(\n                        post(\"/api/auth/login\")\n                            .contentType(MediaType.APPLICATION_JSON)\n                            .content(objectMapper.writeValueAsString(request))\n                    )\n                        .andExpect(status().isUnauthorized)\n                }\n            }\n            \n            context(\"존재하지 않는 이메일로 로그인할 때\") {\n                it(\"401 Unauthorized를 반환한다\") {\n                    val request = LoginRequest(\n                        email = \"nonexistent@example.com\",\n                        password = \"password123\"\n                    )\n                    \n                    mockMvc.perform(\n                        post(\"/api/auth/login\")\n                            .contentType(MediaType.APPLICATION_JSON)\n                            .content(objectMapper.writeValueAsString(request))\n                    )\n                        .andExpect(status().isUnauthorized)\n                }\n            }\n            \n            context(\"이메일 형식이 잘못되었을 때\") {\n                it(\"400 Bad Request를 반환한다\") {\n                    val request = mapOf(\n                        \"email\" to \"invalid-email\",\n                        \"password\" to \"password123\"\n                    )\n                    \n                    mockMvc.perform(\n                        post(\"/api/auth/login\")\n                            .contentType(MediaType.APPLICATION_JSON)\n                            .content(objectMapper.writeValueAsString(request))\n                    )\n                        .andExpect(status().isBadRequest)\n                }\n            }\n        }\n        \n        describe(\"POST /api/auth/register\") {\n            context(\"관리자 권한으로 새 사용자를 등록할 때\") {\n                it(\"200 OK와 생성된 사용자 정보를 반환한다\") {\n                    val token = generateAdminToken()\n                    val request = RegisterRequest(\n                        email = \"newuser@example.com\",\n                        password = \"password123\",\n                        name = \"New User\",\n                        role = UserRole.EMPLOYEE,\n                        storeId = 1L\n                    )\n                    \n                    mockMvc.perform(\n                        post(\"/api/auth/register\")\n                            .header(\"Authorization\", \"Bearer $token\")\n                            .contentType(MediaType.APPLICATION_JSON)\n                            .content(objectMapper.writeValueAsString(request))\n                    )\n                        .andExpect(status().isOk)\n                        .andExpect(jsonPath(\"$.email\").value(\"newuser@example.com\"))\n                        .andExpect(jsonPath(\"$.name\").value(\"New User\"))\n                }\n            }\n            \n            context(\"이미 존재하는 이메일로 등록할 때\") {\n                it(\"400 Bad Request를 반환한다\") {\n                    val token = generateAdminToken()\n                    val request = RegisterRequest(\n                        email = \"existing@example.com\",\n                        password = \"password123\",\n                        name = \"Duplicate User\",\n                        role = UserRole.EMPLOYEE,\n                        storeId = 1L\n                    )\n                    \n                    mockMvc.perform(\n                        post(\"/api/auth/register\")\n                            .header(\"Authorization\", \"Bearer $token\")\n                            .contentType(MediaType.APPLICATION_JSON)\n                            .content(objectMapper.writeValueAsString(request))\n                    )\n                        .andExpect(status().isBadRequest)\n                }\n            }\n            \n            context(\"인증 토큰 없이 등록 요청할 때\") {\n                it(\"401 Unauthorized를 반환한다\") {\n                    val request = RegisterRequest(\n                        email = \"newuser@example.com\",\n                        password = \"password123\",\n                        name = \"New User\",\n                        role = UserRole.EMPLOYEE,\n                        storeId = 1L\n                    )\n                    \n                    mockMvc.perform(\n                        post(\"/api/auth/register\")\n                            .contentType(MediaType.APPLICATION_JSON)\n                            .content(objectMapper.writeValueAsString(request))\n                    )\n                        .andExpect(status().isUnauthorized)\n                }\n            }\n        }\n        \n        describe(\"POST /api/auth/refresh\") {\n            context(\"유효한 Refresh Token으로 요청할 때\") {\n                it(\"200 OK와 새로운 Access Token을 반환한다\") {\n                    val refreshToken = \"valid-refresh-token\"\n                    val request = mapOf(\"refreshToken\" to refreshToken)\n                    \n                    mockMvc.perform(\n                        post(\"/api/auth/refresh\")\n                            .contentType(MediaType.APPLICATION_JSON)\n                            .content(objectMapper.writeValueAsString(request))\n                    )\n                        .andExpect(status().isOk)\n                        .andExpect(jsonPath(\"$.accessToken\").exists())\n                }\n            }\n            \n            context(\"만료된 Refresh Token으로 요청할 때\") {\n                it(\"401 Unauthorized를 반환한다\") {\n                    val expiredToken = \"expired-refresh-token\"\n                    val request = mapOf(\"refreshToken\" to expiredToken)\n                    \n                    mockMvc.perform(\n                        post(\"/api/auth/refresh\")\n                            .contentType(MediaType.APPLICATION_JSON)\n                            .content(objectMapper.writeValueAsString(request))\n                    )\n                        .andExpect(status().isUnauthorized)\n                }\n            }\n        }\n    }\n}\n```\n\n### 4.2 StoreController 통합 테스트 (14개 테스트)\n**위치:** `src/test/kotlin/com/lms/controller/StoreControllerTest.kt`\n```kotlin\nclass StoreControllerTest : IntegrationTestBase() {\n    \n    init {\n        describe(\"GET /api/stores\") {\n            context(\"관리자 권한으로 매장 목록 조회할 때\") {\n                it(\"200 OK와 매장 목록을 반환한다\") {\n                    val token = generateAdminToken()\n                    \n                    mockMvc.perform(\n                        get(\"/api/stores\")\n                            .header(\"Authorization\", \"Bearer $token\")\n                    )\n                        .andExpect(status().isOk)\n                        .andExpect(jsonPath(\"$\").isArray)\n                }\n            }\n            \n            context(\"인증 없이 매장 목록 조회할 때\") {\n                it(\"401 Unauthorized를 반환한다\") {\n                    mockMvc.perform(get(\"/api/stores\"))\n                        .andExpect(status().isUnauthorized)\n                }\n            }\n        }\n        \n        describe(\"GET /api/stores/{id}\") {\n            context(\"존재하는 매장 ID로 조회할 때\") {\n                it(\"200 OK와 매장 상세 정보를 반환한다\") {\n                    val token = generateAdminToken()\n                    \n                    mockMvc.perform(\n                        get(\"/api/stores/1\")\n                            .header(\"Authorization\", \"Bearer $token\")\n                    )\n                        .andExpect(status().isOk)\n                        .andExpect(jsonPath(\"$.id\").value(1))\n                        .andExpect(jsonPath(\"$.name\").exists())\n                }\n            }\n            \n            context(\"존재하지 않는 매장 ID로 조회할 때\") {\n                it(\"404 Not Found를 반환한다\") {\n                    val token = generateAdminToken()\n                    \n                    mockMvc.perform(\n                        get(\"/api/stores/9999\")\n                            .header(\"Authorization\", \"Bearer $token\")\n                    )\n                        .andExpect(status().isNotFound)\n                }\n            }\n        }\n        \n        describe(\"POST /api/stores\") {\n            context(\"SUPER_ADMIN 권한으로 매장 생성할 때\") {\n                it(\"200 OK와 생성된 매장 정보를 반환한다\") {\n                    val token = generateAdminToken()\n                    val request = mapOf(\n                        \"name\" to \"New Store\",\n                        \"address\" to \"Seoul\",\n                        \"phoneNumber\" to \"02-1234-5678\"\n                    )\n                    \n                    mockMvc.perform(\n                        post(\"/api/stores\")\n                            .header(\"Authorization\", \"Bearer $token\")\n                            .contentType(MediaType.APPLICATION_JSON)\n                            .content(objectMapper.writeValueAsString(request))\n                    )\n                        .andExpect(status().isOk)\n                        .andExpect(jsonPath(\"$.name\").value(\"New Store\"))\n                }\n            }\n            \n            context(\"필수 필드 누락 시\") {\n                it(\"400 Bad Request를 반환한다\") {\n                    val token = generateAdminToken()\n                    val request = mapOf(\"name\" to \"Incomplete Store\")\n                    \n                    mockMvc.perform(\n                        post(\"/api/stores\")\n                            .header(\"Authorization\", \"Bearer $token\")\n                            .contentType(MediaType.APPLICATION_JSON)\n                            .content(objectMapper.writeValueAsString(request))\n                    )\n                        .andExpect(status().isBadRequest)\n                }\n            }\n        }\n        \n        describe(\"PUT /api/stores/{id}\") {\n            context(\"매장 정보 수정할 때\") {\n                it(\"200 OK와 수정된 매장 정보를 반환한다\") {\n                    val token = generateAdminToken()\n                    val request = mapOf(\n                        \"name\" to \"Updated Store\",\n                        \"address\" to \"Busan\"\n                    )\n                    \n                    mockMvc.perform(\n                        put(\"/api/stores/1\")\n                            .header(\"Authorization\", \"Bearer $token\")\n                            .contentType(MediaType.APPLICATION_JSON)\n                            .content(objectMapper.writeValueAsString(request))\n                    )\n                        .andExpect(status().isOk)\n                        .andExpect(jsonPath(\"$.name\").value(\"Updated Store\"))\n                }\n            }\n        }\n        \n        describe(\"DELETE /api/stores/{id}\") {\n            context(\"매장 삭제할 때\") {\n                it(\"204 No Content를 반환한다\") {\n                    val token = generateAdminToken()\n                    \n                    mockMvc.perform(\n                        delete(\"/api/stores/1\")\n                            .header(\"Authorization\", \"Bearer $token\")\n                    )\n                        .andExpect(status().isNoContent)\n                }\n            }\n        }\n    }\n}\n```\n\n### 4.3 EmployeeController 통합 테스트 (14개 테스트)\n**위치:** `src/test/kotlin/com/lms/controller/EmployeeControllerTest.kt`\n```kotlin\nclass EmployeeControllerTest : IntegrationTestBase() {\n    \n    init {\n        describe(\"GET /api/employees\") {\n            context(\"전체 근로자 목록 조회할 때\") {\n                it(\"200 OK와 근로자 목록을 반환한다\") {\n                    val token = generateAdminToken()\n                    \n                    mockMvc.perform(\n                        get(\"/api/employees\")\n                            .header(\"Authorization\", \"Bearer $token\")\n                    )\n                        .andExpect(status().isOk)\n                        .andExpect(jsonPath(\"$\").isArray)\n                }\n            }\n            \n            context(\"특정 매장의 근로자 목록 조회할 때\") {\n                it(\"200 OK와 해당 매장 근로자 목록을 반환한다\") {\n                    val token = generateAdminToken()\n                    \n                    mockMvc.perform(\n                        get(\"/api/employees\")\n                            .param(\"storeId\", \"1\")\n                            .header(\"Authorization\", \"Bearer $token\")\n                    )\n                        .andExpect(status().isOk)\n                        .andExpect(jsonPath(\"$[0].storeId\").value(1))\n                }\n            }\n        }\n        \n        describe(\"POST /api/employees\") {\n            context(\"새 근로자 생성할 때\") {\n                it(\"200 OK와 생성된 근로자 정보를 반환한다\") {\n                    val token = generateAdminToken()\n                    val request = mapOf(\n                        \"name\" to \"John Doe\",\n                        \"email\" to \"john@example.com\",\n                        \"storeId\" to 1,\n                        \"hourlyWage\" to 10000\n                    )\n                    \n                    mockMvc.perform(\n                        post(\"/api/employees\")\n                            .header(\"Authorization\", \"Bearer $token\")\n                            .contentType(MediaType.APPLICATION_JSON)\n                            .content(objectMapper.writeValueAsString(request))\n                    )\n                        .andExpect(status().isOk)\n                        .andExpect(jsonPath(\"$.name\").value(\"John Doe\"))\n                }\n            }\n        }\n        \n        // 추가 12개 테스트...\n    }\n}\n```\n\n### 4.4 AttendanceController 통합 테스트 (16개 테스트)\n**위치:** `src/test/kotlin/com/lms/controller/AttendanceControllerTest.kt`\n```kotlin\nclass AttendanceControllerTest : IntegrationTestBase() {\n    \n    init {\n        describe(\"POST /api/attendance/check-in\") {\n            context(\"근로자가 출근 체크할 때\") {\n                it(\"200 OK와 출근 기록을 반환한다\") {\n                    val token = generateEmployeeToken()\n                    val request = mapOf(\"employeeId\" to 1)\n                    \n                    mockMvc.perform(\n                        post(\"/api/attendance/check-in\")\n                            .header(\"Authorization\", \"Bearer $token\")\n                            .contentType(MediaType.APPLICATION_JSON)\n                            .content(objectMapper.writeValueAsString(request))\n                    )\n                        .andExpect(status().isOk)\n                        .andExpect(jsonPath(\"$.checkInTime\").exists())\n                }\n            }\n            \n            context(\"이미 출근한 상태에서 다시 출근 체크할 때\") {\n                it(\"400 Bad Request를 반환한다\") {\n                    val token = generateEmployeeToken()\n                    val request = mapOf(\"employeeId\" to 1)\n                    \n                    // 첫 번째 출근\n                    mockMvc.perform(\n                        post(\"/api/attendance/check-in\")\n                            .header(\"Authorization\", \"Bearer $token\")\n                            .contentType(MediaType.APPLICATION_JSON)\n                            .content(objectMapper.writeValueAsString(request))\n                    )\n                    \n                    // 두 번째 출근 시도\n                    mockMvc.perform(\n                        post(\"/api/attendance/check-in\")\n                            .header(\"Authorization\", \"Bearer $token\")\n                            .contentType(MediaType.APPLICATION_JSON)\n                            .content(objectMapper.writeValueAsString(request))\n                    )\n                        .andExpect(status().isBadRequest)\n                }\n            }\n        }\n        \n        describe(\"POST /api/attendance/check-out\") {\n            context(\"출근한 상태에서 퇴근 체크할 때\") {\n                it(\"200 OK와 퇴근 기록을 반환한다\") {\n                    val token = generateEmployeeToken()\n                    \n                    // 먼저 출근\n                    mockMvc.perform(\n                        post(\"/api/attendance/check-in\")\n                            .header(\"Authorization\", \"Bearer $token\")\n                            .contentType(MediaType.APPLICATION_JSON)\n                            .content(objectMapper.writeValueAsString(mapOf(\"employeeId\" to 1)))\n                    )\n                    \n                    // 퇴근\n                    mockMvc.perform(\n                        post(\"/api/attendance/check-out\")\n                            .header(\"Authorization\", \"Bearer $token\")\n                            .contentType(MediaType.APPLICATION_JSON)\n                            .content(objectMapper.writeValueAsString(mapOf(\"employeeId\" to 1)))\n                    )\n                        .andExpect(status().isOk)\n                        .andExpect(jsonPath(\"$.checkOutTime\").exists())\n                }\n            }\n            \n            context(\"출근하지 않은 상태에서 퇴근 체크할 때\") {\n                it(\"400 Bad Request를 반환한다\") {\n                    val token = generateEmployeeToken()\n                    val request = mapOf(\"employeeId\" to 1)\n                    \n                    mockMvc.perform(\n                        post(\"/api/attendance/check-out\")\n                            .header(\"Authorization\", \"Bearer $token\")\n                            .contentType(MediaType.APPLICATION_JSON)\n                            .content(objectMapper.writeValueAsString(request))\n                    )\n                        .andExpect(status().isBadRequest)\n                }\n            }\n        }\n        \n        describe(\"GET /api/attendance\") {\n            context(\"특정 기간의 출퇴근 기록 조회할 때\") {\n                it(\"200 OK와 출퇴근 기록 목록을 반환한다\") {\n                    val token = generateEmployeeToken()\n                    \n                    mockMvc.perform(\n                        get(\"/api/attendance\")\n                            .param(\"employeeId\", \"1\")\n                            .param(\"startDate\", \"2024-01-01\")\n                            .param(\"endDate\", \"2024-01-31\")\n                            .header(\"Authorization\", \"Bearer $token\")\n                    )\n                        .andExpect(status().isOk)\n                        .andExpect(jsonPath(\"$\").isArray)\n                }\n            }\n        }\n        \n        describe(\"GET /api/attendance/today\") {\n            context(\"오늘 출퇴근 상태 조회할 때\") {\n                it(\"200 OK와 오늘 출퇴근 기록을 반환한다\") {\n                    val token = generateEmployeeToken()\n                    \n                    mockMvc.perform(\n                        get(\"/api/attendance/today\")\n                            .param(\"employeeId\", \"1\")\n                            .header(\"Authorization\", \"Bearer $token\")\n                    )\n                        .andExpect(status().isOk)\n                }\n            }\n        }\n        \n        // 추가 10개 테스트...\n    }\n}\n```\n\n### 4.5 ScheduleController 통합 테스트 (14개 테스트)\n### 4.6 LeaveController 통합 테스트 (15개 테스트)\n### 4.7 PayrollController 통합 테스트 (12개 테스트)\n### 4.8 NotificationController 통합 테스트 (10개 테스트)\n\n---\n\n## 5. DTO 및 공통 응답 모델 정의\n\n### 5.1 공통 에러 응답\n**위치:** `src/main/kotlin/com/lms/dto/ErrorResponse.kt`\n```kotlin\npackage com.lms.dto\n\nimport io.swagger.v3.oas.annotations.media.Schema\n\n@Schema(description = \"에러 응답\")\ndata class ErrorResponse(\n    @Schema(description = \"에러 메시지\", example = \"잘못된 요청입니다\")\n    val message: String,\n    \n    @Schema(description = \"에러 코드\", example = \"INVALID_REQUEST\")\n    val code: String,\n    \n    @Schema(description = \"타임스탬프\", example = \"2024-01-15T10:30:00\")\n    val timestamp: String\n)\n```\n\n---\n\n## 6. 테스트 실행 및 커버리지 확인\n\n### 6.1 Gradle 테스트 태스크 설정\n**위치:** `build.gradle.kts`\n```kotlin\ntasks.withType<Test> {\n    useJUnitPlatform()\n    \n    testLogging {\n        events(\"passed\", \"skipped\", \"failed\")\n        showStandardStreams = true\n    }\n}\n\n// Jacoco 코드 커버리지\nplugins {\n    jacoco\n}\n\njacoco {\n    toolVersion = \"0.8.11\"\n}\n\ntasks.jacocoTestReport {\n    dependsOn(tasks.test)\n    \n    reports {\n        xml.required.set(true)\n        html.required.set(true)\n    }\n}\n```\n\n### 6.2 테스트 실행 명령어\n```bash\n# 모든 통합 테스트 실행\n./gradlew test\n\n# 특정 테스트 클래스 실행\n./gradlew test --tests \"com.lms.controller.AuthControllerTest\"\n\n# 코드 커버리지 리포트 생성\n./gradlew jacocoTestReport\n\n# 커버리지 확인 (build/reports/jacoco/test/html/index.html)\n```",
        "testStrategy": "## 테스트 전략\n\n### 1. Swagger UI 문서 접근 확인\n```bash\n# 애플리케이션 실행\n./gradlew bootRun\n\n# 브라우저에서 Swagger UI 접근\nhttp://localhost:8080/swagger-ui.html\n\n# OpenAPI JSON 스펙 확인\nhttp://localhost:8080/api-docs\n```\n\n**검증 항목:**\n- ✅ Swagger UI 페이지가 정상적으로 로드됨\n- ✅ 8개 컨트롤러 태그가 모두 표시됨 (인증, 매장 관리, 근로자 관리, 출퇴근 관리, 근무 일정 관리, 휴가 관리, 급여 관리, 알림 관리)\n- ✅ 각 API 엔드포인트의 요청/응답 스키마가 정확하게 표시됨\n- ✅ JWT 인증 (bearerAuth) 설정이 활성화되어 있음\n- ✅ \"Authorize\" 버튼 클릭 시 토큰 입력 가능\n- ✅ 각 API의 설명, 파라미터, 응답 코드가 명확하게 문서화됨\n\n---\n\n### 2. Kotest 통합 테스트 실행\n```bash\n# 전체 통합 테스트 실행\n./gradlew test\n\n# 특정 컨트롤러 테스트만 실행\n./gradlew test --tests \"com.lms.controller.AuthControllerTest\"\n./gradlew test --tests \"com.lms.controller.StoreControllerTest\"\n./gradlew test --tests \"com.lms.controller.EmployeeControllerTest\"\n./gradlew test --tests \"com.lms.controller.AttendanceControllerTest\"\n./gradlew test --tests \"com.lms.controller.ScheduleControllerTest\"\n./gradlew test --tests \"com.lms.controller.LeaveControllerTest\"\n./gradlew test --tests \"com.lms.controller.PayrollControllerTest\"\n./gradlew test --tests \"com.lms.controller.NotificationControllerTest\"\n```\n\n**검증 항목:**\n- ✅ 110개 통합 테스트가 모두 성공적으로 실행됨\n- ✅ AuthController: 15개 테스트 통과\n- ✅ StoreController: 14개 테스트 통과\n- ✅ EmployeeController: 14개 테스트 통과\n- ✅ AttendanceController: 16개 테스트 통과\n- ✅ ScheduleController: 14개 테스트 통과\n- ✅ LeaveController: 15개 테스트 통과\n- ✅ PayrollController: 12개 테스트 통과\n- ✅ NotificationController: 10개 테스트 통과\n\n---\n\n### 3. API 엔드포인트별 기능 검증\n\n#### 3.1 인증 API 테스트\n- ✅ POST /api/auth/login: 로그인 성공 시 JWT 토큰 발급\n- ✅ POST /api/auth/login: 잘못된 비밀번호로 401 반환\n- ✅ POST /api/auth/login: 존재하지 않는 이메일로 401 반환\n- ✅ POST /api/auth/register: 관리자 권한으로 사용자 생성 성공\n- ✅ POST /api/auth/register: 중복 이메일로 400 반환\n- ✅ POST /api/auth/refresh: 유효한 Refresh Token으로 새 Access Token 발급\n\n#### 3.2 매장 관리 API 테스트\n- ✅ GET /api/stores: 전체 매장 목록 조회\n- ✅ GET /api/stores/{id}: 특정 매장 상세 조회\n- ✅ GET /api/stores/{id}: 존재하지 않는 매장 ID로 404 반환\n- ✅ POST /api/stores: SUPER_ADMIN 권한으로 매장 생성\n- ✅ PUT /api/stores/{id}: 매장 정보 수정\n- ✅ DELETE /api/stores/{id}: 매장 삭제\n\n#### 3.3 근로자 관리 API 테스트\n- ✅ GET /api/employees: 전체 근로자 목록 조회\n- ✅ GET /api/employees?storeId=1: 특정 매장 근로자 필터링\n- ✅ POST /api/employees: 새 근로자 생성\n- ✅ PUT /api/employees/{id}: 근로자 정보 수정\n- ✅ DELETE /api/employees/{id}: 근로자 삭제\n\n#### 3.4 출퇴근 관리 API 테스트\n- ✅ POST /api/attendance/check-in: 출근 체크 성공\n- ✅ POST /api/attendance/check-in: 중복 출근 시 400 반환\n- ✅ POST /api/attendance/check-out: 퇴근 체크 성공\n- ✅ POST /api/attendance/check-out: 출근하지 않은 상태에서 퇴근 시 400 반환\n- ✅ GET /api/attendance: 특정 기간 출퇴근 기록 조회\n- ✅ GET /api/attendance/today: 오늘 출퇴근 상태 조회\n\n#### 3.5 근무 일정 API 테스트\n- ✅ GET /api/schedules: 특정 기간 근무 일정 조회\n- ✅ POST /api/schedules: 근무 일정 생성\n- ✅ PUT /api/schedules/{id}: 근무 일정 수정\n- ✅ DELETE /api/schedules/{id}: 근무 일정 삭제\n\n#### 3.6 휴가 관리 API 테스트\n- ✅ POST /api/leaves: 휴가 신청\n- ✅ GET /api/leaves: 휴가 목록 조회\n- ✅ GET /api/leaves?status=PENDING: 대기 중인 휴가만 필터링\n- ✅ PUT /api/leaves/{id}/approve: 휴가 승인\n- ✅ PUT /api/leaves/{id}/reject: 휴가 거절\n\n#### 3.7 급여 관리 API 테스트\n- ✅ GET /api/payroll: 특정 월 급여 내역 조회\n- ✅ POST /api/payroll/calculate: 급여 계산 및 생성\n\n#### 3.8 알림 관리 API 테스트\n- ✅ GET /api/notifications: 알림 목록 조회\n- ✅ PUT /api/notifications/{id}/read: 알림 읽음 처리\n- ✅ PUT /api/notifications/read-all: 모든 알림 읽음 처리\n\n---\n\n### 4. 코드 커버리지 확인\n```bash\n# Jacoco 커버리지 리포트 생성\n./gradlew jacocoTestReport\n\n# 리포트 확인\nopen build/reports/jacoco/test/html/index.html\n```\n\n**목표 커버리지:**\n- ✅ 전체 라인 커버리지: 80% 이상\n- ✅ 컨트롤러 레이어: 90% 이상\n- ✅ 서비스 레이어: 85% 이상\n- ✅ 리포지토리 레이어: 75% 이상\n\n---\n\n### 5. Swagger UI를 통한 수동 테스트\n1. **JWT 토큰 발급**\n   - POST /api/auth/login 실행\n   - 응답에서 accessToken 복사\n   - \"Authorize\" 버튼 클릭 후 토큰 입력\n\n2. **각 API 엔드포인트 테스트**\n   - 매장 생성 → 매장 조회 → 매장 수정 → 매장 삭제\n   - 근로자 생성 → 출근 체크 → 퇴근 체크 → 출퇴근 기록 조회\n   - 근무 일정 생성 → 휴가 신청 → 휴가 승인\n   - 급여 계산 → 급여 조회\n\n3. **권한 검증**\n   - EMPLOYEE 토큰으로 관리자 전용 API 호출 시 403 반환 확인\n   - 토큰 없이 보호된 API 호출 시 401 반환 확인\n\n---\n\n### 6. 통합 테스트 시나리오 검증\n\n#### 시나리오 1: 근로자 출퇴근 전체 플로우\n1. 로그인 (POST /api/auth/login)\n2. 출근 체크 (POST /api/attendance/check-in)\n3. 오늘 출퇴근 상태 조회 (GET /api/attendance/today)\n4. 퇴근 체크 (POST /api/attendance/check-out)\n5. 출퇴근 기록 조회 (GET /api/attendance)\n\n#### 시나리오 2: 관리자 매장 및 근로자 관리\n1. 관리자 로그인\n2. 매장 생성 (POST /api/stores)\n3. 근로자 생성 (POST /api/employees)\n4. 근무 일정 생성 (POST /api/schedules)\n5. 근로자 목록 조회 (GET /api/employees?storeId=1)\n\n#### 시나리오 3: 휴가 신청 및 승인 플로우\n1. 근로자 로그인\n2. 휴가 신청 (POST /api/leaves)\n3. 관리자 로그인\n4. 대기 중인 휴가 조회 (GET /api/leaves?status=PENDING)\n5. 휴가 승인 (PUT /api/leaves/{id}/approve)\n\n---\n\n### 7. 성능 테스트\n```bash\n# Apache Bench를 사용한 부하 테스트\nab -n 1000 -c 10 -H \"Authorization: Bearer {token}\" http://localhost:8080/api/stores\n\n# 예상 결과\n# - 평균 응답 시간: 50ms 이하\n# - 초당 요청 처리: 200 req/s 이상\n# - 실패율: 0%\n```\n\n---\n\n### 8. 최종 검증 체크리스트\n- ✅ Springdoc OpenAPI 3.0 설정 완료\n- ✅ 8개 컨트롤러에 Swagger 어노테이션 추가 (492 lines)\n- ✅ Swagger UI에서 모든 API 문서 확인 가능\n- ✅ Kotest 통합 테스트 인프라 구축\n- ✅ 110개 통합 테스트 작성 및 통과 (1,646 lines)\n- ✅ 코드 커버리지 80% 이상 달성\n- ✅ 모든 API 엔드포인트 정상 동작 확인\n- ✅ JWT 인증 및 권한 검증 정상 작동\n- ✅ 에러 처리 및 유효성 검사 정상 작동",
        "status": "done",
        "dependencies": [
          "3",
          "4",
          "5",
          "6",
          "7",
          "9"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-01-17T03:53:25.739Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-01-17T05:52:47.874Z",
      "taskCount": 18,
      "completedCount": 13,
      "tags": [
        "master"
      ]
    }
  }
}